// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/service/kms"
	environment "github.com/telia-oss/aws-env"
)

type FakeKMSClient struct {
	CancelKeyDeletionStub        func(*kms.CancelKeyDeletionInput) (*kms.CancelKeyDeletionOutput, error)
	cancelKeyDeletionMutex       sync.RWMutex
	cancelKeyDeletionArgsForCall []struct {
		arg1 *kms.CancelKeyDeletionInput
	}
	cancelKeyDeletionReturns struct {
		result1 *kms.CancelKeyDeletionOutput
		result2 error
	}
	cancelKeyDeletionReturnsOnCall map[int]struct {
		result1 *kms.CancelKeyDeletionOutput
		result2 error
	}
	CancelKeyDeletionRequestStub        func(*kms.CancelKeyDeletionInput) (*request.Request, *kms.CancelKeyDeletionOutput)
	cancelKeyDeletionRequestMutex       sync.RWMutex
	cancelKeyDeletionRequestArgsForCall []struct {
		arg1 *kms.CancelKeyDeletionInput
	}
	cancelKeyDeletionRequestReturns struct {
		result1 *request.Request
		result2 *kms.CancelKeyDeletionOutput
	}
	cancelKeyDeletionRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.CancelKeyDeletionOutput
	}
	CancelKeyDeletionWithContextStub        func(context.Context, *kms.CancelKeyDeletionInput, ...request.Option) (*kms.CancelKeyDeletionOutput, error)
	cancelKeyDeletionWithContextMutex       sync.RWMutex
	cancelKeyDeletionWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.CancelKeyDeletionInput
		arg3 []request.Option
	}
	cancelKeyDeletionWithContextReturns struct {
		result1 *kms.CancelKeyDeletionOutput
		result2 error
	}
	cancelKeyDeletionWithContextReturnsOnCall map[int]struct {
		result1 *kms.CancelKeyDeletionOutput
		result2 error
	}
	ConnectCustomKeyStoreStub        func(*kms.ConnectCustomKeyStoreInput) (*kms.ConnectCustomKeyStoreOutput, error)
	connectCustomKeyStoreMutex       sync.RWMutex
	connectCustomKeyStoreArgsForCall []struct {
		arg1 *kms.ConnectCustomKeyStoreInput
	}
	connectCustomKeyStoreReturns struct {
		result1 *kms.ConnectCustomKeyStoreOutput
		result2 error
	}
	connectCustomKeyStoreReturnsOnCall map[int]struct {
		result1 *kms.ConnectCustomKeyStoreOutput
		result2 error
	}
	ConnectCustomKeyStoreRequestStub        func(*kms.ConnectCustomKeyStoreInput) (*request.Request, *kms.ConnectCustomKeyStoreOutput)
	connectCustomKeyStoreRequestMutex       sync.RWMutex
	connectCustomKeyStoreRequestArgsForCall []struct {
		arg1 *kms.ConnectCustomKeyStoreInput
	}
	connectCustomKeyStoreRequestReturns struct {
		result1 *request.Request
		result2 *kms.ConnectCustomKeyStoreOutput
	}
	connectCustomKeyStoreRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ConnectCustomKeyStoreOutput
	}
	ConnectCustomKeyStoreWithContextStub        func(context.Context, *kms.ConnectCustomKeyStoreInput, ...request.Option) (*kms.ConnectCustomKeyStoreOutput, error)
	connectCustomKeyStoreWithContextMutex       sync.RWMutex
	connectCustomKeyStoreWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ConnectCustomKeyStoreInput
		arg3 []request.Option
	}
	connectCustomKeyStoreWithContextReturns struct {
		result1 *kms.ConnectCustomKeyStoreOutput
		result2 error
	}
	connectCustomKeyStoreWithContextReturnsOnCall map[int]struct {
		result1 *kms.ConnectCustomKeyStoreOutput
		result2 error
	}
	CreateAliasStub        func(*kms.CreateAliasInput) (*kms.CreateAliasOutput, error)
	createAliasMutex       sync.RWMutex
	createAliasArgsForCall []struct {
		arg1 *kms.CreateAliasInput
	}
	createAliasReturns struct {
		result1 *kms.CreateAliasOutput
		result2 error
	}
	createAliasReturnsOnCall map[int]struct {
		result1 *kms.CreateAliasOutput
		result2 error
	}
	CreateAliasRequestStub        func(*kms.CreateAliasInput) (*request.Request, *kms.CreateAliasOutput)
	createAliasRequestMutex       sync.RWMutex
	createAliasRequestArgsForCall []struct {
		arg1 *kms.CreateAliasInput
	}
	createAliasRequestReturns struct {
		result1 *request.Request
		result2 *kms.CreateAliasOutput
	}
	createAliasRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.CreateAliasOutput
	}
	CreateAliasWithContextStub        func(context.Context, *kms.CreateAliasInput, ...request.Option) (*kms.CreateAliasOutput, error)
	createAliasWithContextMutex       sync.RWMutex
	createAliasWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.CreateAliasInput
		arg3 []request.Option
	}
	createAliasWithContextReturns struct {
		result1 *kms.CreateAliasOutput
		result2 error
	}
	createAliasWithContextReturnsOnCall map[int]struct {
		result1 *kms.CreateAliasOutput
		result2 error
	}
	CreateCustomKeyStoreStub        func(*kms.CreateCustomKeyStoreInput) (*kms.CreateCustomKeyStoreOutput, error)
	createCustomKeyStoreMutex       sync.RWMutex
	createCustomKeyStoreArgsForCall []struct {
		arg1 *kms.CreateCustomKeyStoreInput
	}
	createCustomKeyStoreReturns struct {
		result1 *kms.CreateCustomKeyStoreOutput
		result2 error
	}
	createCustomKeyStoreReturnsOnCall map[int]struct {
		result1 *kms.CreateCustomKeyStoreOutput
		result2 error
	}
	CreateCustomKeyStoreRequestStub        func(*kms.CreateCustomKeyStoreInput) (*request.Request, *kms.CreateCustomKeyStoreOutput)
	createCustomKeyStoreRequestMutex       sync.RWMutex
	createCustomKeyStoreRequestArgsForCall []struct {
		arg1 *kms.CreateCustomKeyStoreInput
	}
	createCustomKeyStoreRequestReturns struct {
		result1 *request.Request
		result2 *kms.CreateCustomKeyStoreOutput
	}
	createCustomKeyStoreRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.CreateCustomKeyStoreOutput
	}
	CreateCustomKeyStoreWithContextStub        func(context.Context, *kms.CreateCustomKeyStoreInput, ...request.Option) (*kms.CreateCustomKeyStoreOutput, error)
	createCustomKeyStoreWithContextMutex       sync.RWMutex
	createCustomKeyStoreWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.CreateCustomKeyStoreInput
		arg3 []request.Option
	}
	createCustomKeyStoreWithContextReturns struct {
		result1 *kms.CreateCustomKeyStoreOutput
		result2 error
	}
	createCustomKeyStoreWithContextReturnsOnCall map[int]struct {
		result1 *kms.CreateCustomKeyStoreOutput
		result2 error
	}
	CreateGrantStub        func(*kms.CreateGrantInput) (*kms.CreateGrantOutput, error)
	createGrantMutex       sync.RWMutex
	createGrantArgsForCall []struct {
		arg1 *kms.CreateGrantInput
	}
	createGrantReturns struct {
		result1 *kms.CreateGrantOutput
		result2 error
	}
	createGrantReturnsOnCall map[int]struct {
		result1 *kms.CreateGrantOutput
		result2 error
	}
	CreateGrantRequestStub        func(*kms.CreateGrantInput) (*request.Request, *kms.CreateGrantOutput)
	createGrantRequestMutex       sync.RWMutex
	createGrantRequestArgsForCall []struct {
		arg1 *kms.CreateGrantInput
	}
	createGrantRequestReturns struct {
		result1 *request.Request
		result2 *kms.CreateGrantOutput
	}
	createGrantRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.CreateGrantOutput
	}
	CreateGrantWithContextStub        func(context.Context, *kms.CreateGrantInput, ...request.Option) (*kms.CreateGrantOutput, error)
	createGrantWithContextMutex       sync.RWMutex
	createGrantWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.CreateGrantInput
		arg3 []request.Option
	}
	createGrantWithContextReturns struct {
		result1 *kms.CreateGrantOutput
		result2 error
	}
	createGrantWithContextReturnsOnCall map[int]struct {
		result1 *kms.CreateGrantOutput
		result2 error
	}
	CreateKeyStub        func(*kms.CreateKeyInput) (*kms.CreateKeyOutput, error)
	createKeyMutex       sync.RWMutex
	createKeyArgsForCall []struct {
		arg1 *kms.CreateKeyInput
	}
	createKeyReturns struct {
		result1 *kms.CreateKeyOutput
		result2 error
	}
	createKeyReturnsOnCall map[int]struct {
		result1 *kms.CreateKeyOutput
		result2 error
	}
	CreateKeyRequestStub        func(*kms.CreateKeyInput) (*request.Request, *kms.CreateKeyOutput)
	createKeyRequestMutex       sync.RWMutex
	createKeyRequestArgsForCall []struct {
		arg1 *kms.CreateKeyInput
	}
	createKeyRequestReturns struct {
		result1 *request.Request
		result2 *kms.CreateKeyOutput
	}
	createKeyRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.CreateKeyOutput
	}
	CreateKeyWithContextStub        func(context.Context, *kms.CreateKeyInput, ...request.Option) (*kms.CreateKeyOutput, error)
	createKeyWithContextMutex       sync.RWMutex
	createKeyWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.CreateKeyInput
		arg3 []request.Option
	}
	createKeyWithContextReturns struct {
		result1 *kms.CreateKeyOutput
		result2 error
	}
	createKeyWithContextReturnsOnCall map[int]struct {
		result1 *kms.CreateKeyOutput
		result2 error
	}
	DecryptStub        func(*kms.DecryptInput) (*kms.DecryptOutput, error)
	decryptMutex       sync.RWMutex
	decryptArgsForCall []struct {
		arg1 *kms.DecryptInput
	}
	decryptReturns struct {
		result1 *kms.DecryptOutput
		result2 error
	}
	decryptReturnsOnCall map[int]struct {
		result1 *kms.DecryptOutput
		result2 error
	}
	DecryptRequestStub        func(*kms.DecryptInput) (*request.Request, *kms.DecryptOutput)
	decryptRequestMutex       sync.RWMutex
	decryptRequestArgsForCall []struct {
		arg1 *kms.DecryptInput
	}
	decryptRequestReturns struct {
		result1 *request.Request
		result2 *kms.DecryptOutput
	}
	decryptRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.DecryptOutput
	}
	DecryptWithContextStub        func(context.Context, *kms.DecryptInput, ...request.Option) (*kms.DecryptOutput, error)
	decryptWithContextMutex       sync.RWMutex
	decryptWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.DecryptInput
		arg3 []request.Option
	}
	decryptWithContextReturns struct {
		result1 *kms.DecryptOutput
		result2 error
	}
	decryptWithContextReturnsOnCall map[int]struct {
		result1 *kms.DecryptOutput
		result2 error
	}
	DeleteAliasStub        func(*kms.DeleteAliasInput) (*kms.DeleteAliasOutput, error)
	deleteAliasMutex       sync.RWMutex
	deleteAliasArgsForCall []struct {
		arg1 *kms.DeleteAliasInput
	}
	deleteAliasReturns struct {
		result1 *kms.DeleteAliasOutput
		result2 error
	}
	deleteAliasReturnsOnCall map[int]struct {
		result1 *kms.DeleteAliasOutput
		result2 error
	}
	DeleteAliasRequestStub        func(*kms.DeleteAliasInput) (*request.Request, *kms.DeleteAliasOutput)
	deleteAliasRequestMutex       sync.RWMutex
	deleteAliasRequestArgsForCall []struct {
		arg1 *kms.DeleteAliasInput
	}
	deleteAliasRequestReturns struct {
		result1 *request.Request
		result2 *kms.DeleteAliasOutput
	}
	deleteAliasRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.DeleteAliasOutput
	}
	DeleteAliasWithContextStub        func(context.Context, *kms.DeleteAliasInput, ...request.Option) (*kms.DeleteAliasOutput, error)
	deleteAliasWithContextMutex       sync.RWMutex
	deleteAliasWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.DeleteAliasInput
		arg3 []request.Option
	}
	deleteAliasWithContextReturns struct {
		result1 *kms.DeleteAliasOutput
		result2 error
	}
	deleteAliasWithContextReturnsOnCall map[int]struct {
		result1 *kms.DeleteAliasOutput
		result2 error
	}
	DeleteCustomKeyStoreStub        func(*kms.DeleteCustomKeyStoreInput) (*kms.DeleteCustomKeyStoreOutput, error)
	deleteCustomKeyStoreMutex       sync.RWMutex
	deleteCustomKeyStoreArgsForCall []struct {
		arg1 *kms.DeleteCustomKeyStoreInput
	}
	deleteCustomKeyStoreReturns struct {
		result1 *kms.DeleteCustomKeyStoreOutput
		result2 error
	}
	deleteCustomKeyStoreReturnsOnCall map[int]struct {
		result1 *kms.DeleteCustomKeyStoreOutput
		result2 error
	}
	DeleteCustomKeyStoreRequestStub        func(*kms.DeleteCustomKeyStoreInput) (*request.Request, *kms.DeleteCustomKeyStoreOutput)
	deleteCustomKeyStoreRequestMutex       sync.RWMutex
	deleteCustomKeyStoreRequestArgsForCall []struct {
		arg1 *kms.DeleteCustomKeyStoreInput
	}
	deleteCustomKeyStoreRequestReturns struct {
		result1 *request.Request
		result2 *kms.DeleteCustomKeyStoreOutput
	}
	deleteCustomKeyStoreRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.DeleteCustomKeyStoreOutput
	}
	DeleteCustomKeyStoreWithContextStub        func(context.Context, *kms.DeleteCustomKeyStoreInput, ...request.Option) (*kms.DeleteCustomKeyStoreOutput, error)
	deleteCustomKeyStoreWithContextMutex       sync.RWMutex
	deleteCustomKeyStoreWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.DeleteCustomKeyStoreInput
		arg3 []request.Option
	}
	deleteCustomKeyStoreWithContextReturns struct {
		result1 *kms.DeleteCustomKeyStoreOutput
		result2 error
	}
	deleteCustomKeyStoreWithContextReturnsOnCall map[int]struct {
		result1 *kms.DeleteCustomKeyStoreOutput
		result2 error
	}
	DeleteImportedKeyMaterialStub        func(*kms.DeleteImportedKeyMaterialInput) (*kms.DeleteImportedKeyMaterialOutput, error)
	deleteImportedKeyMaterialMutex       sync.RWMutex
	deleteImportedKeyMaterialArgsForCall []struct {
		arg1 *kms.DeleteImportedKeyMaterialInput
	}
	deleteImportedKeyMaterialReturns struct {
		result1 *kms.DeleteImportedKeyMaterialOutput
		result2 error
	}
	deleteImportedKeyMaterialReturnsOnCall map[int]struct {
		result1 *kms.DeleteImportedKeyMaterialOutput
		result2 error
	}
	DeleteImportedKeyMaterialRequestStub        func(*kms.DeleteImportedKeyMaterialInput) (*request.Request, *kms.DeleteImportedKeyMaterialOutput)
	deleteImportedKeyMaterialRequestMutex       sync.RWMutex
	deleteImportedKeyMaterialRequestArgsForCall []struct {
		arg1 *kms.DeleteImportedKeyMaterialInput
	}
	deleteImportedKeyMaterialRequestReturns struct {
		result1 *request.Request
		result2 *kms.DeleteImportedKeyMaterialOutput
	}
	deleteImportedKeyMaterialRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.DeleteImportedKeyMaterialOutput
	}
	DeleteImportedKeyMaterialWithContextStub        func(context.Context, *kms.DeleteImportedKeyMaterialInput, ...request.Option) (*kms.DeleteImportedKeyMaterialOutput, error)
	deleteImportedKeyMaterialWithContextMutex       sync.RWMutex
	deleteImportedKeyMaterialWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.DeleteImportedKeyMaterialInput
		arg3 []request.Option
	}
	deleteImportedKeyMaterialWithContextReturns struct {
		result1 *kms.DeleteImportedKeyMaterialOutput
		result2 error
	}
	deleteImportedKeyMaterialWithContextReturnsOnCall map[int]struct {
		result1 *kms.DeleteImportedKeyMaterialOutput
		result2 error
	}
	DescribeCustomKeyStoresStub        func(*kms.DescribeCustomKeyStoresInput) (*kms.DescribeCustomKeyStoresOutput, error)
	describeCustomKeyStoresMutex       sync.RWMutex
	describeCustomKeyStoresArgsForCall []struct {
		arg1 *kms.DescribeCustomKeyStoresInput
	}
	describeCustomKeyStoresReturns struct {
		result1 *kms.DescribeCustomKeyStoresOutput
		result2 error
	}
	describeCustomKeyStoresReturnsOnCall map[int]struct {
		result1 *kms.DescribeCustomKeyStoresOutput
		result2 error
	}
	DescribeCustomKeyStoresRequestStub        func(*kms.DescribeCustomKeyStoresInput) (*request.Request, *kms.DescribeCustomKeyStoresOutput)
	describeCustomKeyStoresRequestMutex       sync.RWMutex
	describeCustomKeyStoresRequestArgsForCall []struct {
		arg1 *kms.DescribeCustomKeyStoresInput
	}
	describeCustomKeyStoresRequestReturns struct {
		result1 *request.Request
		result2 *kms.DescribeCustomKeyStoresOutput
	}
	describeCustomKeyStoresRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.DescribeCustomKeyStoresOutput
	}
	DescribeCustomKeyStoresWithContextStub        func(context.Context, *kms.DescribeCustomKeyStoresInput, ...request.Option) (*kms.DescribeCustomKeyStoresOutput, error)
	describeCustomKeyStoresWithContextMutex       sync.RWMutex
	describeCustomKeyStoresWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.DescribeCustomKeyStoresInput
		arg3 []request.Option
	}
	describeCustomKeyStoresWithContextReturns struct {
		result1 *kms.DescribeCustomKeyStoresOutput
		result2 error
	}
	describeCustomKeyStoresWithContextReturnsOnCall map[int]struct {
		result1 *kms.DescribeCustomKeyStoresOutput
		result2 error
	}
	DescribeKeyStub        func(*kms.DescribeKeyInput) (*kms.DescribeKeyOutput, error)
	describeKeyMutex       sync.RWMutex
	describeKeyArgsForCall []struct {
		arg1 *kms.DescribeKeyInput
	}
	describeKeyReturns struct {
		result1 *kms.DescribeKeyOutput
		result2 error
	}
	describeKeyReturnsOnCall map[int]struct {
		result1 *kms.DescribeKeyOutput
		result2 error
	}
	DescribeKeyRequestStub        func(*kms.DescribeKeyInput) (*request.Request, *kms.DescribeKeyOutput)
	describeKeyRequestMutex       sync.RWMutex
	describeKeyRequestArgsForCall []struct {
		arg1 *kms.DescribeKeyInput
	}
	describeKeyRequestReturns struct {
		result1 *request.Request
		result2 *kms.DescribeKeyOutput
	}
	describeKeyRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.DescribeKeyOutput
	}
	DescribeKeyWithContextStub        func(context.Context, *kms.DescribeKeyInput, ...request.Option) (*kms.DescribeKeyOutput, error)
	describeKeyWithContextMutex       sync.RWMutex
	describeKeyWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.DescribeKeyInput
		arg3 []request.Option
	}
	describeKeyWithContextReturns struct {
		result1 *kms.DescribeKeyOutput
		result2 error
	}
	describeKeyWithContextReturnsOnCall map[int]struct {
		result1 *kms.DescribeKeyOutput
		result2 error
	}
	DisableKeyStub        func(*kms.DisableKeyInput) (*kms.DisableKeyOutput, error)
	disableKeyMutex       sync.RWMutex
	disableKeyArgsForCall []struct {
		arg1 *kms.DisableKeyInput
	}
	disableKeyReturns struct {
		result1 *kms.DisableKeyOutput
		result2 error
	}
	disableKeyReturnsOnCall map[int]struct {
		result1 *kms.DisableKeyOutput
		result2 error
	}
	DisableKeyRequestStub        func(*kms.DisableKeyInput) (*request.Request, *kms.DisableKeyOutput)
	disableKeyRequestMutex       sync.RWMutex
	disableKeyRequestArgsForCall []struct {
		arg1 *kms.DisableKeyInput
	}
	disableKeyRequestReturns struct {
		result1 *request.Request
		result2 *kms.DisableKeyOutput
	}
	disableKeyRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.DisableKeyOutput
	}
	DisableKeyRotationStub        func(*kms.DisableKeyRotationInput) (*kms.DisableKeyRotationOutput, error)
	disableKeyRotationMutex       sync.RWMutex
	disableKeyRotationArgsForCall []struct {
		arg1 *kms.DisableKeyRotationInput
	}
	disableKeyRotationReturns struct {
		result1 *kms.DisableKeyRotationOutput
		result2 error
	}
	disableKeyRotationReturnsOnCall map[int]struct {
		result1 *kms.DisableKeyRotationOutput
		result2 error
	}
	DisableKeyRotationRequestStub        func(*kms.DisableKeyRotationInput) (*request.Request, *kms.DisableKeyRotationOutput)
	disableKeyRotationRequestMutex       sync.RWMutex
	disableKeyRotationRequestArgsForCall []struct {
		arg1 *kms.DisableKeyRotationInput
	}
	disableKeyRotationRequestReturns struct {
		result1 *request.Request
		result2 *kms.DisableKeyRotationOutput
	}
	disableKeyRotationRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.DisableKeyRotationOutput
	}
	DisableKeyRotationWithContextStub        func(context.Context, *kms.DisableKeyRotationInput, ...request.Option) (*kms.DisableKeyRotationOutput, error)
	disableKeyRotationWithContextMutex       sync.RWMutex
	disableKeyRotationWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.DisableKeyRotationInput
		arg3 []request.Option
	}
	disableKeyRotationWithContextReturns struct {
		result1 *kms.DisableKeyRotationOutput
		result2 error
	}
	disableKeyRotationWithContextReturnsOnCall map[int]struct {
		result1 *kms.DisableKeyRotationOutput
		result2 error
	}
	DisableKeyWithContextStub        func(context.Context, *kms.DisableKeyInput, ...request.Option) (*kms.DisableKeyOutput, error)
	disableKeyWithContextMutex       sync.RWMutex
	disableKeyWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.DisableKeyInput
		arg3 []request.Option
	}
	disableKeyWithContextReturns struct {
		result1 *kms.DisableKeyOutput
		result2 error
	}
	disableKeyWithContextReturnsOnCall map[int]struct {
		result1 *kms.DisableKeyOutput
		result2 error
	}
	DisconnectCustomKeyStoreStub        func(*kms.DisconnectCustomKeyStoreInput) (*kms.DisconnectCustomKeyStoreOutput, error)
	disconnectCustomKeyStoreMutex       sync.RWMutex
	disconnectCustomKeyStoreArgsForCall []struct {
		arg1 *kms.DisconnectCustomKeyStoreInput
	}
	disconnectCustomKeyStoreReturns struct {
		result1 *kms.DisconnectCustomKeyStoreOutput
		result2 error
	}
	disconnectCustomKeyStoreReturnsOnCall map[int]struct {
		result1 *kms.DisconnectCustomKeyStoreOutput
		result2 error
	}
	DisconnectCustomKeyStoreRequestStub        func(*kms.DisconnectCustomKeyStoreInput) (*request.Request, *kms.DisconnectCustomKeyStoreOutput)
	disconnectCustomKeyStoreRequestMutex       sync.RWMutex
	disconnectCustomKeyStoreRequestArgsForCall []struct {
		arg1 *kms.DisconnectCustomKeyStoreInput
	}
	disconnectCustomKeyStoreRequestReturns struct {
		result1 *request.Request
		result2 *kms.DisconnectCustomKeyStoreOutput
	}
	disconnectCustomKeyStoreRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.DisconnectCustomKeyStoreOutput
	}
	DisconnectCustomKeyStoreWithContextStub        func(context.Context, *kms.DisconnectCustomKeyStoreInput, ...request.Option) (*kms.DisconnectCustomKeyStoreOutput, error)
	disconnectCustomKeyStoreWithContextMutex       sync.RWMutex
	disconnectCustomKeyStoreWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.DisconnectCustomKeyStoreInput
		arg3 []request.Option
	}
	disconnectCustomKeyStoreWithContextReturns struct {
		result1 *kms.DisconnectCustomKeyStoreOutput
		result2 error
	}
	disconnectCustomKeyStoreWithContextReturnsOnCall map[int]struct {
		result1 *kms.DisconnectCustomKeyStoreOutput
		result2 error
	}
	EnableKeyStub        func(*kms.EnableKeyInput) (*kms.EnableKeyOutput, error)
	enableKeyMutex       sync.RWMutex
	enableKeyArgsForCall []struct {
		arg1 *kms.EnableKeyInput
	}
	enableKeyReturns struct {
		result1 *kms.EnableKeyOutput
		result2 error
	}
	enableKeyReturnsOnCall map[int]struct {
		result1 *kms.EnableKeyOutput
		result2 error
	}
	EnableKeyRequestStub        func(*kms.EnableKeyInput) (*request.Request, *kms.EnableKeyOutput)
	enableKeyRequestMutex       sync.RWMutex
	enableKeyRequestArgsForCall []struct {
		arg1 *kms.EnableKeyInput
	}
	enableKeyRequestReturns struct {
		result1 *request.Request
		result2 *kms.EnableKeyOutput
	}
	enableKeyRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.EnableKeyOutput
	}
	EnableKeyRotationStub        func(*kms.EnableKeyRotationInput) (*kms.EnableKeyRotationOutput, error)
	enableKeyRotationMutex       sync.RWMutex
	enableKeyRotationArgsForCall []struct {
		arg1 *kms.EnableKeyRotationInput
	}
	enableKeyRotationReturns struct {
		result1 *kms.EnableKeyRotationOutput
		result2 error
	}
	enableKeyRotationReturnsOnCall map[int]struct {
		result1 *kms.EnableKeyRotationOutput
		result2 error
	}
	EnableKeyRotationRequestStub        func(*kms.EnableKeyRotationInput) (*request.Request, *kms.EnableKeyRotationOutput)
	enableKeyRotationRequestMutex       sync.RWMutex
	enableKeyRotationRequestArgsForCall []struct {
		arg1 *kms.EnableKeyRotationInput
	}
	enableKeyRotationRequestReturns struct {
		result1 *request.Request
		result2 *kms.EnableKeyRotationOutput
	}
	enableKeyRotationRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.EnableKeyRotationOutput
	}
	EnableKeyRotationWithContextStub        func(context.Context, *kms.EnableKeyRotationInput, ...request.Option) (*kms.EnableKeyRotationOutput, error)
	enableKeyRotationWithContextMutex       sync.RWMutex
	enableKeyRotationWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.EnableKeyRotationInput
		arg3 []request.Option
	}
	enableKeyRotationWithContextReturns struct {
		result1 *kms.EnableKeyRotationOutput
		result2 error
	}
	enableKeyRotationWithContextReturnsOnCall map[int]struct {
		result1 *kms.EnableKeyRotationOutput
		result2 error
	}
	EnableKeyWithContextStub        func(context.Context, *kms.EnableKeyInput, ...request.Option) (*kms.EnableKeyOutput, error)
	enableKeyWithContextMutex       sync.RWMutex
	enableKeyWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.EnableKeyInput
		arg3 []request.Option
	}
	enableKeyWithContextReturns struct {
		result1 *kms.EnableKeyOutput
		result2 error
	}
	enableKeyWithContextReturnsOnCall map[int]struct {
		result1 *kms.EnableKeyOutput
		result2 error
	}
	EncryptStub        func(*kms.EncryptInput) (*kms.EncryptOutput, error)
	encryptMutex       sync.RWMutex
	encryptArgsForCall []struct {
		arg1 *kms.EncryptInput
	}
	encryptReturns struct {
		result1 *kms.EncryptOutput
		result2 error
	}
	encryptReturnsOnCall map[int]struct {
		result1 *kms.EncryptOutput
		result2 error
	}
	EncryptRequestStub        func(*kms.EncryptInput) (*request.Request, *kms.EncryptOutput)
	encryptRequestMutex       sync.RWMutex
	encryptRequestArgsForCall []struct {
		arg1 *kms.EncryptInput
	}
	encryptRequestReturns struct {
		result1 *request.Request
		result2 *kms.EncryptOutput
	}
	encryptRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.EncryptOutput
	}
	EncryptWithContextStub        func(context.Context, *kms.EncryptInput, ...request.Option) (*kms.EncryptOutput, error)
	encryptWithContextMutex       sync.RWMutex
	encryptWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.EncryptInput
		arg3 []request.Option
	}
	encryptWithContextReturns struct {
		result1 *kms.EncryptOutput
		result2 error
	}
	encryptWithContextReturnsOnCall map[int]struct {
		result1 *kms.EncryptOutput
		result2 error
	}
	GenerateDataKeyStub        func(*kms.GenerateDataKeyInput) (*kms.GenerateDataKeyOutput, error)
	generateDataKeyMutex       sync.RWMutex
	generateDataKeyArgsForCall []struct {
		arg1 *kms.GenerateDataKeyInput
	}
	generateDataKeyReturns struct {
		result1 *kms.GenerateDataKeyOutput
		result2 error
	}
	generateDataKeyReturnsOnCall map[int]struct {
		result1 *kms.GenerateDataKeyOutput
		result2 error
	}
	GenerateDataKeyPairStub        func(*kms.GenerateDataKeyPairInput) (*kms.GenerateDataKeyPairOutput, error)
	generateDataKeyPairMutex       sync.RWMutex
	generateDataKeyPairArgsForCall []struct {
		arg1 *kms.GenerateDataKeyPairInput
	}
	generateDataKeyPairReturns struct {
		result1 *kms.GenerateDataKeyPairOutput
		result2 error
	}
	generateDataKeyPairReturnsOnCall map[int]struct {
		result1 *kms.GenerateDataKeyPairOutput
		result2 error
	}
	GenerateDataKeyPairRequestStub        func(*kms.GenerateDataKeyPairInput) (*request.Request, *kms.GenerateDataKeyPairOutput)
	generateDataKeyPairRequestMutex       sync.RWMutex
	generateDataKeyPairRequestArgsForCall []struct {
		arg1 *kms.GenerateDataKeyPairInput
	}
	generateDataKeyPairRequestReturns struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyPairOutput
	}
	generateDataKeyPairRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyPairOutput
	}
	GenerateDataKeyPairWithContextStub        func(context.Context, *kms.GenerateDataKeyPairInput, ...request.Option) (*kms.GenerateDataKeyPairOutput, error)
	generateDataKeyPairWithContextMutex       sync.RWMutex
	generateDataKeyPairWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.GenerateDataKeyPairInput
		arg3 []request.Option
	}
	generateDataKeyPairWithContextReturns struct {
		result1 *kms.GenerateDataKeyPairOutput
		result2 error
	}
	generateDataKeyPairWithContextReturnsOnCall map[int]struct {
		result1 *kms.GenerateDataKeyPairOutput
		result2 error
	}
	GenerateDataKeyPairWithoutPlaintextStub        func(*kms.GenerateDataKeyPairWithoutPlaintextInput) (*kms.GenerateDataKeyPairWithoutPlaintextOutput, error)
	generateDataKeyPairWithoutPlaintextMutex       sync.RWMutex
	generateDataKeyPairWithoutPlaintextArgsForCall []struct {
		arg1 *kms.GenerateDataKeyPairWithoutPlaintextInput
	}
	generateDataKeyPairWithoutPlaintextReturns struct {
		result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput
		result2 error
	}
	generateDataKeyPairWithoutPlaintextReturnsOnCall map[int]struct {
		result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput
		result2 error
	}
	GenerateDataKeyPairWithoutPlaintextRequestStub        func(*kms.GenerateDataKeyPairWithoutPlaintextInput) (*request.Request, *kms.GenerateDataKeyPairWithoutPlaintextOutput)
	generateDataKeyPairWithoutPlaintextRequestMutex       sync.RWMutex
	generateDataKeyPairWithoutPlaintextRequestArgsForCall []struct {
		arg1 *kms.GenerateDataKeyPairWithoutPlaintextInput
	}
	generateDataKeyPairWithoutPlaintextRequestReturns struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyPairWithoutPlaintextOutput
	}
	generateDataKeyPairWithoutPlaintextRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyPairWithoutPlaintextOutput
	}
	GenerateDataKeyPairWithoutPlaintextWithContextStub        func(context.Context, *kms.GenerateDataKeyPairWithoutPlaintextInput, ...request.Option) (*kms.GenerateDataKeyPairWithoutPlaintextOutput, error)
	generateDataKeyPairWithoutPlaintextWithContextMutex       sync.RWMutex
	generateDataKeyPairWithoutPlaintextWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.GenerateDataKeyPairWithoutPlaintextInput
		arg3 []request.Option
	}
	generateDataKeyPairWithoutPlaintextWithContextReturns struct {
		result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput
		result2 error
	}
	generateDataKeyPairWithoutPlaintextWithContextReturnsOnCall map[int]struct {
		result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput
		result2 error
	}
	GenerateDataKeyRequestStub        func(*kms.GenerateDataKeyInput) (*request.Request, *kms.GenerateDataKeyOutput)
	generateDataKeyRequestMutex       sync.RWMutex
	generateDataKeyRequestArgsForCall []struct {
		arg1 *kms.GenerateDataKeyInput
	}
	generateDataKeyRequestReturns struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyOutput
	}
	generateDataKeyRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyOutput
	}
	GenerateDataKeyWithContextStub        func(context.Context, *kms.GenerateDataKeyInput, ...request.Option) (*kms.GenerateDataKeyOutput, error)
	generateDataKeyWithContextMutex       sync.RWMutex
	generateDataKeyWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.GenerateDataKeyInput
		arg3 []request.Option
	}
	generateDataKeyWithContextReturns struct {
		result1 *kms.GenerateDataKeyOutput
		result2 error
	}
	generateDataKeyWithContextReturnsOnCall map[int]struct {
		result1 *kms.GenerateDataKeyOutput
		result2 error
	}
	GenerateDataKeyWithoutPlaintextStub        func(*kms.GenerateDataKeyWithoutPlaintextInput) (*kms.GenerateDataKeyWithoutPlaintextOutput, error)
	generateDataKeyWithoutPlaintextMutex       sync.RWMutex
	generateDataKeyWithoutPlaintextArgsForCall []struct {
		arg1 *kms.GenerateDataKeyWithoutPlaintextInput
	}
	generateDataKeyWithoutPlaintextReturns struct {
		result1 *kms.GenerateDataKeyWithoutPlaintextOutput
		result2 error
	}
	generateDataKeyWithoutPlaintextReturnsOnCall map[int]struct {
		result1 *kms.GenerateDataKeyWithoutPlaintextOutput
		result2 error
	}
	GenerateDataKeyWithoutPlaintextRequestStub        func(*kms.GenerateDataKeyWithoutPlaintextInput) (*request.Request, *kms.GenerateDataKeyWithoutPlaintextOutput)
	generateDataKeyWithoutPlaintextRequestMutex       sync.RWMutex
	generateDataKeyWithoutPlaintextRequestArgsForCall []struct {
		arg1 *kms.GenerateDataKeyWithoutPlaintextInput
	}
	generateDataKeyWithoutPlaintextRequestReturns struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyWithoutPlaintextOutput
	}
	generateDataKeyWithoutPlaintextRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyWithoutPlaintextOutput
	}
	GenerateDataKeyWithoutPlaintextWithContextStub        func(context.Context, *kms.GenerateDataKeyWithoutPlaintextInput, ...request.Option) (*kms.GenerateDataKeyWithoutPlaintextOutput, error)
	generateDataKeyWithoutPlaintextWithContextMutex       sync.RWMutex
	generateDataKeyWithoutPlaintextWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.GenerateDataKeyWithoutPlaintextInput
		arg3 []request.Option
	}
	generateDataKeyWithoutPlaintextWithContextReturns struct {
		result1 *kms.GenerateDataKeyWithoutPlaintextOutput
		result2 error
	}
	generateDataKeyWithoutPlaintextWithContextReturnsOnCall map[int]struct {
		result1 *kms.GenerateDataKeyWithoutPlaintextOutput
		result2 error
	}
	GenerateMacStub        func(*kms.GenerateMacInput) (*kms.GenerateMacOutput, error)
	generateMacMutex       sync.RWMutex
	generateMacArgsForCall []struct {
		arg1 *kms.GenerateMacInput
	}
	generateMacReturns struct {
		result1 *kms.GenerateMacOutput
		result2 error
	}
	generateMacReturnsOnCall map[int]struct {
		result1 *kms.GenerateMacOutput
		result2 error
	}
	GenerateMacRequestStub        func(*kms.GenerateMacInput) (*request.Request, *kms.GenerateMacOutput)
	generateMacRequestMutex       sync.RWMutex
	generateMacRequestArgsForCall []struct {
		arg1 *kms.GenerateMacInput
	}
	generateMacRequestReturns struct {
		result1 *request.Request
		result2 *kms.GenerateMacOutput
	}
	generateMacRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.GenerateMacOutput
	}
	GenerateMacWithContextStub        func(context.Context, *kms.GenerateMacInput, ...request.Option) (*kms.GenerateMacOutput, error)
	generateMacWithContextMutex       sync.RWMutex
	generateMacWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.GenerateMacInput
		arg3 []request.Option
	}
	generateMacWithContextReturns struct {
		result1 *kms.GenerateMacOutput
		result2 error
	}
	generateMacWithContextReturnsOnCall map[int]struct {
		result1 *kms.GenerateMacOutput
		result2 error
	}
	GenerateRandomStub        func(*kms.GenerateRandomInput) (*kms.GenerateRandomOutput, error)
	generateRandomMutex       sync.RWMutex
	generateRandomArgsForCall []struct {
		arg1 *kms.GenerateRandomInput
	}
	generateRandomReturns struct {
		result1 *kms.GenerateRandomOutput
		result2 error
	}
	generateRandomReturnsOnCall map[int]struct {
		result1 *kms.GenerateRandomOutput
		result2 error
	}
	GenerateRandomRequestStub        func(*kms.GenerateRandomInput) (*request.Request, *kms.GenerateRandomOutput)
	generateRandomRequestMutex       sync.RWMutex
	generateRandomRequestArgsForCall []struct {
		arg1 *kms.GenerateRandomInput
	}
	generateRandomRequestReturns struct {
		result1 *request.Request
		result2 *kms.GenerateRandomOutput
	}
	generateRandomRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.GenerateRandomOutput
	}
	GenerateRandomWithContextStub        func(context.Context, *kms.GenerateRandomInput, ...request.Option) (*kms.GenerateRandomOutput, error)
	generateRandomWithContextMutex       sync.RWMutex
	generateRandomWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.GenerateRandomInput
		arg3 []request.Option
	}
	generateRandomWithContextReturns struct {
		result1 *kms.GenerateRandomOutput
		result2 error
	}
	generateRandomWithContextReturnsOnCall map[int]struct {
		result1 *kms.GenerateRandomOutput
		result2 error
	}
	GetKeyPolicyStub        func(*kms.GetKeyPolicyInput) (*kms.GetKeyPolicyOutput, error)
	getKeyPolicyMutex       sync.RWMutex
	getKeyPolicyArgsForCall []struct {
		arg1 *kms.GetKeyPolicyInput
	}
	getKeyPolicyReturns struct {
		result1 *kms.GetKeyPolicyOutput
		result2 error
	}
	getKeyPolicyReturnsOnCall map[int]struct {
		result1 *kms.GetKeyPolicyOutput
		result2 error
	}
	GetKeyPolicyRequestStub        func(*kms.GetKeyPolicyInput) (*request.Request, *kms.GetKeyPolicyOutput)
	getKeyPolicyRequestMutex       sync.RWMutex
	getKeyPolicyRequestArgsForCall []struct {
		arg1 *kms.GetKeyPolicyInput
	}
	getKeyPolicyRequestReturns struct {
		result1 *request.Request
		result2 *kms.GetKeyPolicyOutput
	}
	getKeyPolicyRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.GetKeyPolicyOutput
	}
	GetKeyPolicyWithContextStub        func(context.Context, *kms.GetKeyPolicyInput, ...request.Option) (*kms.GetKeyPolicyOutput, error)
	getKeyPolicyWithContextMutex       sync.RWMutex
	getKeyPolicyWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.GetKeyPolicyInput
		arg3 []request.Option
	}
	getKeyPolicyWithContextReturns struct {
		result1 *kms.GetKeyPolicyOutput
		result2 error
	}
	getKeyPolicyWithContextReturnsOnCall map[int]struct {
		result1 *kms.GetKeyPolicyOutput
		result2 error
	}
	GetKeyRotationStatusStub        func(*kms.GetKeyRotationStatusInput) (*kms.GetKeyRotationStatusOutput, error)
	getKeyRotationStatusMutex       sync.RWMutex
	getKeyRotationStatusArgsForCall []struct {
		arg1 *kms.GetKeyRotationStatusInput
	}
	getKeyRotationStatusReturns struct {
		result1 *kms.GetKeyRotationStatusOutput
		result2 error
	}
	getKeyRotationStatusReturnsOnCall map[int]struct {
		result1 *kms.GetKeyRotationStatusOutput
		result2 error
	}
	GetKeyRotationStatusRequestStub        func(*kms.GetKeyRotationStatusInput) (*request.Request, *kms.GetKeyRotationStatusOutput)
	getKeyRotationStatusRequestMutex       sync.RWMutex
	getKeyRotationStatusRequestArgsForCall []struct {
		arg1 *kms.GetKeyRotationStatusInput
	}
	getKeyRotationStatusRequestReturns struct {
		result1 *request.Request
		result2 *kms.GetKeyRotationStatusOutput
	}
	getKeyRotationStatusRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.GetKeyRotationStatusOutput
	}
	GetKeyRotationStatusWithContextStub        func(context.Context, *kms.GetKeyRotationStatusInput, ...request.Option) (*kms.GetKeyRotationStatusOutput, error)
	getKeyRotationStatusWithContextMutex       sync.RWMutex
	getKeyRotationStatusWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.GetKeyRotationStatusInput
		arg3 []request.Option
	}
	getKeyRotationStatusWithContextReturns struct {
		result1 *kms.GetKeyRotationStatusOutput
		result2 error
	}
	getKeyRotationStatusWithContextReturnsOnCall map[int]struct {
		result1 *kms.GetKeyRotationStatusOutput
		result2 error
	}
	GetParametersForImportStub        func(*kms.GetParametersForImportInput) (*kms.GetParametersForImportOutput, error)
	getParametersForImportMutex       sync.RWMutex
	getParametersForImportArgsForCall []struct {
		arg1 *kms.GetParametersForImportInput
	}
	getParametersForImportReturns struct {
		result1 *kms.GetParametersForImportOutput
		result2 error
	}
	getParametersForImportReturnsOnCall map[int]struct {
		result1 *kms.GetParametersForImportOutput
		result2 error
	}
	GetParametersForImportRequestStub        func(*kms.GetParametersForImportInput) (*request.Request, *kms.GetParametersForImportOutput)
	getParametersForImportRequestMutex       sync.RWMutex
	getParametersForImportRequestArgsForCall []struct {
		arg1 *kms.GetParametersForImportInput
	}
	getParametersForImportRequestReturns struct {
		result1 *request.Request
		result2 *kms.GetParametersForImportOutput
	}
	getParametersForImportRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.GetParametersForImportOutput
	}
	GetParametersForImportWithContextStub        func(context.Context, *kms.GetParametersForImportInput, ...request.Option) (*kms.GetParametersForImportOutput, error)
	getParametersForImportWithContextMutex       sync.RWMutex
	getParametersForImportWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.GetParametersForImportInput
		arg3 []request.Option
	}
	getParametersForImportWithContextReturns struct {
		result1 *kms.GetParametersForImportOutput
		result2 error
	}
	getParametersForImportWithContextReturnsOnCall map[int]struct {
		result1 *kms.GetParametersForImportOutput
		result2 error
	}
	GetPublicKeyStub        func(*kms.GetPublicKeyInput) (*kms.GetPublicKeyOutput, error)
	getPublicKeyMutex       sync.RWMutex
	getPublicKeyArgsForCall []struct {
		arg1 *kms.GetPublicKeyInput
	}
	getPublicKeyReturns struct {
		result1 *kms.GetPublicKeyOutput
		result2 error
	}
	getPublicKeyReturnsOnCall map[int]struct {
		result1 *kms.GetPublicKeyOutput
		result2 error
	}
	GetPublicKeyRequestStub        func(*kms.GetPublicKeyInput) (*request.Request, *kms.GetPublicKeyOutput)
	getPublicKeyRequestMutex       sync.RWMutex
	getPublicKeyRequestArgsForCall []struct {
		arg1 *kms.GetPublicKeyInput
	}
	getPublicKeyRequestReturns struct {
		result1 *request.Request
		result2 *kms.GetPublicKeyOutput
	}
	getPublicKeyRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.GetPublicKeyOutput
	}
	GetPublicKeyWithContextStub        func(context.Context, *kms.GetPublicKeyInput, ...request.Option) (*kms.GetPublicKeyOutput, error)
	getPublicKeyWithContextMutex       sync.RWMutex
	getPublicKeyWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.GetPublicKeyInput
		arg3 []request.Option
	}
	getPublicKeyWithContextReturns struct {
		result1 *kms.GetPublicKeyOutput
		result2 error
	}
	getPublicKeyWithContextReturnsOnCall map[int]struct {
		result1 *kms.GetPublicKeyOutput
		result2 error
	}
	ImportKeyMaterialStub        func(*kms.ImportKeyMaterialInput) (*kms.ImportKeyMaterialOutput, error)
	importKeyMaterialMutex       sync.RWMutex
	importKeyMaterialArgsForCall []struct {
		arg1 *kms.ImportKeyMaterialInput
	}
	importKeyMaterialReturns struct {
		result1 *kms.ImportKeyMaterialOutput
		result2 error
	}
	importKeyMaterialReturnsOnCall map[int]struct {
		result1 *kms.ImportKeyMaterialOutput
		result2 error
	}
	ImportKeyMaterialRequestStub        func(*kms.ImportKeyMaterialInput) (*request.Request, *kms.ImportKeyMaterialOutput)
	importKeyMaterialRequestMutex       sync.RWMutex
	importKeyMaterialRequestArgsForCall []struct {
		arg1 *kms.ImportKeyMaterialInput
	}
	importKeyMaterialRequestReturns struct {
		result1 *request.Request
		result2 *kms.ImportKeyMaterialOutput
	}
	importKeyMaterialRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ImportKeyMaterialOutput
	}
	ImportKeyMaterialWithContextStub        func(context.Context, *kms.ImportKeyMaterialInput, ...request.Option) (*kms.ImportKeyMaterialOutput, error)
	importKeyMaterialWithContextMutex       sync.RWMutex
	importKeyMaterialWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ImportKeyMaterialInput
		arg3 []request.Option
	}
	importKeyMaterialWithContextReturns struct {
		result1 *kms.ImportKeyMaterialOutput
		result2 error
	}
	importKeyMaterialWithContextReturnsOnCall map[int]struct {
		result1 *kms.ImportKeyMaterialOutput
		result2 error
	}
	ListAliasesStub        func(*kms.ListAliasesInput) (*kms.ListAliasesOutput, error)
	listAliasesMutex       sync.RWMutex
	listAliasesArgsForCall []struct {
		arg1 *kms.ListAliasesInput
	}
	listAliasesReturns struct {
		result1 *kms.ListAliasesOutput
		result2 error
	}
	listAliasesReturnsOnCall map[int]struct {
		result1 *kms.ListAliasesOutput
		result2 error
	}
	ListAliasesPagesStub        func(*kms.ListAliasesInput, func(*kms.ListAliasesOutput, bool) bool) error
	listAliasesPagesMutex       sync.RWMutex
	listAliasesPagesArgsForCall []struct {
		arg1 *kms.ListAliasesInput
		arg2 func(*kms.ListAliasesOutput, bool) bool
	}
	listAliasesPagesReturns struct {
		result1 error
	}
	listAliasesPagesReturnsOnCall map[int]struct {
		result1 error
	}
	ListAliasesPagesWithContextStub        func(context.Context, *kms.ListAliasesInput, func(*kms.ListAliasesOutput, bool) bool, ...request.Option) error
	listAliasesPagesWithContextMutex       sync.RWMutex
	listAliasesPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ListAliasesInput
		arg3 func(*kms.ListAliasesOutput, bool) bool
		arg4 []request.Option
	}
	listAliasesPagesWithContextReturns struct {
		result1 error
	}
	listAliasesPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	ListAliasesRequestStub        func(*kms.ListAliasesInput) (*request.Request, *kms.ListAliasesOutput)
	listAliasesRequestMutex       sync.RWMutex
	listAliasesRequestArgsForCall []struct {
		arg1 *kms.ListAliasesInput
	}
	listAliasesRequestReturns struct {
		result1 *request.Request
		result2 *kms.ListAliasesOutput
	}
	listAliasesRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ListAliasesOutput
	}
	ListAliasesWithContextStub        func(context.Context, *kms.ListAliasesInput, ...request.Option) (*kms.ListAliasesOutput, error)
	listAliasesWithContextMutex       sync.RWMutex
	listAliasesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ListAliasesInput
		arg3 []request.Option
	}
	listAliasesWithContextReturns struct {
		result1 *kms.ListAliasesOutput
		result2 error
	}
	listAliasesWithContextReturnsOnCall map[int]struct {
		result1 *kms.ListAliasesOutput
		result2 error
	}
	ListGrantsStub        func(*kms.ListGrantsInput) (*kms.ListGrantsResponse, error)
	listGrantsMutex       sync.RWMutex
	listGrantsArgsForCall []struct {
		arg1 *kms.ListGrantsInput
	}
	listGrantsReturns struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}
	listGrantsReturnsOnCall map[int]struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}
	ListGrantsPagesStub        func(*kms.ListGrantsInput, func(*kms.ListGrantsResponse, bool) bool) error
	listGrantsPagesMutex       sync.RWMutex
	listGrantsPagesArgsForCall []struct {
		arg1 *kms.ListGrantsInput
		arg2 func(*kms.ListGrantsResponse, bool) bool
	}
	listGrantsPagesReturns struct {
		result1 error
	}
	listGrantsPagesReturnsOnCall map[int]struct {
		result1 error
	}
	ListGrantsPagesWithContextStub        func(context.Context, *kms.ListGrantsInput, func(*kms.ListGrantsResponse, bool) bool, ...request.Option) error
	listGrantsPagesWithContextMutex       sync.RWMutex
	listGrantsPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ListGrantsInput
		arg3 func(*kms.ListGrantsResponse, bool) bool
		arg4 []request.Option
	}
	listGrantsPagesWithContextReturns struct {
		result1 error
	}
	listGrantsPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	ListGrantsRequestStub        func(*kms.ListGrantsInput) (*request.Request, *kms.ListGrantsResponse)
	listGrantsRequestMutex       sync.RWMutex
	listGrantsRequestArgsForCall []struct {
		arg1 *kms.ListGrantsInput
	}
	listGrantsRequestReturns struct {
		result1 *request.Request
		result2 *kms.ListGrantsResponse
	}
	listGrantsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ListGrantsResponse
	}
	ListGrantsWithContextStub        func(context.Context, *kms.ListGrantsInput, ...request.Option) (*kms.ListGrantsResponse, error)
	listGrantsWithContextMutex       sync.RWMutex
	listGrantsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ListGrantsInput
		arg3 []request.Option
	}
	listGrantsWithContextReturns struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}
	listGrantsWithContextReturnsOnCall map[int]struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}
	ListKeyPoliciesStub        func(*kms.ListKeyPoliciesInput) (*kms.ListKeyPoliciesOutput, error)
	listKeyPoliciesMutex       sync.RWMutex
	listKeyPoliciesArgsForCall []struct {
		arg1 *kms.ListKeyPoliciesInput
	}
	listKeyPoliciesReturns struct {
		result1 *kms.ListKeyPoliciesOutput
		result2 error
	}
	listKeyPoliciesReturnsOnCall map[int]struct {
		result1 *kms.ListKeyPoliciesOutput
		result2 error
	}
	ListKeyPoliciesPagesStub        func(*kms.ListKeyPoliciesInput, func(*kms.ListKeyPoliciesOutput, bool) bool) error
	listKeyPoliciesPagesMutex       sync.RWMutex
	listKeyPoliciesPagesArgsForCall []struct {
		arg1 *kms.ListKeyPoliciesInput
		arg2 func(*kms.ListKeyPoliciesOutput, bool) bool
	}
	listKeyPoliciesPagesReturns struct {
		result1 error
	}
	listKeyPoliciesPagesReturnsOnCall map[int]struct {
		result1 error
	}
	ListKeyPoliciesPagesWithContextStub        func(context.Context, *kms.ListKeyPoliciesInput, func(*kms.ListKeyPoliciesOutput, bool) bool, ...request.Option) error
	listKeyPoliciesPagesWithContextMutex       sync.RWMutex
	listKeyPoliciesPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ListKeyPoliciesInput
		arg3 func(*kms.ListKeyPoliciesOutput, bool) bool
		arg4 []request.Option
	}
	listKeyPoliciesPagesWithContextReturns struct {
		result1 error
	}
	listKeyPoliciesPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	ListKeyPoliciesRequestStub        func(*kms.ListKeyPoliciesInput) (*request.Request, *kms.ListKeyPoliciesOutput)
	listKeyPoliciesRequestMutex       sync.RWMutex
	listKeyPoliciesRequestArgsForCall []struct {
		arg1 *kms.ListKeyPoliciesInput
	}
	listKeyPoliciesRequestReturns struct {
		result1 *request.Request
		result2 *kms.ListKeyPoliciesOutput
	}
	listKeyPoliciesRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ListKeyPoliciesOutput
	}
	ListKeyPoliciesWithContextStub        func(context.Context, *kms.ListKeyPoliciesInput, ...request.Option) (*kms.ListKeyPoliciesOutput, error)
	listKeyPoliciesWithContextMutex       sync.RWMutex
	listKeyPoliciesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ListKeyPoliciesInput
		arg3 []request.Option
	}
	listKeyPoliciesWithContextReturns struct {
		result1 *kms.ListKeyPoliciesOutput
		result2 error
	}
	listKeyPoliciesWithContextReturnsOnCall map[int]struct {
		result1 *kms.ListKeyPoliciesOutput
		result2 error
	}
	ListKeysStub        func(*kms.ListKeysInput) (*kms.ListKeysOutput, error)
	listKeysMutex       sync.RWMutex
	listKeysArgsForCall []struct {
		arg1 *kms.ListKeysInput
	}
	listKeysReturns struct {
		result1 *kms.ListKeysOutput
		result2 error
	}
	listKeysReturnsOnCall map[int]struct {
		result1 *kms.ListKeysOutput
		result2 error
	}
	ListKeysPagesStub        func(*kms.ListKeysInput, func(*kms.ListKeysOutput, bool) bool) error
	listKeysPagesMutex       sync.RWMutex
	listKeysPagesArgsForCall []struct {
		arg1 *kms.ListKeysInput
		arg2 func(*kms.ListKeysOutput, bool) bool
	}
	listKeysPagesReturns struct {
		result1 error
	}
	listKeysPagesReturnsOnCall map[int]struct {
		result1 error
	}
	ListKeysPagesWithContextStub        func(context.Context, *kms.ListKeysInput, func(*kms.ListKeysOutput, bool) bool, ...request.Option) error
	listKeysPagesWithContextMutex       sync.RWMutex
	listKeysPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ListKeysInput
		arg3 func(*kms.ListKeysOutput, bool) bool
		arg4 []request.Option
	}
	listKeysPagesWithContextReturns struct {
		result1 error
	}
	listKeysPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	ListKeysRequestStub        func(*kms.ListKeysInput) (*request.Request, *kms.ListKeysOutput)
	listKeysRequestMutex       sync.RWMutex
	listKeysRequestArgsForCall []struct {
		arg1 *kms.ListKeysInput
	}
	listKeysRequestReturns struct {
		result1 *request.Request
		result2 *kms.ListKeysOutput
	}
	listKeysRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ListKeysOutput
	}
	ListKeysWithContextStub        func(context.Context, *kms.ListKeysInput, ...request.Option) (*kms.ListKeysOutput, error)
	listKeysWithContextMutex       sync.RWMutex
	listKeysWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ListKeysInput
		arg3 []request.Option
	}
	listKeysWithContextReturns struct {
		result1 *kms.ListKeysOutput
		result2 error
	}
	listKeysWithContextReturnsOnCall map[int]struct {
		result1 *kms.ListKeysOutput
		result2 error
	}
	ListResourceTagsStub        func(*kms.ListResourceTagsInput) (*kms.ListResourceTagsOutput, error)
	listResourceTagsMutex       sync.RWMutex
	listResourceTagsArgsForCall []struct {
		arg1 *kms.ListResourceTagsInput
	}
	listResourceTagsReturns struct {
		result1 *kms.ListResourceTagsOutput
		result2 error
	}
	listResourceTagsReturnsOnCall map[int]struct {
		result1 *kms.ListResourceTagsOutput
		result2 error
	}
	ListResourceTagsRequestStub        func(*kms.ListResourceTagsInput) (*request.Request, *kms.ListResourceTagsOutput)
	listResourceTagsRequestMutex       sync.RWMutex
	listResourceTagsRequestArgsForCall []struct {
		arg1 *kms.ListResourceTagsInput
	}
	listResourceTagsRequestReturns struct {
		result1 *request.Request
		result2 *kms.ListResourceTagsOutput
	}
	listResourceTagsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ListResourceTagsOutput
	}
	ListResourceTagsWithContextStub        func(context.Context, *kms.ListResourceTagsInput, ...request.Option) (*kms.ListResourceTagsOutput, error)
	listResourceTagsWithContextMutex       sync.RWMutex
	listResourceTagsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ListResourceTagsInput
		arg3 []request.Option
	}
	listResourceTagsWithContextReturns struct {
		result1 *kms.ListResourceTagsOutput
		result2 error
	}
	listResourceTagsWithContextReturnsOnCall map[int]struct {
		result1 *kms.ListResourceTagsOutput
		result2 error
	}
	ListRetirableGrantsStub        func(*kms.ListRetirableGrantsInput) (*kms.ListGrantsResponse, error)
	listRetirableGrantsMutex       sync.RWMutex
	listRetirableGrantsArgsForCall []struct {
		arg1 *kms.ListRetirableGrantsInput
	}
	listRetirableGrantsReturns struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}
	listRetirableGrantsReturnsOnCall map[int]struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}
	ListRetirableGrantsRequestStub        func(*kms.ListRetirableGrantsInput) (*request.Request, *kms.ListGrantsResponse)
	listRetirableGrantsRequestMutex       sync.RWMutex
	listRetirableGrantsRequestArgsForCall []struct {
		arg1 *kms.ListRetirableGrantsInput
	}
	listRetirableGrantsRequestReturns struct {
		result1 *request.Request
		result2 *kms.ListGrantsResponse
	}
	listRetirableGrantsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ListGrantsResponse
	}
	ListRetirableGrantsWithContextStub        func(context.Context, *kms.ListRetirableGrantsInput, ...request.Option) (*kms.ListGrantsResponse, error)
	listRetirableGrantsWithContextMutex       sync.RWMutex
	listRetirableGrantsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ListRetirableGrantsInput
		arg3 []request.Option
	}
	listRetirableGrantsWithContextReturns struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}
	listRetirableGrantsWithContextReturnsOnCall map[int]struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}
	PutKeyPolicyStub        func(*kms.PutKeyPolicyInput) (*kms.PutKeyPolicyOutput, error)
	putKeyPolicyMutex       sync.RWMutex
	putKeyPolicyArgsForCall []struct {
		arg1 *kms.PutKeyPolicyInput
	}
	putKeyPolicyReturns struct {
		result1 *kms.PutKeyPolicyOutput
		result2 error
	}
	putKeyPolicyReturnsOnCall map[int]struct {
		result1 *kms.PutKeyPolicyOutput
		result2 error
	}
	PutKeyPolicyRequestStub        func(*kms.PutKeyPolicyInput) (*request.Request, *kms.PutKeyPolicyOutput)
	putKeyPolicyRequestMutex       sync.RWMutex
	putKeyPolicyRequestArgsForCall []struct {
		arg1 *kms.PutKeyPolicyInput
	}
	putKeyPolicyRequestReturns struct {
		result1 *request.Request
		result2 *kms.PutKeyPolicyOutput
	}
	putKeyPolicyRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.PutKeyPolicyOutput
	}
	PutKeyPolicyWithContextStub        func(context.Context, *kms.PutKeyPolicyInput, ...request.Option) (*kms.PutKeyPolicyOutput, error)
	putKeyPolicyWithContextMutex       sync.RWMutex
	putKeyPolicyWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.PutKeyPolicyInput
		arg3 []request.Option
	}
	putKeyPolicyWithContextReturns struct {
		result1 *kms.PutKeyPolicyOutput
		result2 error
	}
	putKeyPolicyWithContextReturnsOnCall map[int]struct {
		result1 *kms.PutKeyPolicyOutput
		result2 error
	}
	ReEncryptStub        func(*kms.ReEncryptInput) (*kms.ReEncryptOutput, error)
	reEncryptMutex       sync.RWMutex
	reEncryptArgsForCall []struct {
		arg1 *kms.ReEncryptInput
	}
	reEncryptReturns struct {
		result1 *kms.ReEncryptOutput
		result2 error
	}
	reEncryptReturnsOnCall map[int]struct {
		result1 *kms.ReEncryptOutput
		result2 error
	}
	ReEncryptRequestStub        func(*kms.ReEncryptInput) (*request.Request, *kms.ReEncryptOutput)
	reEncryptRequestMutex       sync.RWMutex
	reEncryptRequestArgsForCall []struct {
		arg1 *kms.ReEncryptInput
	}
	reEncryptRequestReturns struct {
		result1 *request.Request
		result2 *kms.ReEncryptOutput
	}
	reEncryptRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ReEncryptOutput
	}
	ReEncryptWithContextStub        func(context.Context, *kms.ReEncryptInput, ...request.Option) (*kms.ReEncryptOutput, error)
	reEncryptWithContextMutex       sync.RWMutex
	reEncryptWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ReEncryptInput
		arg3 []request.Option
	}
	reEncryptWithContextReturns struct {
		result1 *kms.ReEncryptOutput
		result2 error
	}
	reEncryptWithContextReturnsOnCall map[int]struct {
		result1 *kms.ReEncryptOutput
		result2 error
	}
	ReplicateKeyStub        func(*kms.ReplicateKeyInput) (*kms.ReplicateKeyOutput, error)
	replicateKeyMutex       sync.RWMutex
	replicateKeyArgsForCall []struct {
		arg1 *kms.ReplicateKeyInput
	}
	replicateKeyReturns struct {
		result1 *kms.ReplicateKeyOutput
		result2 error
	}
	replicateKeyReturnsOnCall map[int]struct {
		result1 *kms.ReplicateKeyOutput
		result2 error
	}
	ReplicateKeyRequestStub        func(*kms.ReplicateKeyInput) (*request.Request, *kms.ReplicateKeyOutput)
	replicateKeyRequestMutex       sync.RWMutex
	replicateKeyRequestArgsForCall []struct {
		arg1 *kms.ReplicateKeyInput
	}
	replicateKeyRequestReturns struct {
		result1 *request.Request
		result2 *kms.ReplicateKeyOutput
	}
	replicateKeyRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ReplicateKeyOutput
	}
	ReplicateKeyWithContextStub        func(context.Context, *kms.ReplicateKeyInput, ...request.Option) (*kms.ReplicateKeyOutput, error)
	replicateKeyWithContextMutex       sync.RWMutex
	replicateKeyWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ReplicateKeyInput
		arg3 []request.Option
	}
	replicateKeyWithContextReturns struct {
		result1 *kms.ReplicateKeyOutput
		result2 error
	}
	replicateKeyWithContextReturnsOnCall map[int]struct {
		result1 *kms.ReplicateKeyOutput
		result2 error
	}
	RetireGrantStub        func(*kms.RetireGrantInput) (*kms.RetireGrantOutput, error)
	retireGrantMutex       sync.RWMutex
	retireGrantArgsForCall []struct {
		arg1 *kms.RetireGrantInput
	}
	retireGrantReturns struct {
		result1 *kms.RetireGrantOutput
		result2 error
	}
	retireGrantReturnsOnCall map[int]struct {
		result1 *kms.RetireGrantOutput
		result2 error
	}
	RetireGrantRequestStub        func(*kms.RetireGrantInput) (*request.Request, *kms.RetireGrantOutput)
	retireGrantRequestMutex       sync.RWMutex
	retireGrantRequestArgsForCall []struct {
		arg1 *kms.RetireGrantInput
	}
	retireGrantRequestReturns struct {
		result1 *request.Request
		result2 *kms.RetireGrantOutput
	}
	retireGrantRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.RetireGrantOutput
	}
	RetireGrantWithContextStub        func(context.Context, *kms.RetireGrantInput, ...request.Option) (*kms.RetireGrantOutput, error)
	retireGrantWithContextMutex       sync.RWMutex
	retireGrantWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.RetireGrantInput
		arg3 []request.Option
	}
	retireGrantWithContextReturns struct {
		result1 *kms.RetireGrantOutput
		result2 error
	}
	retireGrantWithContextReturnsOnCall map[int]struct {
		result1 *kms.RetireGrantOutput
		result2 error
	}
	RevokeGrantStub        func(*kms.RevokeGrantInput) (*kms.RevokeGrantOutput, error)
	revokeGrantMutex       sync.RWMutex
	revokeGrantArgsForCall []struct {
		arg1 *kms.RevokeGrantInput
	}
	revokeGrantReturns struct {
		result1 *kms.RevokeGrantOutput
		result2 error
	}
	revokeGrantReturnsOnCall map[int]struct {
		result1 *kms.RevokeGrantOutput
		result2 error
	}
	RevokeGrantRequestStub        func(*kms.RevokeGrantInput) (*request.Request, *kms.RevokeGrantOutput)
	revokeGrantRequestMutex       sync.RWMutex
	revokeGrantRequestArgsForCall []struct {
		arg1 *kms.RevokeGrantInput
	}
	revokeGrantRequestReturns struct {
		result1 *request.Request
		result2 *kms.RevokeGrantOutput
	}
	revokeGrantRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.RevokeGrantOutput
	}
	RevokeGrantWithContextStub        func(context.Context, *kms.RevokeGrantInput, ...request.Option) (*kms.RevokeGrantOutput, error)
	revokeGrantWithContextMutex       sync.RWMutex
	revokeGrantWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.RevokeGrantInput
		arg3 []request.Option
	}
	revokeGrantWithContextReturns struct {
		result1 *kms.RevokeGrantOutput
		result2 error
	}
	revokeGrantWithContextReturnsOnCall map[int]struct {
		result1 *kms.RevokeGrantOutput
		result2 error
	}
	ScheduleKeyDeletionStub        func(*kms.ScheduleKeyDeletionInput) (*kms.ScheduleKeyDeletionOutput, error)
	scheduleKeyDeletionMutex       sync.RWMutex
	scheduleKeyDeletionArgsForCall []struct {
		arg1 *kms.ScheduleKeyDeletionInput
	}
	scheduleKeyDeletionReturns struct {
		result1 *kms.ScheduleKeyDeletionOutput
		result2 error
	}
	scheduleKeyDeletionReturnsOnCall map[int]struct {
		result1 *kms.ScheduleKeyDeletionOutput
		result2 error
	}
	ScheduleKeyDeletionRequestStub        func(*kms.ScheduleKeyDeletionInput) (*request.Request, *kms.ScheduleKeyDeletionOutput)
	scheduleKeyDeletionRequestMutex       sync.RWMutex
	scheduleKeyDeletionRequestArgsForCall []struct {
		arg1 *kms.ScheduleKeyDeletionInput
	}
	scheduleKeyDeletionRequestReturns struct {
		result1 *request.Request
		result2 *kms.ScheduleKeyDeletionOutput
	}
	scheduleKeyDeletionRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.ScheduleKeyDeletionOutput
	}
	ScheduleKeyDeletionWithContextStub        func(context.Context, *kms.ScheduleKeyDeletionInput, ...request.Option) (*kms.ScheduleKeyDeletionOutput, error)
	scheduleKeyDeletionWithContextMutex       sync.RWMutex
	scheduleKeyDeletionWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.ScheduleKeyDeletionInput
		arg3 []request.Option
	}
	scheduleKeyDeletionWithContextReturns struct {
		result1 *kms.ScheduleKeyDeletionOutput
		result2 error
	}
	scheduleKeyDeletionWithContextReturnsOnCall map[int]struct {
		result1 *kms.ScheduleKeyDeletionOutput
		result2 error
	}
	SignStub        func(*kms.SignInput) (*kms.SignOutput, error)
	signMutex       sync.RWMutex
	signArgsForCall []struct {
		arg1 *kms.SignInput
	}
	signReturns struct {
		result1 *kms.SignOutput
		result2 error
	}
	signReturnsOnCall map[int]struct {
		result1 *kms.SignOutput
		result2 error
	}
	SignRequestStub        func(*kms.SignInput) (*request.Request, *kms.SignOutput)
	signRequestMutex       sync.RWMutex
	signRequestArgsForCall []struct {
		arg1 *kms.SignInput
	}
	signRequestReturns struct {
		result1 *request.Request
		result2 *kms.SignOutput
	}
	signRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.SignOutput
	}
	SignWithContextStub        func(context.Context, *kms.SignInput, ...request.Option) (*kms.SignOutput, error)
	signWithContextMutex       sync.RWMutex
	signWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.SignInput
		arg3 []request.Option
	}
	signWithContextReturns struct {
		result1 *kms.SignOutput
		result2 error
	}
	signWithContextReturnsOnCall map[int]struct {
		result1 *kms.SignOutput
		result2 error
	}
	TagResourceStub        func(*kms.TagResourceInput) (*kms.TagResourceOutput, error)
	tagResourceMutex       sync.RWMutex
	tagResourceArgsForCall []struct {
		arg1 *kms.TagResourceInput
	}
	tagResourceReturns struct {
		result1 *kms.TagResourceOutput
		result2 error
	}
	tagResourceReturnsOnCall map[int]struct {
		result1 *kms.TagResourceOutput
		result2 error
	}
	TagResourceRequestStub        func(*kms.TagResourceInput) (*request.Request, *kms.TagResourceOutput)
	tagResourceRequestMutex       sync.RWMutex
	tagResourceRequestArgsForCall []struct {
		arg1 *kms.TagResourceInput
	}
	tagResourceRequestReturns struct {
		result1 *request.Request
		result2 *kms.TagResourceOutput
	}
	tagResourceRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.TagResourceOutput
	}
	TagResourceWithContextStub        func(context.Context, *kms.TagResourceInput, ...request.Option) (*kms.TagResourceOutput, error)
	tagResourceWithContextMutex       sync.RWMutex
	tagResourceWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.TagResourceInput
		arg3 []request.Option
	}
	tagResourceWithContextReturns struct {
		result1 *kms.TagResourceOutput
		result2 error
	}
	tagResourceWithContextReturnsOnCall map[int]struct {
		result1 *kms.TagResourceOutput
		result2 error
	}
	UntagResourceStub        func(*kms.UntagResourceInput) (*kms.UntagResourceOutput, error)
	untagResourceMutex       sync.RWMutex
	untagResourceArgsForCall []struct {
		arg1 *kms.UntagResourceInput
	}
	untagResourceReturns struct {
		result1 *kms.UntagResourceOutput
		result2 error
	}
	untagResourceReturnsOnCall map[int]struct {
		result1 *kms.UntagResourceOutput
		result2 error
	}
	UntagResourceRequestStub        func(*kms.UntagResourceInput) (*request.Request, *kms.UntagResourceOutput)
	untagResourceRequestMutex       sync.RWMutex
	untagResourceRequestArgsForCall []struct {
		arg1 *kms.UntagResourceInput
	}
	untagResourceRequestReturns struct {
		result1 *request.Request
		result2 *kms.UntagResourceOutput
	}
	untagResourceRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.UntagResourceOutput
	}
	UntagResourceWithContextStub        func(context.Context, *kms.UntagResourceInput, ...request.Option) (*kms.UntagResourceOutput, error)
	untagResourceWithContextMutex       sync.RWMutex
	untagResourceWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.UntagResourceInput
		arg3 []request.Option
	}
	untagResourceWithContextReturns struct {
		result1 *kms.UntagResourceOutput
		result2 error
	}
	untagResourceWithContextReturnsOnCall map[int]struct {
		result1 *kms.UntagResourceOutput
		result2 error
	}
	UpdateAliasStub        func(*kms.UpdateAliasInput) (*kms.UpdateAliasOutput, error)
	updateAliasMutex       sync.RWMutex
	updateAliasArgsForCall []struct {
		arg1 *kms.UpdateAliasInput
	}
	updateAliasReturns struct {
		result1 *kms.UpdateAliasOutput
		result2 error
	}
	updateAliasReturnsOnCall map[int]struct {
		result1 *kms.UpdateAliasOutput
		result2 error
	}
	UpdateAliasRequestStub        func(*kms.UpdateAliasInput) (*request.Request, *kms.UpdateAliasOutput)
	updateAliasRequestMutex       sync.RWMutex
	updateAliasRequestArgsForCall []struct {
		arg1 *kms.UpdateAliasInput
	}
	updateAliasRequestReturns struct {
		result1 *request.Request
		result2 *kms.UpdateAliasOutput
	}
	updateAliasRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.UpdateAliasOutput
	}
	UpdateAliasWithContextStub        func(context.Context, *kms.UpdateAliasInput, ...request.Option) (*kms.UpdateAliasOutput, error)
	updateAliasWithContextMutex       sync.RWMutex
	updateAliasWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.UpdateAliasInput
		arg3 []request.Option
	}
	updateAliasWithContextReturns struct {
		result1 *kms.UpdateAliasOutput
		result2 error
	}
	updateAliasWithContextReturnsOnCall map[int]struct {
		result1 *kms.UpdateAliasOutput
		result2 error
	}
	UpdateCustomKeyStoreStub        func(*kms.UpdateCustomKeyStoreInput) (*kms.UpdateCustomKeyStoreOutput, error)
	updateCustomKeyStoreMutex       sync.RWMutex
	updateCustomKeyStoreArgsForCall []struct {
		arg1 *kms.UpdateCustomKeyStoreInput
	}
	updateCustomKeyStoreReturns struct {
		result1 *kms.UpdateCustomKeyStoreOutput
		result2 error
	}
	updateCustomKeyStoreReturnsOnCall map[int]struct {
		result1 *kms.UpdateCustomKeyStoreOutput
		result2 error
	}
	UpdateCustomKeyStoreRequestStub        func(*kms.UpdateCustomKeyStoreInput) (*request.Request, *kms.UpdateCustomKeyStoreOutput)
	updateCustomKeyStoreRequestMutex       sync.RWMutex
	updateCustomKeyStoreRequestArgsForCall []struct {
		arg1 *kms.UpdateCustomKeyStoreInput
	}
	updateCustomKeyStoreRequestReturns struct {
		result1 *request.Request
		result2 *kms.UpdateCustomKeyStoreOutput
	}
	updateCustomKeyStoreRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.UpdateCustomKeyStoreOutput
	}
	UpdateCustomKeyStoreWithContextStub        func(context.Context, *kms.UpdateCustomKeyStoreInput, ...request.Option) (*kms.UpdateCustomKeyStoreOutput, error)
	updateCustomKeyStoreWithContextMutex       sync.RWMutex
	updateCustomKeyStoreWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.UpdateCustomKeyStoreInput
		arg3 []request.Option
	}
	updateCustomKeyStoreWithContextReturns struct {
		result1 *kms.UpdateCustomKeyStoreOutput
		result2 error
	}
	updateCustomKeyStoreWithContextReturnsOnCall map[int]struct {
		result1 *kms.UpdateCustomKeyStoreOutput
		result2 error
	}
	UpdateKeyDescriptionStub        func(*kms.UpdateKeyDescriptionInput) (*kms.UpdateKeyDescriptionOutput, error)
	updateKeyDescriptionMutex       sync.RWMutex
	updateKeyDescriptionArgsForCall []struct {
		arg1 *kms.UpdateKeyDescriptionInput
	}
	updateKeyDescriptionReturns struct {
		result1 *kms.UpdateKeyDescriptionOutput
		result2 error
	}
	updateKeyDescriptionReturnsOnCall map[int]struct {
		result1 *kms.UpdateKeyDescriptionOutput
		result2 error
	}
	UpdateKeyDescriptionRequestStub        func(*kms.UpdateKeyDescriptionInput) (*request.Request, *kms.UpdateKeyDescriptionOutput)
	updateKeyDescriptionRequestMutex       sync.RWMutex
	updateKeyDescriptionRequestArgsForCall []struct {
		arg1 *kms.UpdateKeyDescriptionInput
	}
	updateKeyDescriptionRequestReturns struct {
		result1 *request.Request
		result2 *kms.UpdateKeyDescriptionOutput
	}
	updateKeyDescriptionRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.UpdateKeyDescriptionOutput
	}
	UpdateKeyDescriptionWithContextStub        func(context.Context, *kms.UpdateKeyDescriptionInput, ...request.Option) (*kms.UpdateKeyDescriptionOutput, error)
	updateKeyDescriptionWithContextMutex       sync.RWMutex
	updateKeyDescriptionWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.UpdateKeyDescriptionInput
		arg3 []request.Option
	}
	updateKeyDescriptionWithContextReturns struct {
		result1 *kms.UpdateKeyDescriptionOutput
		result2 error
	}
	updateKeyDescriptionWithContextReturnsOnCall map[int]struct {
		result1 *kms.UpdateKeyDescriptionOutput
		result2 error
	}
	UpdatePrimaryRegionStub        func(*kms.UpdatePrimaryRegionInput) (*kms.UpdatePrimaryRegionOutput, error)
	updatePrimaryRegionMutex       sync.RWMutex
	updatePrimaryRegionArgsForCall []struct {
		arg1 *kms.UpdatePrimaryRegionInput
	}
	updatePrimaryRegionReturns struct {
		result1 *kms.UpdatePrimaryRegionOutput
		result2 error
	}
	updatePrimaryRegionReturnsOnCall map[int]struct {
		result1 *kms.UpdatePrimaryRegionOutput
		result2 error
	}
	UpdatePrimaryRegionRequestStub        func(*kms.UpdatePrimaryRegionInput) (*request.Request, *kms.UpdatePrimaryRegionOutput)
	updatePrimaryRegionRequestMutex       sync.RWMutex
	updatePrimaryRegionRequestArgsForCall []struct {
		arg1 *kms.UpdatePrimaryRegionInput
	}
	updatePrimaryRegionRequestReturns struct {
		result1 *request.Request
		result2 *kms.UpdatePrimaryRegionOutput
	}
	updatePrimaryRegionRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.UpdatePrimaryRegionOutput
	}
	UpdatePrimaryRegionWithContextStub        func(context.Context, *kms.UpdatePrimaryRegionInput, ...request.Option) (*kms.UpdatePrimaryRegionOutput, error)
	updatePrimaryRegionWithContextMutex       sync.RWMutex
	updatePrimaryRegionWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.UpdatePrimaryRegionInput
		arg3 []request.Option
	}
	updatePrimaryRegionWithContextReturns struct {
		result1 *kms.UpdatePrimaryRegionOutput
		result2 error
	}
	updatePrimaryRegionWithContextReturnsOnCall map[int]struct {
		result1 *kms.UpdatePrimaryRegionOutput
		result2 error
	}
	VerifyStub        func(*kms.VerifyInput) (*kms.VerifyOutput, error)
	verifyMutex       sync.RWMutex
	verifyArgsForCall []struct {
		arg1 *kms.VerifyInput
	}
	verifyReturns struct {
		result1 *kms.VerifyOutput
		result2 error
	}
	verifyReturnsOnCall map[int]struct {
		result1 *kms.VerifyOutput
		result2 error
	}
	VerifyMacStub        func(*kms.VerifyMacInput) (*kms.VerifyMacOutput, error)
	verifyMacMutex       sync.RWMutex
	verifyMacArgsForCall []struct {
		arg1 *kms.VerifyMacInput
	}
	verifyMacReturns struct {
		result1 *kms.VerifyMacOutput
		result2 error
	}
	verifyMacReturnsOnCall map[int]struct {
		result1 *kms.VerifyMacOutput
		result2 error
	}
	VerifyMacRequestStub        func(*kms.VerifyMacInput) (*request.Request, *kms.VerifyMacOutput)
	verifyMacRequestMutex       sync.RWMutex
	verifyMacRequestArgsForCall []struct {
		arg1 *kms.VerifyMacInput
	}
	verifyMacRequestReturns struct {
		result1 *request.Request
		result2 *kms.VerifyMacOutput
	}
	verifyMacRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.VerifyMacOutput
	}
	VerifyMacWithContextStub        func(context.Context, *kms.VerifyMacInput, ...request.Option) (*kms.VerifyMacOutput, error)
	verifyMacWithContextMutex       sync.RWMutex
	verifyMacWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.VerifyMacInput
		arg3 []request.Option
	}
	verifyMacWithContextReturns struct {
		result1 *kms.VerifyMacOutput
		result2 error
	}
	verifyMacWithContextReturnsOnCall map[int]struct {
		result1 *kms.VerifyMacOutput
		result2 error
	}
	VerifyRequestStub        func(*kms.VerifyInput) (*request.Request, *kms.VerifyOutput)
	verifyRequestMutex       sync.RWMutex
	verifyRequestArgsForCall []struct {
		arg1 *kms.VerifyInput
	}
	verifyRequestReturns struct {
		result1 *request.Request
		result2 *kms.VerifyOutput
	}
	verifyRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kms.VerifyOutput
	}
	VerifyWithContextStub        func(context.Context, *kms.VerifyInput, ...request.Option) (*kms.VerifyOutput, error)
	verifyWithContextMutex       sync.RWMutex
	verifyWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kms.VerifyInput
		arg3 []request.Option
	}
	verifyWithContextReturns struct {
		result1 *kms.VerifyOutput
		result2 error
	}
	verifyWithContextReturnsOnCall map[int]struct {
		result1 *kms.VerifyOutput
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeKMSClient) CancelKeyDeletion(arg1 *kms.CancelKeyDeletionInput) (*kms.CancelKeyDeletionOutput, error) {
	fake.cancelKeyDeletionMutex.Lock()
	ret, specificReturn := fake.cancelKeyDeletionReturnsOnCall[len(fake.cancelKeyDeletionArgsForCall)]
	fake.cancelKeyDeletionArgsForCall = append(fake.cancelKeyDeletionArgsForCall, struct {
		arg1 *kms.CancelKeyDeletionInput
	}{arg1})
	stub := fake.CancelKeyDeletionStub
	fakeReturns := fake.cancelKeyDeletionReturns
	fake.recordInvocation("CancelKeyDeletion", []interface{}{arg1})
	fake.cancelKeyDeletionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CancelKeyDeletionCallCount() int {
	fake.cancelKeyDeletionMutex.RLock()
	defer fake.cancelKeyDeletionMutex.RUnlock()
	return len(fake.cancelKeyDeletionArgsForCall)
}

func (fake *FakeKMSClient) CancelKeyDeletionCalls(stub func(*kms.CancelKeyDeletionInput) (*kms.CancelKeyDeletionOutput, error)) {
	fake.cancelKeyDeletionMutex.Lock()
	defer fake.cancelKeyDeletionMutex.Unlock()
	fake.CancelKeyDeletionStub = stub
}

func (fake *FakeKMSClient) CancelKeyDeletionArgsForCall(i int) *kms.CancelKeyDeletionInput {
	fake.cancelKeyDeletionMutex.RLock()
	defer fake.cancelKeyDeletionMutex.RUnlock()
	argsForCall := fake.cancelKeyDeletionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) CancelKeyDeletionReturns(result1 *kms.CancelKeyDeletionOutput, result2 error) {
	fake.cancelKeyDeletionMutex.Lock()
	defer fake.cancelKeyDeletionMutex.Unlock()
	fake.CancelKeyDeletionStub = nil
	fake.cancelKeyDeletionReturns = struct {
		result1 *kms.CancelKeyDeletionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CancelKeyDeletionReturnsOnCall(i int, result1 *kms.CancelKeyDeletionOutput, result2 error) {
	fake.cancelKeyDeletionMutex.Lock()
	defer fake.cancelKeyDeletionMutex.Unlock()
	fake.CancelKeyDeletionStub = nil
	if fake.cancelKeyDeletionReturnsOnCall == nil {
		fake.cancelKeyDeletionReturnsOnCall = make(map[int]struct {
			result1 *kms.CancelKeyDeletionOutput
			result2 error
		})
	}
	fake.cancelKeyDeletionReturnsOnCall[i] = struct {
		result1 *kms.CancelKeyDeletionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CancelKeyDeletionRequest(arg1 *kms.CancelKeyDeletionInput) (*request.Request, *kms.CancelKeyDeletionOutput) {
	fake.cancelKeyDeletionRequestMutex.Lock()
	ret, specificReturn := fake.cancelKeyDeletionRequestReturnsOnCall[len(fake.cancelKeyDeletionRequestArgsForCall)]
	fake.cancelKeyDeletionRequestArgsForCall = append(fake.cancelKeyDeletionRequestArgsForCall, struct {
		arg1 *kms.CancelKeyDeletionInput
	}{arg1})
	stub := fake.CancelKeyDeletionRequestStub
	fakeReturns := fake.cancelKeyDeletionRequestReturns
	fake.recordInvocation("CancelKeyDeletionRequest", []interface{}{arg1})
	fake.cancelKeyDeletionRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CancelKeyDeletionRequestCallCount() int {
	fake.cancelKeyDeletionRequestMutex.RLock()
	defer fake.cancelKeyDeletionRequestMutex.RUnlock()
	return len(fake.cancelKeyDeletionRequestArgsForCall)
}

func (fake *FakeKMSClient) CancelKeyDeletionRequestCalls(stub func(*kms.CancelKeyDeletionInput) (*request.Request, *kms.CancelKeyDeletionOutput)) {
	fake.cancelKeyDeletionRequestMutex.Lock()
	defer fake.cancelKeyDeletionRequestMutex.Unlock()
	fake.CancelKeyDeletionRequestStub = stub
}

func (fake *FakeKMSClient) CancelKeyDeletionRequestArgsForCall(i int) *kms.CancelKeyDeletionInput {
	fake.cancelKeyDeletionRequestMutex.RLock()
	defer fake.cancelKeyDeletionRequestMutex.RUnlock()
	argsForCall := fake.cancelKeyDeletionRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) CancelKeyDeletionRequestReturns(result1 *request.Request, result2 *kms.CancelKeyDeletionOutput) {
	fake.cancelKeyDeletionRequestMutex.Lock()
	defer fake.cancelKeyDeletionRequestMutex.Unlock()
	fake.CancelKeyDeletionRequestStub = nil
	fake.cancelKeyDeletionRequestReturns = struct {
		result1 *request.Request
		result2 *kms.CancelKeyDeletionOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) CancelKeyDeletionRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.CancelKeyDeletionOutput) {
	fake.cancelKeyDeletionRequestMutex.Lock()
	defer fake.cancelKeyDeletionRequestMutex.Unlock()
	fake.CancelKeyDeletionRequestStub = nil
	if fake.cancelKeyDeletionRequestReturnsOnCall == nil {
		fake.cancelKeyDeletionRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.CancelKeyDeletionOutput
		})
	}
	fake.cancelKeyDeletionRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.CancelKeyDeletionOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) CancelKeyDeletionWithContext(arg1 context.Context, arg2 *kms.CancelKeyDeletionInput, arg3 ...request.Option) (*kms.CancelKeyDeletionOutput, error) {
	fake.cancelKeyDeletionWithContextMutex.Lock()
	ret, specificReturn := fake.cancelKeyDeletionWithContextReturnsOnCall[len(fake.cancelKeyDeletionWithContextArgsForCall)]
	fake.cancelKeyDeletionWithContextArgsForCall = append(fake.cancelKeyDeletionWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.CancelKeyDeletionInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.CancelKeyDeletionWithContextStub
	fakeReturns := fake.cancelKeyDeletionWithContextReturns
	fake.recordInvocation("CancelKeyDeletionWithContext", []interface{}{arg1, arg2, arg3})
	fake.cancelKeyDeletionWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CancelKeyDeletionWithContextCallCount() int {
	fake.cancelKeyDeletionWithContextMutex.RLock()
	defer fake.cancelKeyDeletionWithContextMutex.RUnlock()
	return len(fake.cancelKeyDeletionWithContextArgsForCall)
}

func (fake *FakeKMSClient) CancelKeyDeletionWithContextCalls(stub func(context.Context, *kms.CancelKeyDeletionInput, ...request.Option) (*kms.CancelKeyDeletionOutput, error)) {
	fake.cancelKeyDeletionWithContextMutex.Lock()
	defer fake.cancelKeyDeletionWithContextMutex.Unlock()
	fake.CancelKeyDeletionWithContextStub = stub
}

func (fake *FakeKMSClient) CancelKeyDeletionWithContextArgsForCall(i int) (context.Context, *kms.CancelKeyDeletionInput, []request.Option) {
	fake.cancelKeyDeletionWithContextMutex.RLock()
	defer fake.cancelKeyDeletionWithContextMutex.RUnlock()
	argsForCall := fake.cancelKeyDeletionWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) CancelKeyDeletionWithContextReturns(result1 *kms.CancelKeyDeletionOutput, result2 error) {
	fake.cancelKeyDeletionWithContextMutex.Lock()
	defer fake.cancelKeyDeletionWithContextMutex.Unlock()
	fake.CancelKeyDeletionWithContextStub = nil
	fake.cancelKeyDeletionWithContextReturns = struct {
		result1 *kms.CancelKeyDeletionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CancelKeyDeletionWithContextReturnsOnCall(i int, result1 *kms.CancelKeyDeletionOutput, result2 error) {
	fake.cancelKeyDeletionWithContextMutex.Lock()
	defer fake.cancelKeyDeletionWithContextMutex.Unlock()
	fake.CancelKeyDeletionWithContextStub = nil
	if fake.cancelKeyDeletionWithContextReturnsOnCall == nil {
		fake.cancelKeyDeletionWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.CancelKeyDeletionOutput
			result2 error
		})
	}
	fake.cancelKeyDeletionWithContextReturnsOnCall[i] = struct {
		result1 *kms.CancelKeyDeletionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ConnectCustomKeyStore(arg1 *kms.ConnectCustomKeyStoreInput) (*kms.ConnectCustomKeyStoreOutput, error) {
	fake.connectCustomKeyStoreMutex.Lock()
	ret, specificReturn := fake.connectCustomKeyStoreReturnsOnCall[len(fake.connectCustomKeyStoreArgsForCall)]
	fake.connectCustomKeyStoreArgsForCall = append(fake.connectCustomKeyStoreArgsForCall, struct {
		arg1 *kms.ConnectCustomKeyStoreInput
	}{arg1})
	stub := fake.ConnectCustomKeyStoreStub
	fakeReturns := fake.connectCustomKeyStoreReturns
	fake.recordInvocation("ConnectCustomKeyStore", []interface{}{arg1})
	fake.connectCustomKeyStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreCallCount() int {
	fake.connectCustomKeyStoreMutex.RLock()
	defer fake.connectCustomKeyStoreMutex.RUnlock()
	return len(fake.connectCustomKeyStoreArgsForCall)
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreCalls(stub func(*kms.ConnectCustomKeyStoreInput) (*kms.ConnectCustomKeyStoreOutput, error)) {
	fake.connectCustomKeyStoreMutex.Lock()
	defer fake.connectCustomKeyStoreMutex.Unlock()
	fake.ConnectCustomKeyStoreStub = stub
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreArgsForCall(i int) *kms.ConnectCustomKeyStoreInput {
	fake.connectCustomKeyStoreMutex.RLock()
	defer fake.connectCustomKeyStoreMutex.RUnlock()
	argsForCall := fake.connectCustomKeyStoreArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreReturns(result1 *kms.ConnectCustomKeyStoreOutput, result2 error) {
	fake.connectCustomKeyStoreMutex.Lock()
	defer fake.connectCustomKeyStoreMutex.Unlock()
	fake.ConnectCustomKeyStoreStub = nil
	fake.connectCustomKeyStoreReturns = struct {
		result1 *kms.ConnectCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreReturnsOnCall(i int, result1 *kms.ConnectCustomKeyStoreOutput, result2 error) {
	fake.connectCustomKeyStoreMutex.Lock()
	defer fake.connectCustomKeyStoreMutex.Unlock()
	fake.ConnectCustomKeyStoreStub = nil
	if fake.connectCustomKeyStoreReturnsOnCall == nil {
		fake.connectCustomKeyStoreReturnsOnCall = make(map[int]struct {
			result1 *kms.ConnectCustomKeyStoreOutput
			result2 error
		})
	}
	fake.connectCustomKeyStoreReturnsOnCall[i] = struct {
		result1 *kms.ConnectCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreRequest(arg1 *kms.ConnectCustomKeyStoreInput) (*request.Request, *kms.ConnectCustomKeyStoreOutput) {
	fake.connectCustomKeyStoreRequestMutex.Lock()
	ret, specificReturn := fake.connectCustomKeyStoreRequestReturnsOnCall[len(fake.connectCustomKeyStoreRequestArgsForCall)]
	fake.connectCustomKeyStoreRequestArgsForCall = append(fake.connectCustomKeyStoreRequestArgsForCall, struct {
		arg1 *kms.ConnectCustomKeyStoreInput
	}{arg1})
	stub := fake.ConnectCustomKeyStoreRequestStub
	fakeReturns := fake.connectCustomKeyStoreRequestReturns
	fake.recordInvocation("ConnectCustomKeyStoreRequest", []interface{}{arg1})
	fake.connectCustomKeyStoreRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreRequestCallCount() int {
	fake.connectCustomKeyStoreRequestMutex.RLock()
	defer fake.connectCustomKeyStoreRequestMutex.RUnlock()
	return len(fake.connectCustomKeyStoreRequestArgsForCall)
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreRequestCalls(stub func(*kms.ConnectCustomKeyStoreInput) (*request.Request, *kms.ConnectCustomKeyStoreOutput)) {
	fake.connectCustomKeyStoreRequestMutex.Lock()
	defer fake.connectCustomKeyStoreRequestMutex.Unlock()
	fake.ConnectCustomKeyStoreRequestStub = stub
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreRequestArgsForCall(i int) *kms.ConnectCustomKeyStoreInput {
	fake.connectCustomKeyStoreRequestMutex.RLock()
	defer fake.connectCustomKeyStoreRequestMutex.RUnlock()
	argsForCall := fake.connectCustomKeyStoreRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreRequestReturns(result1 *request.Request, result2 *kms.ConnectCustomKeyStoreOutput) {
	fake.connectCustomKeyStoreRequestMutex.Lock()
	defer fake.connectCustomKeyStoreRequestMutex.Unlock()
	fake.ConnectCustomKeyStoreRequestStub = nil
	fake.connectCustomKeyStoreRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ConnectCustomKeyStoreOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ConnectCustomKeyStoreOutput) {
	fake.connectCustomKeyStoreRequestMutex.Lock()
	defer fake.connectCustomKeyStoreRequestMutex.Unlock()
	fake.ConnectCustomKeyStoreRequestStub = nil
	if fake.connectCustomKeyStoreRequestReturnsOnCall == nil {
		fake.connectCustomKeyStoreRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ConnectCustomKeyStoreOutput
		})
	}
	fake.connectCustomKeyStoreRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ConnectCustomKeyStoreOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreWithContext(arg1 context.Context, arg2 *kms.ConnectCustomKeyStoreInput, arg3 ...request.Option) (*kms.ConnectCustomKeyStoreOutput, error) {
	fake.connectCustomKeyStoreWithContextMutex.Lock()
	ret, specificReturn := fake.connectCustomKeyStoreWithContextReturnsOnCall[len(fake.connectCustomKeyStoreWithContextArgsForCall)]
	fake.connectCustomKeyStoreWithContextArgsForCall = append(fake.connectCustomKeyStoreWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ConnectCustomKeyStoreInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ConnectCustomKeyStoreWithContextStub
	fakeReturns := fake.connectCustomKeyStoreWithContextReturns
	fake.recordInvocation("ConnectCustomKeyStoreWithContext", []interface{}{arg1, arg2, arg3})
	fake.connectCustomKeyStoreWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreWithContextCallCount() int {
	fake.connectCustomKeyStoreWithContextMutex.RLock()
	defer fake.connectCustomKeyStoreWithContextMutex.RUnlock()
	return len(fake.connectCustomKeyStoreWithContextArgsForCall)
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreWithContextCalls(stub func(context.Context, *kms.ConnectCustomKeyStoreInput, ...request.Option) (*kms.ConnectCustomKeyStoreOutput, error)) {
	fake.connectCustomKeyStoreWithContextMutex.Lock()
	defer fake.connectCustomKeyStoreWithContextMutex.Unlock()
	fake.ConnectCustomKeyStoreWithContextStub = stub
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreWithContextArgsForCall(i int) (context.Context, *kms.ConnectCustomKeyStoreInput, []request.Option) {
	fake.connectCustomKeyStoreWithContextMutex.RLock()
	defer fake.connectCustomKeyStoreWithContextMutex.RUnlock()
	argsForCall := fake.connectCustomKeyStoreWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreWithContextReturns(result1 *kms.ConnectCustomKeyStoreOutput, result2 error) {
	fake.connectCustomKeyStoreWithContextMutex.Lock()
	defer fake.connectCustomKeyStoreWithContextMutex.Unlock()
	fake.ConnectCustomKeyStoreWithContextStub = nil
	fake.connectCustomKeyStoreWithContextReturns = struct {
		result1 *kms.ConnectCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ConnectCustomKeyStoreWithContextReturnsOnCall(i int, result1 *kms.ConnectCustomKeyStoreOutput, result2 error) {
	fake.connectCustomKeyStoreWithContextMutex.Lock()
	defer fake.connectCustomKeyStoreWithContextMutex.Unlock()
	fake.ConnectCustomKeyStoreWithContextStub = nil
	if fake.connectCustomKeyStoreWithContextReturnsOnCall == nil {
		fake.connectCustomKeyStoreWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ConnectCustomKeyStoreOutput
			result2 error
		})
	}
	fake.connectCustomKeyStoreWithContextReturnsOnCall[i] = struct {
		result1 *kms.ConnectCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateAlias(arg1 *kms.CreateAliasInput) (*kms.CreateAliasOutput, error) {
	fake.createAliasMutex.Lock()
	ret, specificReturn := fake.createAliasReturnsOnCall[len(fake.createAliasArgsForCall)]
	fake.createAliasArgsForCall = append(fake.createAliasArgsForCall, struct {
		arg1 *kms.CreateAliasInput
	}{arg1})
	stub := fake.CreateAliasStub
	fakeReturns := fake.createAliasReturns
	fake.recordInvocation("CreateAlias", []interface{}{arg1})
	fake.createAliasMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateAliasCallCount() int {
	fake.createAliasMutex.RLock()
	defer fake.createAliasMutex.RUnlock()
	return len(fake.createAliasArgsForCall)
}

func (fake *FakeKMSClient) CreateAliasCalls(stub func(*kms.CreateAliasInput) (*kms.CreateAliasOutput, error)) {
	fake.createAliasMutex.Lock()
	defer fake.createAliasMutex.Unlock()
	fake.CreateAliasStub = stub
}

func (fake *FakeKMSClient) CreateAliasArgsForCall(i int) *kms.CreateAliasInput {
	fake.createAliasMutex.RLock()
	defer fake.createAliasMutex.RUnlock()
	argsForCall := fake.createAliasArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) CreateAliasReturns(result1 *kms.CreateAliasOutput, result2 error) {
	fake.createAliasMutex.Lock()
	defer fake.createAliasMutex.Unlock()
	fake.CreateAliasStub = nil
	fake.createAliasReturns = struct {
		result1 *kms.CreateAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateAliasReturnsOnCall(i int, result1 *kms.CreateAliasOutput, result2 error) {
	fake.createAliasMutex.Lock()
	defer fake.createAliasMutex.Unlock()
	fake.CreateAliasStub = nil
	if fake.createAliasReturnsOnCall == nil {
		fake.createAliasReturnsOnCall = make(map[int]struct {
			result1 *kms.CreateAliasOutput
			result2 error
		})
	}
	fake.createAliasReturnsOnCall[i] = struct {
		result1 *kms.CreateAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateAliasRequest(arg1 *kms.CreateAliasInput) (*request.Request, *kms.CreateAliasOutput) {
	fake.createAliasRequestMutex.Lock()
	ret, specificReturn := fake.createAliasRequestReturnsOnCall[len(fake.createAliasRequestArgsForCall)]
	fake.createAliasRequestArgsForCall = append(fake.createAliasRequestArgsForCall, struct {
		arg1 *kms.CreateAliasInput
	}{arg1})
	stub := fake.CreateAliasRequestStub
	fakeReturns := fake.createAliasRequestReturns
	fake.recordInvocation("CreateAliasRequest", []interface{}{arg1})
	fake.createAliasRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateAliasRequestCallCount() int {
	fake.createAliasRequestMutex.RLock()
	defer fake.createAliasRequestMutex.RUnlock()
	return len(fake.createAliasRequestArgsForCall)
}

func (fake *FakeKMSClient) CreateAliasRequestCalls(stub func(*kms.CreateAliasInput) (*request.Request, *kms.CreateAliasOutput)) {
	fake.createAliasRequestMutex.Lock()
	defer fake.createAliasRequestMutex.Unlock()
	fake.CreateAliasRequestStub = stub
}

func (fake *FakeKMSClient) CreateAliasRequestArgsForCall(i int) *kms.CreateAliasInput {
	fake.createAliasRequestMutex.RLock()
	defer fake.createAliasRequestMutex.RUnlock()
	argsForCall := fake.createAliasRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) CreateAliasRequestReturns(result1 *request.Request, result2 *kms.CreateAliasOutput) {
	fake.createAliasRequestMutex.Lock()
	defer fake.createAliasRequestMutex.Unlock()
	fake.CreateAliasRequestStub = nil
	fake.createAliasRequestReturns = struct {
		result1 *request.Request
		result2 *kms.CreateAliasOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateAliasRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.CreateAliasOutput) {
	fake.createAliasRequestMutex.Lock()
	defer fake.createAliasRequestMutex.Unlock()
	fake.CreateAliasRequestStub = nil
	if fake.createAliasRequestReturnsOnCall == nil {
		fake.createAliasRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.CreateAliasOutput
		})
	}
	fake.createAliasRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.CreateAliasOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateAliasWithContext(arg1 context.Context, arg2 *kms.CreateAliasInput, arg3 ...request.Option) (*kms.CreateAliasOutput, error) {
	fake.createAliasWithContextMutex.Lock()
	ret, specificReturn := fake.createAliasWithContextReturnsOnCall[len(fake.createAliasWithContextArgsForCall)]
	fake.createAliasWithContextArgsForCall = append(fake.createAliasWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.CreateAliasInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.CreateAliasWithContextStub
	fakeReturns := fake.createAliasWithContextReturns
	fake.recordInvocation("CreateAliasWithContext", []interface{}{arg1, arg2, arg3})
	fake.createAliasWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateAliasWithContextCallCount() int {
	fake.createAliasWithContextMutex.RLock()
	defer fake.createAliasWithContextMutex.RUnlock()
	return len(fake.createAliasWithContextArgsForCall)
}

func (fake *FakeKMSClient) CreateAliasWithContextCalls(stub func(context.Context, *kms.CreateAliasInput, ...request.Option) (*kms.CreateAliasOutput, error)) {
	fake.createAliasWithContextMutex.Lock()
	defer fake.createAliasWithContextMutex.Unlock()
	fake.CreateAliasWithContextStub = stub
}

func (fake *FakeKMSClient) CreateAliasWithContextArgsForCall(i int) (context.Context, *kms.CreateAliasInput, []request.Option) {
	fake.createAliasWithContextMutex.RLock()
	defer fake.createAliasWithContextMutex.RUnlock()
	argsForCall := fake.createAliasWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) CreateAliasWithContextReturns(result1 *kms.CreateAliasOutput, result2 error) {
	fake.createAliasWithContextMutex.Lock()
	defer fake.createAliasWithContextMutex.Unlock()
	fake.CreateAliasWithContextStub = nil
	fake.createAliasWithContextReturns = struct {
		result1 *kms.CreateAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateAliasWithContextReturnsOnCall(i int, result1 *kms.CreateAliasOutput, result2 error) {
	fake.createAliasWithContextMutex.Lock()
	defer fake.createAliasWithContextMutex.Unlock()
	fake.CreateAliasWithContextStub = nil
	if fake.createAliasWithContextReturnsOnCall == nil {
		fake.createAliasWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.CreateAliasOutput
			result2 error
		})
	}
	fake.createAliasWithContextReturnsOnCall[i] = struct {
		result1 *kms.CreateAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateCustomKeyStore(arg1 *kms.CreateCustomKeyStoreInput) (*kms.CreateCustomKeyStoreOutput, error) {
	fake.createCustomKeyStoreMutex.Lock()
	ret, specificReturn := fake.createCustomKeyStoreReturnsOnCall[len(fake.createCustomKeyStoreArgsForCall)]
	fake.createCustomKeyStoreArgsForCall = append(fake.createCustomKeyStoreArgsForCall, struct {
		arg1 *kms.CreateCustomKeyStoreInput
	}{arg1})
	stub := fake.CreateCustomKeyStoreStub
	fakeReturns := fake.createCustomKeyStoreReturns
	fake.recordInvocation("CreateCustomKeyStore", []interface{}{arg1})
	fake.createCustomKeyStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateCustomKeyStoreCallCount() int {
	fake.createCustomKeyStoreMutex.RLock()
	defer fake.createCustomKeyStoreMutex.RUnlock()
	return len(fake.createCustomKeyStoreArgsForCall)
}

func (fake *FakeKMSClient) CreateCustomKeyStoreCalls(stub func(*kms.CreateCustomKeyStoreInput) (*kms.CreateCustomKeyStoreOutput, error)) {
	fake.createCustomKeyStoreMutex.Lock()
	defer fake.createCustomKeyStoreMutex.Unlock()
	fake.CreateCustomKeyStoreStub = stub
}

func (fake *FakeKMSClient) CreateCustomKeyStoreArgsForCall(i int) *kms.CreateCustomKeyStoreInput {
	fake.createCustomKeyStoreMutex.RLock()
	defer fake.createCustomKeyStoreMutex.RUnlock()
	argsForCall := fake.createCustomKeyStoreArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) CreateCustomKeyStoreReturns(result1 *kms.CreateCustomKeyStoreOutput, result2 error) {
	fake.createCustomKeyStoreMutex.Lock()
	defer fake.createCustomKeyStoreMutex.Unlock()
	fake.CreateCustomKeyStoreStub = nil
	fake.createCustomKeyStoreReturns = struct {
		result1 *kms.CreateCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateCustomKeyStoreReturnsOnCall(i int, result1 *kms.CreateCustomKeyStoreOutput, result2 error) {
	fake.createCustomKeyStoreMutex.Lock()
	defer fake.createCustomKeyStoreMutex.Unlock()
	fake.CreateCustomKeyStoreStub = nil
	if fake.createCustomKeyStoreReturnsOnCall == nil {
		fake.createCustomKeyStoreReturnsOnCall = make(map[int]struct {
			result1 *kms.CreateCustomKeyStoreOutput
			result2 error
		})
	}
	fake.createCustomKeyStoreReturnsOnCall[i] = struct {
		result1 *kms.CreateCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateCustomKeyStoreRequest(arg1 *kms.CreateCustomKeyStoreInput) (*request.Request, *kms.CreateCustomKeyStoreOutput) {
	fake.createCustomKeyStoreRequestMutex.Lock()
	ret, specificReturn := fake.createCustomKeyStoreRequestReturnsOnCall[len(fake.createCustomKeyStoreRequestArgsForCall)]
	fake.createCustomKeyStoreRequestArgsForCall = append(fake.createCustomKeyStoreRequestArgsForCall, struct {
		arg1 *kms.CreateCustomKeyStoreInput
	}{arg1})
	stub := fake.CreateCustomKeyStoreRequestStub
	fakeReturns := fake.createCustomKeyStoreRequestReturns
	fake.recordInvocation("CreateCustomKeyStoreRequest", []interface{}{arg1})
	fake.createCustomKeyStoreRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateCustomKeyStoreRequestCallCount() int {
	fake.createCustomKeyStoreRequestMutex.RLock()
	defer fake.createCustomKeyStoreRequestMutex.RUnlock()
	return len(fake.createCustomKeyStoreRequestArgsForCall)
}

func (fake *FakeKMSClient) CreateCustomKeyStoreRequestCalls(stub func(*kms.CreateCustomKeyStoreInput) (*request.Request, *kms.CreateCustomKeyStoreOutput)) {
	fake.createCustomKeyStoreRequestMutex.Lock()
	defer fake.createCustomKeyStoreRequestMutex.Unlock()
	fake.CreateCustomKeyStoreRequestStub = stub
}

func (fake *FakeKMSClient) CreateCustomKeyStoreRequestArgsForCall(i int) *kms.CreateCustomKeyStoreInput {
	fake.createCustomKeyStoreRequestMutex.RLock()
	defer fake.createCustomKeyStoreRequestMutex.RUnlock()
	argsForCall := fake.createCustomKeyStoreRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) CreateCustomKeyStoreRequestReturns(result1 *request.Request, result2 *kms.CreateCustomKeyStoreOutput) {
	fake.createCustomKeyStoreRequestMutex.Lock()
	defer fake.createCustomKeyStoreRequestMutex.Unlock()
	fake.CreateCustomKeyStoreRequestStub = nil
	fake.createCustomKeyStoreRequestReturns = struct {
		result1 *request.Request
		result2 *kms.CreateCustomKeyStoreOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateCustomKeyStoreRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.CreateCustomKeyStoreOutput) {
	fake.createCustomKeyStoreRequestMutex.Lock()
	defer fake.createCustomKeyStoreRequestMutex.Unlock()
	fake.CreateCustomKeyStoreRequestStub = nil
	if fake.createCustomKeyStoreRequestReturnsOnCall == nil {
		fake.createCustomKeyStoreRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.CreateCustomKeyStoreOutput
		})
	}
	fake.createCustomKeyStoreRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.CreateCustomKeyStoreOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateCustomKeyStoreWithContext(arg1 context.Context, arg2 *kms.CreateCustomKeyStoreInput, arg3 ...request.Option) (*kms.CreateCustomKeyStoreOutput, error) {
	fake.createCustomKeyStoreWithContextMutex.Lock()
	ret, specificReturn := fake.createCustomKeyStoreWithContextReturnsOnCall[len(fake.createCustomKeyStoreWithContextArgsForCall)]
	fake.createCustomKeyStoreWithContextArgsForCall = append(fake.createCustomKeyStoreWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.CreateCustomKeyStoreInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.CreateCustomKeyStoreWithContextStub
	fakeReturns := fake.createCustomKeyStoreWithContextReturns
	fake.recordInvocation("CreateCustomKeyStoreWithContext", []interface{}{arg1, arg2, arg3})
	fake.createCustomKeyStoreWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateCustomKeyStoreWithContextCallCount() int {
	fake.createCustomKeyStoreWithContextMutex.RLock()
	defer fake.createCustomKeyStoreWithContextMutex.RUnlock()
	return len(fake.createCustomKeyStoreWithContextArgsForCall)
}

func (fake *FakeKMSClient) CreateCustomKeyStoreWithContextCalls(stub func(context.Context, *kms.CreateCustomKeyStoreInput, ...request.Option) (*kms.CreateCustomKeyStoreOutput, error)) {
	fake.createCustomKeyStoreWithContextMutex.Lock()
	defer fake.createCustomKeyStoreWithContextMutex.Unlock()
	fake.CreateCustomKeyStoreWithContextStub = stub
}

func (fake *FakeKMSClient) CreateCustomKeyStoreWithContextArgsForCall(i int) (context.Context, *kms.CreateCustomKeyStoreInput, []request.Option) {
	fake.createCustomKeyStoreWithContextMutex.RLock()
	defer fake.createCustomKeyStoreWithContextMutex.RUnlock()
	argsForCall := fake.createCustomKeyStoreWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) CreateCustomKeyStoreWithContextReturns(result1 *kms.CreateCustomKeyStoreOutput, result2 error) {
	fake.createCustomKeyStoreWithContextMutex.Lock()
	defer fake.createCustomKeyStoreWithContextMutex.Unlock()
	fake.CreateCustomKeyStoreWithContextStub = nil
	fake.createCustomKeyStoreWithContextReturns = struct {
		result1 *kms.CreateCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateCustomKeyStoreWithContextReturnsOnCall(i int, result1 *kms.CreateCustomKeyStoreOutput, result2 error) {
	fake.createCustomKeyStoreWithContextMutex.Lock()
	defer fake.createCustomKeyStoreWithContextMutex.Unlock()
	fake.CreateCustomKeyStoreWithContextStub = nil
	if fake.createCustomKeyStoreWithContextReturnsOnCall == nil {
		fake.createCustomKeyStoreWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.CreateCustomKeyStoreOutput
			result2 error
		})
	}
	fake.createCustomKeyStoreWithContextReturnsOnCall[i] = struct {
		result1 *kms.CreateCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateGrant(arg1 *kms.CreateGrantInput) (*kms.CreateGrantOutput, error) {
	fake.createGrantMutex.Lock()
	ret, specificReturn := fake.createGrantReturnsOnCall[len(fake.createGrantArgsForCall)]
	fake.createGrantArgsForCall = append(fake.createGrantArgsForCall, struct {
		arg1 *kms.CreateGrantInput
	}{arg1})
	stub := fake.CreateGrantStub
	fakeReturns := fake.createGrantReturns
	fake.recordInvocation("CreateGrant", []interface{}{arg1})
	fake.createGrantMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateGrantCallCount() int {
	fake.createGrantMutex.RLock()
	defer fake.createGrantMutex.RUnlock()
	return len(fake.createGrantArgsForCall)
}

func (fake *FakeKMSClient) CreateGrantCalls(stub func(*kms.CreateGrantInput) (*kms.CreateGrantOutput, error)) {
	fake.createGrantMutex.Lock()
	defer fake.createGrantMutex.Unlock()
	fake.CreateGrantStub = stub
}

func (fake *FakeKMSClient) CreateGrantArgsForCall(i int) *kms.CreateGrantInput {
	fake.createGrantMutex.RLock()
	defer fake.createGrantMutex.RUnlock()
	argsForCall := fake.createGrantArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) CreateGrantReturns(result1 *kms.CreateGrantOutput, result2 error) {
	fake.createGrantMutex.Lock()
	defer fake.createGrantMutex.Unlock()
	fake.CreateGrantStub = nil
	fake.createGrantReturns = struct {
		result1 *kms.CreateGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateGrantReturnsOnCall(i int, result1 *kms.CreateGrantOutput, result2 error) {
	fake.createGrantMutex.Lock()
	defer fake.createGrantMutex.Unlock()
	fake.CreateGrantStub = nil
	if fake.createGrantReturnsOnCall == nil {
		fake.createGrantReturnsOnCall = make(map[int]struct {
			result1 *kms.CreateGrantOutput
			result2 error
		})
	}
	fake.createGrantReturnsOnCall[i] = struct {
		result1 *kms.CreateGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateGrantRequest(arg1 *kms.CreateGrantInput) (*request.Request, *kms.CreateGrantOutput) {
	fake.createGrantRequestMutex.Lock()
	ret, specificReturn := fake.createGrantRequestReturnsOnCall[len(fake.createGrantRequestArgsForCall)]
	fake.createGrantRequestArgsForCall = append(fake.createGrantRequestArgsForCall, struct {
		arg1 *kms.CreateGrantInput
	}{arg1})
	stub := fake.CreateGrantRequestStub
	fakeReturns := fake.createGrantRequestReturns
	fake.recordInvocation("CreateGrantRequest", []interface{}{arg1})
	fake.createGrantRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateGrantRequestCallCount() int {
	fake.createGrantRequestMutex.RLock()
	defer fake.createGrantRequestMutex.RUnlock()
	return len(fake.createGrantRequestArgsForCall)
}

func (fake *FakeKMSClient) CreateGrantRequestCalls(stub func(*kms.CreateGrantInput) (*request.Request, *kms.CreateGrantOutput)) {
	fake.createGrantRequestMutex.Lock()
	defer fake.createGrantRequestMutex.Unlock()
	fake.CreateGrantRequestStub = stub
}

func (fake *FakeKMSClient) CreateGrantRequestArgsForCall(i int) *kms.CreateGrantInput {
	fake.createGrantRequestMutex.RLock()
	defer fake.createGrantRequestMutex.RUnlock()
	argsForCall := fake.createGrantRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) CreateGrantRequestReturns(result1 *request.Request, result2 *kms.CreateGrantOutput) {
	fake.createGrantRequestMutex.Lock()
	defer fake.createGrantRequestMutex.Unlock()
	fake.CreateGrantRequestStub = nil
	fake.createGrantRequestReturns = struct {
		result1 *request.Request
		result2 *kms.CreateGrantOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateGrantRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.CreateGrantOutput) {
	fake.createGrantRequestMutex.Lock()
	defer fake.createGrantRequestMutex.Unlock()
	fake.CreateGrantRequestStub = nil
	if fake.createGrantRequestReturnsOnCall == nil {
		fake.createGrantRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.CreateGrantOutput
		})
	}
	fake.createGrantRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.CreateGrantOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateGrantWithContext(arg1 context.Context, arg2 *kms.CreateGrantInput, arg3 ...request.Option) (*kms.CreateGrantOutput, error) {
	fake.createGrantWithContextMutex.Lock()
	ret, specificReturn := fake.createGrantWithContextReturnsOnCall[len(fake.createGrantWithContextArgsForCall)]
	fake.createGrantWithContextArgsForCall = append(fake.createGrantWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.CreateGrantInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.CreateGrantWithContextStub
	fakeReturns := fake.createGrantWithContextReturns
	fake.recordInvocation("CreateGrantWithContext", []interface{}{arg1, arg2, arg3})
	fake.createGrantWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateGrantWithContextCallCount() int {
	fake.createGrantWithContextMutex.RLock()
	defer fake.createGrantWithContextMutex.RUnlock()
	return len(fake.createGrantWithContextArgsForCall)
}

func (fake *FakeKMSClient) CreateGrantWithContextCalls(stub func(context.Context, *kms.CreateGrantInput, ...request.Option) (*kms.CreateGrantOutput, error)) {
	fake.createGrantWithContextMutex.Lock()
	defer fake.createGrantWithContextMutex.Unlock()
	fake.CreateGrantWithContextStub = stub
}

func (fake *FakeKMSClient) CreateGrantWithContextArgsForCall(i int) (context.Context, *kms.CreateGrantInput, []request.Option) {
	fake.createGrantWithContextMutex.RLock()
	defer fake.createGrantWithContextMutex.RUnlock()
	argsForCall := fake.createGrantWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) CreateGrantWithContextReturns(result1 *kms.CreateGrantOutput, result2 error) {
	fake.createGrantWithContextMutex.Lock()
	defer fake.createGrantWithContextMutex.Unlock()
	fake.CreateGrantWithContextStub = nil
	fake.createGrantWithContextReturns = struct {
		result1 *kms.CreateGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateGrantWithContextReturnsOnCall(i int, result1 *kms.CreateGrantOutput, result2 error) {
	fake.createGrantWithContextMutex.Lock()
	defer fake.createGrantWithContextMutex.Unlock()
	fake.CreateGrantWithContextStub = nil
	if fake.createGrantWithContextReturnsOnCall == nil {
		fake.createGrantWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.CreateGrantOutput
			result2 error
		})
	}
	fake.createGrantWithContextReturnsOnCall[i] = struct {
		result1 *kms.CreateGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateKey(arg1 *kms.CreateKeyInput) (*kms.CreateKeyOutput, error) {
	fake.createKeyMutex.Lock()
	ret, specificReturn := fake.createKeyReturnsOnCall[len(fake.createKeyArgsForCall)]
	fake.createKeyArgsForCall = append(fake.createKeyArgsForCall, struct {
		arg1 *kms.CreateKeyInput
	}{arg1})
	stub := fake.CreateKeyStub
	fakeReturns := fake.createKeyReturns
	fake.recordInvocation("CreateKey", []interface{}{arg1})
	fake.createKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateKeyCallCount() int {
	fake.createKeyMutex.RLock()
	defer fake.createKeyMutex.RUnlock()
	return len(fake.createKeyArgsForCall)
}

func (fake *FakeKMSClient) CreateKeyCalls(stub func(*kms.CreateKeyInput) (*kms.CreateKeyOutput, error)) {
	fake.createKeyMutex.Lock()
	defer fake.createKeyMutex.Unlock()
	fake.CreateKeyStub = stub
}

func (fake *FakeKMSClient) CreateKeyArgsForCall(i int) *kms.CreateKeyInput {
	fake.createKeyMutex.RLock()
	defer fake.createKeyMutex.RUnlock()
	argsForCall := fake.createKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) CreateKeyReturns(result1 *kms.CreateKeyOutput, result2 error) {
	fake.createKeyMutex.Lock()
	defer fake.createKeyMutex.Unlock()
	fake.CreateKeyStub = nil
	fake.createKeyReturns = struct {
		result1 *kms.CreateKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateKeyReturnsOnCall(i int, result1 *kms.CreateKeyOutput, result2 error) {
	fake.createKeyMutex.Lock()
	defer fake.createKeyMutex.Unlock()
	fake.CreateKeyStub = nil
	if fake.createKeyReturnsOnCall == nil {
		fake.createKeyReturnsOnCall = make(map[int]struct {
			result1 *kms.CreateKeyOutput
			result2 error
		})
	}
	fake.createKeyReturnsOnCall[i] = struct {
		result1 *kms.CreateKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateKeyRequest(arg1 *kms.CreateKeyInput) (*request.Request, *kms.CreateKeyOutput) {
	fake.createKeyRequestMutex.Lock()
	ret, specificReturn := fake.createKeyRequestReturnsOnCall[len(fake.createKeyRequestArgsForCall)]
	fake.createKeyRequestArgsForCall = append(fake.createKeyRequestArgsForCall, struct {
		arg1 *kms.CreateKeyInput
	}{arg1})
	stub := fake.CreateKeyRequestStub
	fakeReturns := fake.createKeyRequestReturns
	fake.recordInvocation("CreateKeyRequest", []interface{}{arg1})
	fake.createKeyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateKeyRequestCallCount() int {
	fake.createKeyRequestMutex.RLock()
	defer fake.createKeyRequestMutex.RUnlock()
	return len(fake.createKeyRequestArgsForCall)
}

func (fake *FakeKMSClient) CreateKeyRequestCalls(stub func(*kms.CreateKeyInput) (*request.Request, *kms.CreateKeyOutput)) {
	fake.createKeyRequestMutex.Lock()
	defer fake.createKeyRequestMutex.Unlock()
	fake.CreateKeyRequestStub = stub
}

func (fake *FakeKMSClient) CreateKeyRequestArgsForCall(i int) *kms.CreateKeyInput {
	fake.createKeyRequestMutex.RLock()
	defer fake.createKeyRequestMutex.RUnlock()
	argsForCall := fake.createKeyRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) CreateKeyRequestReturns(result1 *request.Request, result2 *kms.CreateKeyOutput) {
	fake.createKeyRequestMutex.Lock()
	defer fake.createKeyRequestMutex.Unlock()
	fake.CreateKeyRequestStub = nil
	fake.createKeyRequestReturns = struct {
		result1 *request.Request
		result2 *kms.CreateKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateKeyRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.CreateKeyOutput) {
	fake.createKeyRequestMutex.Lock()
	defer fake.createKeyRequestMutex.Unlock()
	fake.CreateKeyRequestStub = nil
	if fake.createKeyRequestReturnsOnCall == nil {
		fake.createKeyRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.CreateKeyOutput
		})
	}
	fake.createKeyRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.CreateKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateKeyWithContext(arg1 context.Context, arg2 *kms.CreateKeyInput, arg3 ...request.Option) (*kms.CreateKeyOutput, error) {
	fake.createKeyWithContextMutex.Lock()
	ret, specificReturn := fake.createKeyWithContextReturnsOnCall[len(fake.createKeyWithContextArgsForCall)]
	fake.createKeyWithContextArgsForCall = append(fake.createKeyWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.CreateKeyInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.CreateKeyWithContextStub
	fakeReturns := fake.createKeyWithContextReturns
	fake.recordInvocation("CreateKeyWithContext", []interface{}{arg1, arg2, arg3})
	fake.createKeyWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) CreateKeyWithContextCallCount() int {
	fake.createKeyWithContextMutex.RLock()
	defer fake.createKeyWithContextMutex.RUnlock()
	return len(fake.createKeyWithContextArgsForCall)
}

func (fake *FakeKMSClient) CreateKeyWithContextCalls(stub func(context.Context, *kms.CreateKeyInput, ...request.Option) (*kms.CreateKeyOutput, error)) {
	fake.createKeyWithContextMutex.Lock()
	defer fake.createKeyWithContextMutex.Unlock()
	fake.CreateKeyWithContextStub = stub
}

func (fake *FakeKMSClient) CreateKeyWithContextArgsForCall(i int) (context.Context, *kms.CreateKeyInput, []request.Option) {
	fake.createKeyWithContextMutex.RLock()
	defer fake.createKeyWithContextMutex.RUnlock()
	argsForCall := fake.createKeyWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) CreateKeyWithContextReturns(result1 *kms.CreateKeyOutput, result2 error) {
	fake.createKeyWithContextMutex.Lock()
	defer fake.createKeyWithContextMutex.Unlock()
	fake.CreateKeyWithContextStub = nil
	fake.createKeyWithContextReturns = struct {
		result1 *kms.CreateKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) CreateKeyWithContextReturnsOnCall(i int, result1 *kms.CreateKeyOutput, result2 error) {
	fake.createKeyWithContextMutex.Lock()
	defer fake.createKeyWithContextMutex.Unlock()
	fake.CreateKeyWithContextStub = nil
	if fake.createKeyWithContextReturnsOnCall == nil {
		fake.createKeyWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.CreateKeyOutput
			result2 error
		})
	}
	fake.createKeyWithContextReturnsOnCall[i] = struct {
		result1 *kms.CreateKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) Decrypt(arg1 *kms.DecryptInput) (*kms.DecryptOutput, error) {
	fake.decryptMutex.Lock()
	ret, specificReturn := fake.decryptReturnsOnCall[len(fake.decryptArgsForCall)]
	fake.decryptArgsForCall = append(fake.decryptArgsForCall, struct {
		arg1 *kms.DecryptInput
	}{arg1})
	stub := fake.DecryptStub
	fakeReturns := fake.decryptReturns
	fake.recordInvocation("Decrypt", []interface{}{arg1})
	fake.decryptMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DecryptCallCount() int {
	fake.decryptMutex.RLock()
	defer fake.decryptMutex.RUnlock()
	return len(fake.decryptArgsForCall)
}

func (fake *FakeKMSClient) DecryptCalls(stub func(*kms.DecryptInput) (*kms.DecryptOutput, error)) {
	fake.decryptMutex.Lock()
	defer fake.decryptMutex.Unlock()
	fake.DecryptStub = stub
}

func (fake *FakeKMSClient) DecryptArgsForCall(i int) *kms.DecryptInput {
	fake.decryptMutex.RLock()
	defer fake.decryptMutex.RUnlock()
	argsForCall := fake.decryptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DecryptReturns(result1 *kms.DecryptOutput, result2 error) {
	fake.decryptMutex.Lock()
	defer fake.decryptMutex.Unlock()
	fake.DecryptStub = nil
	fake.decryptReturns = struct {
		result1 *kms.DecryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DecryptReturnsOnCall(i int, result1 *kms.DecryptOutput, result2 error) {
	fake.decryptMutex.Lock()
	defer fake.decryptMutex.Unlock()
	fake.DecryptStub = nil
	if fake.decryptReturnsOnCall == nil {
		fake.decryptReturnsOnCall = make(map[int]struct {
			result1 *kms.DecryptOutput
			result2 error
		})
	}
	fake.decryptReturnsOnCall[i] = struct {
		result1 *kms.DecryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DecryptRequest(arg1 *kms.DecryptInput) (*request.Request, *kms.DecryptOutput) {
	fake.decryptRequestMutex.Lock()
	ret, specificReturn := fake.decryptRequestReturnsOnCall[len(fake.decryptRequestArgsForCall)]
	fake.decryptRequestArgsForCall = append(fake.decryptRequestArgsForCall, struct {
		arg1 *kms.DecryptInput
	}{arg1})
	stub := fake.DecryptRequestStub
	fakeReturns := fake.decryptRequestReturns
	fake.recordInvocation("DecryptRequest", []interface{}{arg1})
	fake.decryptRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DecryptRequestCallCount() int {
	fake.decryptRequestMutex.RLock()
	defer fake.decryptRequestMutex.RUnlock()
	return len(fake.decryptRequestArgsForCall)
}

func (fake *FakeKMSClient) DecryptRequestCalls(stub func(*kms.DecryptInput) (*request.Request, *kms.DecryptOutput)) {
	fake.decryptRequestMutex.Lock()
	defer fake.decryptRequestMutex.Unlock()
	fake.DecryptRequestStub = stub
}

func (fake *FakeKMSClient) DecryptRequestArgsForCall(i int) *kms.DecryptInput {
	fake.decryptRequestMutex.RLock()
	defer fake.decryptRequestMutex.RUnlock()
	argsForCall := fake.decryptRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DecryptRequestReturns(result1 *request.Request, result2 *kms.DecryptOutput) {
	fake.decryptRequestMutex.Lock()
	defer fake.decryptRequestMutex.Unlock()
	fake.DecryptRequestStub = nil
	fake.decryptRequestReturns = struct {
		result1 *request.Request
		result2 *kms.DecryptOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DecryptRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.DecryptOutput) {
	fake.decryptRequestMutex.Lock()
	defer fake.decryptRequestMutex.Unlock()
	fake.DecryptRequestStub = nil
	if fake.decryptRequestReturnsOnCall == nil {
		fake.decryptRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.DecryptOutput
		})
	}
	fake.decryptRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.DecryptOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DecryptWithContext(arg1 context.Context, arg2 *kms.DecryptInput, arg3 ...request.Option) (*kms.DecryptOutput, error) {
	fake.decryptWithContextMutex.Lock()
	ret, specificReturn := fake.decryptWithContextReturnsOnCall[len(fake.decryptWithContextArgsForCall)]
	fake.decryptWithContextArgsForCall = append(fake.decryptWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.DecryptInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DecryptWithContextStub
	fakeReturns := fake.decryptWithContextReturns
	fake.recordInvocation("DecryptWithContext", []interface{}{arg1, arg2, arg3})
	fake.decryptWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DecryptWithContextCallCount() int {
	fake.decryptWithContextMutex.RLock()
	defer fake.decryptWithContextMutex.RUnlock()
	return len(fake.decryptWithContextArgsForCall)
}

func (fake *FakeKMSClient) DecryptWithContextCalls(stub func(context.Context, *kms.DecryptInput, ...request.Option) (*kms.DecryptOutput, error)) {
	fake.decryptWithContextMutex.Lock()
	defer fake.decryptWithContextMutex.Unlock()
	fake.DecryptWithContextStub = stub
}

func (fake *FakeKMSClient) DecryptWithContextArgsForCall(i int) (context.Context, *kms.DecryptInput, []request.Option) {
	fake.decryptWithContextMutex.RLock()
	defer fake.decryptWithContextMutex.RUnlock()
	argsForCall := fake.decryptWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) DecryptWithContextReturns(result1 *kms.DecryptOutput, result2 error) {
	fake.decryptWithContextMutex.Lock()
	defer fake.decryptWithContextMutex.Unlock()
	fake.DecryptWithContextStub = nil
	fake.decryptWithContextReturns = struct {
		result1 *kms.DecryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DecryptWithContextReturnsOnCall(i int, result1 *kms.DecryptOutput, result2 error) {
	fake.decryptWithContextMutex.Lock()
	defer fake.decryptWithContextMutex.Unlock()
	fake.DecryptWithContextStub = nil
	if fake.decryptWithContextReturnsOnCall == nil {
		fake.decryptWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.DecryptOutput
			result2 error
		})
	}
	fake.decryptWithContextReturnsOnCall[i] = struct {
		result1 *kms.DecryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteAlias(arg1 *kms.DeleteAliasInput) (*kms.DeleteAliasOutput, error) {
	fake.deleteAliasMutex.Lock()
	ret, specificReturn := fake.deleteAliasReturnsOnCall[len(fake.deleteAliasArgsForCall)]
	fake.deleteAliasArgsForCall = append(fake.deleteAliasArgsForCall, struct {
		arg1 *kms.DeleteAliasInput
	}{arg1})
	stub := fake.DeleteAliasStub
	fakeReturns := fake.deleteAliasReturns
	fake.recordInvocation("DeleteAlias", []interface{}{arg1})
	fake.deleteAliasMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DeleteAliasCallCount() int {
	fake.deleteAliasMutex.RLock()
	defer fake.deleteAliasMutex.RUnlock()
	return len(fake.deleteAliasArgsForCall)
}

func (fake *FakeKMSClient) DeleteAliasCalls(stub func(*kms.DeleteAliasInput) (*kms.DeleteAliasOutput, error)) {
	fake.deleteAliasMutex.Lock()
	defer fake.deleteAliasMutex.Unlock()
	fake.DeleteAliasStub = stub
}

func (fake *FakeKMSClient) DeleteAliasArgsForCall(i int) *kms.DeleteAliasInput {
	fake.deleteAliasMutex.RLock()
	defer fake.deleteAliasMutex.RUnlock()
	argsForCall := fake.deleteAliasArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DeleteAliasReturns(result1 *kms.DeleteAliasOutput, result2 error) {
	fake.deleteAliasMutex.Lock()
	defer fake.deleteAliasMutex.Unlock()
	fake.DeleteAliasStub = nil
	fake.deleteAliasReturns = struct {
		result1 *kms.DeleteAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteAliasReturnsOnCall(i int, result1 *kms.DeleteAliasOutput, result2 error) {
	fake.deleteAliasMutex.Lock()
	defer fake.deleteAliasMutex.Unlock()
	fake.DeleteAliasStub = nil
	if fake.deleteAliasReturnsOnCall == nil {
		fake.deleteAliasReturnsOnCall = make(map[int]struct {
			result1 *kms.DeleteAliasOutput
			result2 error
		})
	}
	fake.deleteAliasReturnsOnCall[i] = struct {
		result1 *kms.DeleteAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteAliasRequest(arg1 *kms.DeleteAliasInput) (*request.Request, *kms.DeleteAliasOutput) {
	fake.deleteAliasRequestMutex.Lock()
	ret, specificReturn := fake.deleteAliasRequestReturnsOnCall[len(fake.deleteAliasRequestArgsForCall)]
	fake.deleteAliasRequestArgsForCall = append(fake.deleteAliasRequestArgsForCall, struct {
		arg1 *kms.DeleteAliasInput
	}{arg1})
	stub := fake.DeleteAliasRequestStub
	fakeReturns := fake.deleteAliasRequestReturns
	fake.recordInvocation("DeleteAliasRequest", []interface{}{arg1})
	fake.deleteAliasRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DeleteAliasRequestCallCount() int {
	fake.deleteAliasRequestMutex.RLock()
	defer fake.deleteAliasRequestMutex.RUnlock()
	return len(fake.deleteAliasRequestArgsForCall)
}

func (fake *FakeKMSClient) DeleteAliasRequestCalls(stub func(*kms.DeleteAliasInput) (*request.Request, *kms.DeleteAliasOutput)) {
	fake.deleteAliasRequestMutex.Lock()
	defer fake.deleteAliasRequestMutex.Unlock()
	fake.DeleteAliasRequestStub = stub
}

func (fake *FakeKMSClient) DeleteAliasRequestArgsForCall(i int) *kms.DeleteAliasInput {
	fake.deleteAliasRequestMutex.RLock()
	defer fake.deleteAliasRequestMutex.RUnlock()
	argsForCall := fake.deleteAliasRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DeleteAliasRequestReturns(result1 *request.Request, result2 *kms.DeleteAliasOutput) {
	fake.deleteAliasRequestMutex.Lock()
	defer fake.deleteAliasRequestMutex.Unlock()
	fake.DeleteAliasRequestStub = nil
	fake.deleteAliasRequestReturns = struct {
		result1 *request.Request
		result2 *kms.DeleteAliasOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteAliasRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.DeleteAliasOutput) {
	fake.deleteAliasRequestMutex.Lock()
	defer fake.deleteAliasRequestMutex.Unlock()
	fake.DeleteAliasRequestStub = nil
	if fake.deleteAliasRequestReturnsOnCall == nil {
		fake.deleteAliasRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.DeleteAliasOutput
		})
	}
	fake.deleteAliasRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.DeleteAliasOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteAliasWithContext(arg1 context.Context, arg2 *kms.DeleteAliasInput, arg3 ...request.Option) (*kms.DeleteAliasOutput, error) {
	fake.deleteAliasWithContextMutex.Lock()
	ret, specificReturn := fake.deleteAliasWithContextReturnsOnCall[len(fake.deleteAliasWithContextArgsForCall)]
	fake.deleteAliasWithContextArgsForCall = append(fake.deleteAliasWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.DeleteAliasInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DeleteAliasWithContextStub
	fakeReturns := fake.deleteAliasWithContextReturns
	fake.recordInvocation("DeleteAliasWithContext", []interface{}{arg1, arg2, arg3})
	fake.deleteAliasWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DeleteAliasWithContextCallCount() int {
	fake.deleteAliasWithContextMutex.RLock()
	defer fake.deleteAliasWithContextMutex.RUnlock()
	return len(fake.deleteAliasWithContextArgsForCall)
}

func (fake *FakeKMSClient) DeleteAliasWithContextCalls(stub func(context.Context, *kms.DeleteAliasInput, ...request.Option) (*kms.DeleteAliasOutput, error)) {
	fake.deleteAliasWithContextMutex.Lock()
	defer fake.deleteAliasWithContextMutex.Unlock()
	fake.DeleteAliasWithContextStub = stub
}

func (fake *FakeKMSClient) DeleteAliasWithContextArgsForCall(i int) (context.Context, *kms.DeleteAliasInput, []request.Option) {
	fake.deleteAliasWithContextMutex.RLock()
	defer fake.deleteAliasWithContextMutex.RUnlock()
	argsForCall := fake.deleteAliasWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) DeleteAliasWithContextReturns(result1 *kms.DeleteAliasOutput, result2 error) {
	fake.deleteAliasWithContextMutex.Lock()
	defer fake.deleteAliasWithContextMutex.Unlock()
	fake.DeleteAliasWithContextStub = nil
	fake.deleteAliasWithContextReturns = struct {
		result1 *kms.DeleteAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteAliasWithContextReturnsOnCall(i int, result1 *kms.DeleteAliasOutput, result2 error) {
	fake.deleteAliasWithContextMutex.Lock()
	defer fake.deleteAliasWithContextMutex.Unlock()
	fake.DeleteAliasWithContextStub = nil
	if fake.deleteAliasWithContextReturnsOnCall == nil {
		fake.deleteAliasWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.DeleteAliasOutput
			result2 error
		})
	}
	fake.deleteAliasWithContextReturnsOnCall[i] = struct {
		result1 *kms.DeleteAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteCustomKeyStore(arg1 *kms.DeleteCustomKeyStoreInput) (*kms.DeleteCustomKeyStoreOutput, error) {
	fake.deleteCustomKeyStoreMutex.Lock()
	ret, specificReturn := fake.deleteCustomKeyStoreReturnsOnCall[len(fake.deleteCustomKeyStoreArgsForCall)]
	fake.deleteCustomKeyStoreArgsForCall = append(fake.deleteCustomKeyStoreArgsForCall, struct {
		arg1 *kms.DeleteCustomKeyStoreInput
	}{arg1})
	stub := fake.DeleteCustomKeyStoreStub
	fakeReturns := fake.deleteCustomKeyStoreReturns
	fake.recordInvocation("DeleteCustomKeyStore", []interface{}{arg1})
	fake.deleteCustomKeyStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreCallCount() int {
	fake.deleteCustomKeyStoreMutex.RLock()
	defer fake.deleteCustomKeyStoreMutex.RUnlock()
	return len(fake.deleteCustomKeyStoreArgsForCall)
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreCalls(stub func(*kms.DeleteCustomKeyStoreInput) (*kms.DeleteCustomKeyStoreOutput, error)) {
	fake.deleteCustomKeyStoreMutex.Lock()
	defer fake.deleteCustomKeyStoreMutex.Unlock()
	fake.DeleteCustomKeyStoreStub = stub
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreArgsForCall(i int) *kms.DeleteCustomKeyStoreInput {
	fake.deleteCustomKeyStoreMutex.RLock()
	defer fake.deleteCustomKeyStoreMutex.RUnlock()
	argsForCall := fake.deleteCustomKeyStoreArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreReturns(result1 *kms.DeleteCustomKeyStoreOutput, result2 error) {
	fake.deleteCustomKeyStoreMutex.Lock()
	defer fake.deleteCustomKeyStoreMutex.Unlock()
	fake.DeleteCustomKeyStoreStub = nil
	fake.deleteCustomKeyStoreReturns = struct {
		result1 *kms.DeleteCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreReturnsOnCall(i int, result1 *kms.DeleteCustomKeyStoreOutput, result2 error) {
	fake.deleteCustomKeyStoreMutex.Lock()
	defer fake.deleteCustomKeyStoreMutex.Unlock()
	fake.DeleteCustomKeyStoreStub = nil
	if fake.deleteCustomKeyStoreReturnsOnCall == nil {
		fake.deleteCustomKeyStoreReturnsOnCall = make(map[int]struct {
			result1 *kms.DeleteCustomKeyStoreOutput
			result2 error
		})
	}
	fake.deleteCustomKeyStoreReturnsOnCall[i] = struct {
		result1 *kms.DeleteCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreRequest(arg1 *kms.DeleteCustomKeyStoreInput) (*request.Request, *kms.DeleteCustomKeyStoreOutput) {
	fake.deleteCustomKeyStoreRequestMutex.Lock()
	ret, specificReturn := fake.deleteCustomKeyStoreRequestReturnsOnCall[len(fake.deleteCustomKeyStoreRequestArgsForCall)]
	fake.deleteCustomKeyStoreRequestArgsForCall = append(fake.deleteCustomKeyStoreRequestArgsForCall, struct {
		arg1 *kms.DeleteCustomKeyStoreInput
	}{arg1})
	stub := fake.DeleteCustomKeyStoreRequestStub
	fakeReturns := fake.deleteCustomKeyStoreRequestReturns
	fake.recordInvocation("DeleteCustomKeyStoreRequest", []interface{}{arg1})
	fake.deleteCustomKeyStoreRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreRequestCallCount() int {
	fake.deleteCustomKeyStoreRequestMutex.RLock()
	defer fake.deleteCustomKeyStoreRequestMutex.RUnlock()
	return len(fake.deleteCustomKeyStoreRequestArgsForCall)
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreRequestCalls(stub func(*kms.DeleteCustomKeyStoreInput) (*request.Request, *kms.DeleteCustomKeyStoreOutput)) {
	fake.deleteCustomKeyStoreRequestMutex.Lock()
	defer fake.deleteCustomKeyStoreRequestMutex.Unlock()
	fake.DeleteCustomKeyStoreRequestStub = stub
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreRequestArgsForCall(i int) *kms.DeleteCustomKeyStoreInput {
	fake.deleteCustomKeyStoreRequestMutex.RLock()
	defer fake.deleteCustomKeyStoreRequestMutex.RUnlock()
	argsForCall := fake.deleteCustomKeyStoreRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreRequestReturns(result1 *request.Request, result2 *kms.DeleteCustomKeyStoreOutput) {
	fake.deleteCustomKeyStoreRequestMutex.Lock()
	defer fake.deleteCustomKeyStoreRequestMutex.Unlock()
	fake.DeleteCustomKeyStoreRequestStub = nil
	fake.deleteCustomKeyStoreRequestReturns = struct {
		result1 *request.Request
		result2 *kms.DeleteCustomKeyStoreOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.DeleteCustomKeyStoreOutput) {
	fake.deleteCustomKeyStoreRequestMutex.Lock()
	defer fake.deleteCustomKeyStoreRequestMutex.Unlock()
	fake.DeleteCustomKeyStoreRequestStub = nil
	if fake.deleteCustomKeyStoreRequestReturnsOnCall == nil {
		fake.deleteCustomKeyStoreRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.DeleteCustomKeyStoreOutput
		})
	}
	fake.deleteCustomKeyStoreRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.DeleteCustomKeyStoreOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreWithContext(arg1 context.Context, arg2 *kms.DeleteCustomKeyStoreInput, arg3 ...request.Option) (*kms.DeleteCustomKeyStoreOutput, error) {
	fake.deleteCustomKeyStoreWithContextMutex.Lock()
	ret, specificReturn := fake.deleteCustomKeyStoreWithContextReturnsOnCall[len(fake.deleteCustomKeyStoreWithContextArgsForCall)]
	fake.deleteCustomKeyStoreWithContextArgsForCall = append(fake.deleteCustomKeyStoreWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.DeleteCustomKeyStoreInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DeleteCustomKeyStoreWithContextStub
	fakeReturns := fake.deleteCustomKeyStoreWithContextReturns
	fake.recordInvocation("DeleteCustomKeyStoreWithContext", []interface{}{arg1, arg2, arg3})
	fake.deleteCustomKeyStoreWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreWithContextCallCount() int {
	fake.deleteCustomKeyStoreWithContextMutex.RLock()
	defer fake.deleteCustomKeyStoreWithContextMutex.RUnlock()
	return len(fake.deleteCustomKeyStoreWithContextArgsForCall)
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreWithContextCalls(stub func(context.Context, *kms.DeleteCustomKeyStoreInput, ...request.Option) (*kms.DeleteCustomKeyStoreOutput, error)) {
	fake.deleteCustomKeyStoreWithContextMutex.Lock()
	defer fake.deleteCustomKeyStoreWithContextMutex.Unlock()
	fake.DeleteCustomKeyStoreWithContextStub = stub
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreWithContextArgsForCall(i int) (context.Context, *kms.DeleteCustomKeyStoreInput, []request.Option) {
	fake.deleteCustomKeyStoreWithContextMutex.RLock()
	defer fake.deleteCustomKeyStoreWithContextMutex.RUnlock()
	argsForCall := fake.deleteCustomKeyStoreWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreWithContextReturns(result1 *kms.DeleteCustomKeyStoreOutput, result2 error) {
	fake.deleteCustomKeyStoreWithContextMutex.Lock()
	defer fake.deleteCustomKeyStoreWithContextMutex.Unlock()
	fake.DeleteCustomKeyStoreWithContextStub = nil
	fake.deleteCustomKeyStoreWithContextReturns = struct {
		result1 *kms.DeleteCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteCustomKeyStoreWithContextReturnsOnCall(i int, result1 *kms.DeleteCustomKeyStoreOutput, result2 error) {
	fake.deleteCustomKeyStoreWithContextMutex.Lock()
	defer fake.deleteCustomKeyStoreWithContextMutex.Unlock()
	fake.DeleteCustomKeyStoreWithContextStub = nil
	if fake.deleteCustomKeyStoreWithContextReturnsOnCall == nil {
		fake.deleteCustomKeyStoreWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.DeleteCustomKeyStoreOutput
			result2 error
		})
	}
	fake.deleteCustomKeyStoreWithContextReturnsOnCall[i] = struct {
		result1 *kms.DeleteCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterial(arg1 *kms.DeleteImportedKeyMaterialInput) (*kms.DeleteImportedKeyMaterialOutput, error) {
	fake.deleteImportedKeyMaterialMutex.Lock()
	ret, specificReturn := fake.deleteImportedKeyMaterialReturnsOnCall[len(fake.deleteImportedKeyMaterialArgsForCall)]
	fake.deleteImportedKeyMaterialArgsForCall = append(fake.deleteImportedKeyMaterialArgsForCall, struct {
		arg1 *kms.DeleteImportedKeyMaterialInput
	}{arg1})
	stub := fake.DeleteImportedKeyMaterialStub
	fakeReturns := fake.deleteImportedKeyMaterialReturns
	fake.recordInvocation("DeleteImportedKeyMaterial", []interface{}{arg1})
	fake.deleteImportedKeyMaterialMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialCallCount() int {
	fake.deleteImportedKeyMaterialMutex.RLock()
	defer fake.deleteImportedKeyMaterialMutex.RUnlock()
	return len(fake.deleteImportedKeyMaterialArgsForCall)
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialCalls(stub func(*kms.DeleteImportedKeyMaterialInput) (*kms.DeleteImportedKeyMaterialOutput, error)) {
	fake.deleteImportedKeyMaterialMutex.Lock()
	defer fake.deleteImportedKeyMaterialMutex.Unlock()
	fake.DeleteImportedKeyMaterialStub = stub
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialArgsForCall(i int) *kms.DeleteImportedKeyMaterialInput {
	fake.deleteImportedKeyMaterialMutex.RLock()
	defer fake.deleteImportedKeyMaterialMutex.RUnlock()
	argsForCall := fake.deleteImportedKeyMaterialArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialReturns(result1 *kms.DeleteImportedKeyMaterialOutput, result2 error) {
	fake.deleteImportedKeyMaterialMutex.Lock()
	defer fake.deleteImportedKeyMaterialMutex.Unlock()
	fake.DeleteImportedKeyMaterialStub = nil
	fake.deleteImportedKeyMaterialReturns = struct {
		result1 *kms.DeleteImportedKeyMaterialOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialReturnsOnCall(i int, result1 *kms.DeleteImportedKeyMaterialOutput, result2 error) {
	fake.deleteImportedKeyMaterialMutex.Lock()
	defer fake.deleteImportedKeyMaterialMutex.Unlock()
	fake.DeleteImportedKeyMaterialStub = nil
	if fake.deleteImportedKeyMaterialReturnsOnCall == nil {
		fake.deleteImportedKeyMaterialReturnsOnCall = make(map[int]struct {
			result1 *kms.DeleteImportedKeyMaterialOutput
			result2 error
		})
	}
	fake.deleteImportedKeyMaterialReturnsOnCall[i] = struct {
		result1 *kms.DeleteImportedKeyMaterialOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialRequest(arg1 *kms.DeleteImportedKeyMaterialInput) (*request.Request, *kms.DeleteImportedKeyMaterialOutput) {
	fake.deleteImportedKeyMaterialRequestMutex.Lock()
	ret, specificReturn := fake.deleteImportedKeyMaterialRequestReturnsOnCall[len(fake.deleteImportedKeyMaterialRequestArgsForCall)]
	fake.deleteImportedKeyMaterialRequestArgsForCall = append(fake.deleteImportedKeyMaterialRequestArgsForCall, struct {
		arg1 *kms.DeleteImportedKeyMaterialInput
	}{arg1})
	stub := fake.DeleteImportedKeyMaterialRequestStub
	fakeReturns := fake.deleteImportedKeyMaterialRequestReturns
	fake.recordInvocation("DeleteImportedKeyMaterialRequest", []interface{}{arg1})
	fake.deleteImportedKeyMaterialRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialRequestCallCount() int {
	fake.deleteImportedKeyMaterialRequestMutex.RLock()
	defer fake.deleteImportedKeyMaterialRequestMutex.RUnlock()
	return len(fake.deleteImportedKeyMaterialRequestArgsForCall)
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialRequestCalls(stub func(*kms.DeleteImportedKeyMaterialInput) (*request.Request, *kms.DeleteImportedKeyMaterialOutput)) {
	fake.deleteImportedKeyMaterialRequestMutex.Lock()
	defer fake.deleteImportedKeyMaterialRequestMutex.Unlock()
	fake.DeleteImportedKeyMaterialRequestStub = stub
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialRequestArgsForCall(i int) *kms.DeleteImportedKeyMaterialInput {
	fake.deleteImportedKeyMaterialRequestMutex.RLock()
	defer fake.deleteImportedKeyMaterialRequestMutex.RUnlock()
	argsForCall := fake.deleteImportedKeyMaterialRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialRequestReturns(result1 *request.Request, result2 *kms.DeleteImportedKeyMaterialOutput) {
	fake.deleteImportedKeyMaterialRequestMutex.Lock()
	defer fake.deleteImportedKeyMaterialRequestMutex.Unlock()
	fake.DeleteImportedKeyMaterialRequestStub = nil
	fake.deleteImportedKeyMaterialRequestReturns = struct {
		result1 *request.Request
		result2 *kms.DeleteImportedKeyMaterialOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.DeleteImportedKeyMaterialOutput) {
	fake.deleteImportedKeyMaterialRequestMutex.Lock()
	defer fake.deleteImportedKeyMaterialRequestMutex.Unlock()
	fake.DeleteImportedKeyMaterialRequestStub = nil
	if fake.deleteImportedKeyMaterialRequestReturnsOnCall == nil {
		fake.deleteImportedKeyMaterialRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.DeleteImportedKeyMaterialOutput
		})
	}
	fake.deleteImportedKeyMaterialRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.DeleteImportedKeyMaterialOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialWithContext(arg1 context.Context, arg2 *kms.DeleteImportedKeyMaterialInput, arg3 ...request.Option) (*kms.DeleteImportedKeyMaterialOutput, error) {
	fake.deleteImportedKeyMaterialWithContextMutex.Lock()
	ret, specificReturn := fake.deleteImportedKeyMaterialWithContextReturnsOnCall[len(fake.deleteImportedKeyMaterialWithContextArgsForCall)]
	fake.deleteImportedKeyMaterialWithContextArgsForCall = append(fake.deleteImportedKeyMaterialWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.DeleteImportedKeyMaterialInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DeleteImportedKeyMaterialWithContextStub
	fakeReturns := fake.deleteImportedKeyMaterialWithContextReturns
	fake.recordInvocation("DeleteImportedKeyMaterialWithContext", []interface{}{arg1, arg2, arg3})
	fake.deleteImportedKeyMaterialWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialWithContextCallCount() int {
	fake.deleteImportedKeyMaterialWithContextMutex.RLock()
	defer fake.deleteImportedKeyMaterialWithContextMutex.RUnlock()
	return len(fake.deleteImportedKeyMaterialWithContextArgsForCall)
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialWithContextCalls(stub func(context.Context, *kms.DeleteImportedKeyMaterialInput, ...request.Option) (*kms.DeleteImportedKeyMaterialOutput, error)) {
	fake.deleteImportedKeyMaterialWithContextMutex.Lock()
	defer fake.deleteImportedKeyMaterialWithContextMutex.Unlock()
	fake.DeleteImportedKeyMaterialWithContextStub = stub
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialWithContextArgsForCall(i int) (context.Context, *kms.DeleteImportedKeyMaterialInput, []request.Option) {
	fake.deleteImportedKeyMaterialWithContextMutex.RLock()
	defer fake.deleteImportedKeyMaterialWithContextMutex.RUnlock()
	argsForCall := fake.deleteImportedKeyMaterialWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialWithContextReturns(result1 *kms.DeleteImportedKeyMaterialOutput, result2 error) {
	fake.deleteImportedKeyMaterialWithContextMutex.Lock()
	defer fake.deleteImportedKeyMaterialWithContextMutex.Unlock()
	fake.DeleteImportedKeyMaterialWithContextStub = nil
	fake.deleteImportedKeyMaterialWithContextReturns = struct {
		result1 *kms.DeleteImportedKeyMaterialOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DeleteImportedKeyMaterialWithContextReturnsOnCall(i int, result1 *kms.DeleteImportedKeyMaterialOutput, result2 error) {
	fake.deleteImportedKeyMaterialWithContextMutex.Lock()
	defer fake.deleteImportedKeyMaterialWithContextMutex.Unlock()
	fake.DeleteImportedKeyMaterialWithContextStub = nil
	if fake.deleteImportedKeyMaterialWithContextReturnsOnCall == nil {
		fake.deleteImportedKeyMaterialWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.DeleteImportedKeyMaterialOutput
			result2 error
		})
	}
	fake.deleteImportedKeyMaterialWithContextReturnsOnCall[i] = struct {
		result1 *kms.DeleteImportedKeyMaterialOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeCustomKeyStores(arg1 *kms.DescribeCustomKeyStoresInput) (*kms.DescribeCustomKeyStoresOutput, error) {
	fake.describeCustomKeyStoresMutex.Lock()
	ret, specificReturn := fake.describeCustomKeyStoresReturnsOnCall[len(fake.describeCustomKeyStoresArgsForCall)]
	fake.describeCustomKeyStoresArgsForCall = append(fake.describeCustomKeyStoresArgsForCall, struct {
		arg1 *kms.DescribeCustomKeyStoresInput
	}{arg1})
	stub := fake.DescribeCustomKeyStoresStub
	fakeReturns := fake.describeCustomKeyStoresReturns
	fake.recordInvocation("DescribeCustomKeyStores", []interface{}{arg1})
	fake.describeCustomKeyStoresMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresCallCount() int {
	fake.describeCustomKeyStoresMutex.RLock()
	defer fake.describeCustomKeyStoresMutex.RUnlock()
	return len(fake.describeCustomKeyStoresArgsForCall)
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresCalls(stub func(*kms.DescribeCustomKeyStoresInput) (*kms.DescribeCustomKeyStoresOutput, error)) {
	fake.describeCustomKeyStoresMutex.Lock()
	defer fake.describeCustomKeyStoresMutex.Unlock()
	fake.DescribeCustomKeyStoresStub = stub
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresArgsForCall(i int) *kms.DescribeCustomKeyStoresInput {
	fake.describeCustomKeyStoresMutex.RLock()
	defer fake.describeCustomKeyStoresMutex.RUnlock()
	argsForCall := fake.describeCustomKeyStoresArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresReturns(result1 *kms.DescribeCustomKeyStoresOutput, result2 error) {
	fake.describeCustomKeyStoresMutex.Lock()
	defer fake.describeCustomKeyStoresMutex.Unlock()
	fake.DescribeCustomKeyStoresStub = nil
	fake.describeCustomKeyStoresReturns = struct {
		result1 *kms.DescribeCustomKeyStoresOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresReturnsOnCall(i int, result1 *kms.DescribeCustomKeyStoresOutput, result2 error) {
	fake.describeCustomKeyStoresMutex.Lock()
	defer fake.describeCustomKeyStoresMutex.Unlock()
	fake.DescribeCustomKeyStoresStub = nil
	if fake.describeCustomKeyStoresReturnsOnCall == nil {
		fake.describeCustomKeyStoresReturnsOnCall = make(map[int]struct {
			result1 *kms.DescribeCustomKeyStoresOutput
			result2 error
		})
	}
	fake.describeCustomKeyStoresReturnsOnCall[i] = struct {
		result1 *kms.DescribeCustomKeyStoresOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresRequest(arg1 *kms.DescribeCustomKeyStoresInput) (*request.Request, *kms.DescribeCustomKeyStoresOutput) {
	fake.describeCustomKeyStoresRequestMutex.Lock()
	ret, specificReturn := fake.describeCustomKeyStoresRequestReturnsOnCall[len(fake.describeCustomKeyStoresRequestArgsForCall)]
	fake.describeCustomKeyStoresRequestArgsForCall = append(fake.describeCustomKeyStoresRequestArgsForCall, struct {
		arg1 *kms.DescribeCustomKeyStoresInput
	}{arg1})
	stub := fake.DescribeCustomKeyStoresRequestStub
	fakeReturns := fake.describeCustomKeyStoresRequestReturns
	fake.recordInvocation("DescribeCustomKeyStoresRequest", []interface{}{arg1})
	fake.describeCustomKeyStoresRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresRequestCallCount() int {
	fake.describeCustomKeyStoresRequestMutex.RLock()
	defer fake.describeCustomKeyStoresRequestMutex.RUnlock()
	return len(fake.describeCustomKeyStoresRequestArgsForCall)
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresRequestCalls(stub func(*kms.DescribeCustomKeyStoresInput) (*request.Request, *kms.DescribeCustomKeyStoresOutput)) {
	fake.describeCustomKeyStoresRequestMutex.Lock()
	defer fake.describeCustomKeyStoresRequestMutex.Unlock()
	fake.DescribeCustomKeyStoresRequestStub = stub
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresRequestArgsForCall(i int) *kms.DescribeCustomKeyStoresInput {
	fake.describeCustomKeyStoresRequestMutex.RLock()
	defer fake.describeCustomKeyStoresRequestMutex.RUnlock()
	argsForCall := fake.describeCustomKeyStoresRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresRequestReturns(result1 *request.Request, result2 *kms.DescribeCustomKeyStoresOutput) {
	fake.describeCustomKeyStoresRequestMutex.Lock()
	defer fake.describeCustomKeyStoresRequestMutex.Unlock()
	fake.DescribeCustomKeyStoresRequestStub = nil
	fake.describeCustomKeyStoresRequestReturns = struct {
		result1 *request.Request
		result2 *kms.DescribeCustomKeyStoresOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.DescribeCustomKeyStoresOutput) {
	fake.describeCustomKeyStoresRequestMutex.Lock()
	defer fake.describeCustomKeyStoresRequestMutex.Unlock()
	fake.DescribeCustomKeyStoresRequestStub = nil
	if fake.describeCustomKeyStoresRequestReturnsOnCall == nil {
		fake.describeCustomKeyStoresRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.DescribeCustomKeyStoresOutput
		})
	}
	fake.describeCustomKeyStoresRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.DescribeCustomKeyStoresOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresWithContext(arg1 context.Context, arg2 *kms.DescribeCustomKeyStoresInput, arg3 ...request.Option) (*kms.DescribeCustomKeyStoresOutput, error) {
	fake.describeCustomKeyStoresWithContextMutex.Lock()
	ret, specificReturn := fake.describeCustomKeyStoresWithContextReturnsOnCall[len(fake.describeCustomKeyStoresWithContextArgsForCall)]
	fake.describeCustomKeyStoresWithContextArgsForCall = append(fake.describeCustomKeyStoresWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.DescribeCustomKeyStoresInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DescribeCustomKeyStoresWithContextStub
	fakeReturns := fake.describeCustomKeyStoresWithContextReturns
	fake.recordInvocation("DescribeCustomKeyStoresWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeCustomKeyStoresWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresWithContextCallCount() int {
	fake.describeCustomKeyStoresWithContextMutex.RLock()
	defer fake.describeCustomKeyStoresWithContextMutex.RUnlock()
	return len(fake.describeCustomKeyStoresWithContextArgsForCall)
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresWithContextCalls(stub func(context.Context, *kms.DescribeCustomKeyStoresInput, ...request.Option) (*kms.DescribeCustomKeyStoresOutput, error)) {
	fake.describeCustomKeyStoresWithContextMutex.Lock()
	defer fake.describeCustomKeyStoresWithContextMutex.Unlock()
	fake.DescribeCustomKeyStoresWithContextStub = stub
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresWithContextArgsForCall(i int) (context.Context, *kms.DescribeCustomKeyStoresInput, []request.Option) {
	fake.describeCustomKeyStoresWithContextMutex.RLock()
	defer fake.describeCustomKeyStoresWithContextMutex.RUnlock()
	argsForCall := fake.describeCustomKeyStoresWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresWithContextReturns(result1 *kms.DescribeCustomKeyStoresOutput, result2 error) {
	fake.describeCustomKeyStoresWithContextMutex.Lock()
	defer fake.describeCustomKeyStoresWithContextMutex.Unlock()
	fake.DescribeCustomKeyStoresWithContextStub = nil
	fake.describeCustomKeyStoresWithContextReturns = struct {
		result1 *kms.DescribeCustomKeyStoresOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeCustomKeyStoresWithContextReturnsOnCall(i int, result1 *kms.DescribeCustomKeyStoresOutput, result2 error) {
	fake.describeCustomKeyStoresWithContextMutex.Lock()
	defer fake.describeCustomKeyStoresWithContextMutex.Unlock()
	fake.DescribeCustomKeyStoresWithContextStub = nil
	if fake.describeCustomKeyStoresWithContextReturnsOnCall == nil {
		fake.describeCustomKeyStoresWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.DescribeCustomKeyStoresOutput
			result2 error
		})
	}
	fake.describeCustomKeyStoresWithContextReturnsOnCall[i] = struct {
		result1 *kms.DescribeCustomKeyStoresOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeKey(arg1 *kms.DescribeKeyInput) (*kms.DescribeKeyOutput, error) {
	fake.describeKeyMutex.Lock()
	ret, specificReturn := fake.describeKeyReturnsOnCall[len(fake.describeKeyArgsForCall)]
	fake.describeKeyArgsForCall = append(fake.describeKeyArgsForCall, struct {
		arg1 *kms.DescribeKeyInput
	}{arg1})
	stub := fake.DescribeKeyStub
	fakeReturns := fake.describeKeyReturns
	fake.recordInvocation("DescribeKey", []interface{}{arg1})
	fake.describeKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DescribeKeyCallCount() int {
	fake.describeKeyMutex.RLock()
	defer fake.describeKeyMutex.RUnlock()
	return len(fake.describeKeyArgsForCall)
}

func (fake *FakeKMSClient) DescribeKeyCalls(stub func(*kms.DescribeKeyInput) (*kms.DescribeKeyOutput, error)) {
	fake.describeKeyMutex.Lock()
	defer fake.describeKeyMutex.Unlock()
	fake.DescribeKeyStub = stub
}

func (fake *FakeKMSClient) DescribeKeyArgsForCall(i int) *kms.DescribeKeyInput {
	fake.describeKeyMutex.RLock()
	defer fake.describeKeyMutex.RUnlock()
	argsForCall := fake.describeKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DescribeKeyReturns(result1 *kms.DescribeKeyOutput, result2 error) {
	fake.describeKeyMutex.Lock()
	defer fake.describeKeyMutex.Unlock()
	fake.DescribeKeyStub = nil
	fake.describeKeyReturns = struct {
		result1 *kms.DescribeKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeKeyReturnsOnCall(i int, result1 *kms.DescribeKeyOutput, result2 error) {
	fake.describeKeyMutex.Lock()
	defer fake.describeKeyMutex.Unlock()
	fake.DescribeKeyStub = nil
	if fake.describeKeyReturnsOnCall == nil {
		fake.describeKeyReturnsOnCall = make(map[int]struct {
			result1 *kms.DescribeKeyOutput
			result2 error
		})
	}
	fake.describeKeyReturnsOnCall[i] = struct {
		result1 *kms.DescribeKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeKeyRequest(arg1 *kms.DescribeKeyInput) (*request.Request, *kms.DescribeKeyOutput) {
	fake.describeKeyRequestMutex.Lock()
	ret, specificReturn := fake.describeKeyRequestReturnsOnCall[len(fake.describeKeyRequestArgsForCall)]
	fake.describeKeyRequestArgsForCall = append(fake.describeKeyRequestArgsForCall, struct {
		arg1 *kms.DescribeKeyInput
	}{arg1})
	stub := fake.DescribeKeyRequestStub
	fakeReturns := fake.describeKeyRequestReturns
	fake.recordInvocation("DescribeKeyRequest", []interface{}{arg1})
	fake.describeKeyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DescribeKeyRequestCallCount() int {
	fake.describeKeyRequestMutex.RLock()
	defer fake.describeKeyRequestMutex.RUnlock()
	return len(fake.describeKeyRequestArgsForCall)
}

func (fake *FakeKMSClient) DescribeKeyRequestCalls(stub func(*kms.DescribeKeyInput) (*request.Request, *kms.DescribeKeyOutput)) {
	fake.describeKeyRequestMutex.Lock()
	defer fake.describeKeyRequestMutex.Unlock()
	fake.DescribeKeyRequestStub = stub
}

func (fake *FakeKMSClient) DescribeKeyRequestArgsForCall(i int) *kms.DescribeKeyInput {
	fake.describeKeyRequestMutex.RLock()
	defer fake.describeKeyRequestMutex.RUnlock()
	argsForCall := fake.describeKeyRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DescribeKeyRequestReturns(result1 *request.Request, result2 *kms.DescribeKeyOutput) {
	fake.describeKeyRequestMutex.Lock()
	defer fake.describeKeyRequestMutex.Unlock()
	fake.DescribeKeyRequestStub = nil
	fake.describeKeyRequestReturns = struct {
		result1 *request.Request
		result2 *kms.DescribeKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeKeyRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.DescribeKeyOutput) {
	fake.describeKeyRequestMutex.Lock()
	defer fake.describeKeyRequestMutex.Unlock()
	fake.DescribeKeyRequestStub = nil
	if fake.describeKeyRequestReturnsOnCall == nil {
		fake.describeKeyRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.DescribeKeyOutput
		})
	}
	fake.describeKeyRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.DescribeKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeKeyWithContext(arg1 context.Context, arg2 *kms.DescribeKeyInput, arg3 ...request.Option) (*kms.DescribeKeyOutput, error) {
	fake.describeKeyWithContextMutex.Lock()
	ret, specificReturn := fake.describeKeyWithContextReturnsOnCall[len(fake.describeKeyWithContextArgsForCall)]
	fake.describeKeyWithContextArgsForCall = append(fake.describeKeyWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.DescribeKeyInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DescribeKeyWithContextStub
	fakeReturns := fake.describeKeyWithContextReturns
	fake.recordInvocation("DescribeKeyWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeKeyWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DescribeKeyWithContextCallCount() int {
	fake.describeKeyWithContextMutex.RLock()
	defer fake.describeKeyWithContextMutex.RUnlock()
	return len(fake.describeKeyWithContextArgsForCall)
}

func (fake *FakeKMSClient) DescribeKeyWithContextCalls(stub func(context.Context, *kms.DescribeKeyInput, ...request.Option) (*kms.DescribeKeyOutput, error)) {
	fake.describeKeyWithContextMutex.Lock()
	defer fake.describeKeyWithContextMutex.Unlock()
	fake.DescribeKeyWithContextStub = stub
}

func (fake *FakeKMSClient) DescribeKeyWithContextArgsForCall(i int) (context.Context, *kms.DescribeKeyInput, []request.Option) {
	fake.describeKeyWithContextMutex.RLock()
	defer fake.describeKeyWithContextMutex.RUnlock()
	argsForCall := fake.describeKeyWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) DescribeKeyWithContextReturns(result1 *kms.DescribeKeyOutput, result2 error) {
	fake.describeKeyWithContextMutex.Lock()
	defer fake.describeKeyWithContextMutex.Unlock()
	fake.DescribeKeyWithContextStub = nil
	fake.describeKeyWithContextReturns = struct {
		result1 *kms.DescribeKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DescribeKeyWithContextReturnsOnCall(i int, result1 *kms.DescribeKeyOutput, result2 error) {
	fake.describeKeyWithContextMutex.Lock()
	defer fake.describeKeyWithContextMutex.Unlock()
	fake.DescribeKeyWithContextStub = nil
	if fake.describeKeyWithContextReturnsOnCall == nil {
		fake.describeKeyWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.DescribeKeyOutput
			result2 error
		})
	}
	fake.describeKeyWithContextReturnsOnCall[i] = struct {
		result1 *kms.DescribeKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKey(arg1 *kms.DisableKeyInput) (*kms.DisableKeyOutput, error) {
	fake.disableKeyMutex.Lock()
	ret, specificReturn := fake.disableKeyReturnsOnCall[len(fake.disableKeyArgsForCall)]
	fake.disableKeyArgsForCall = append(fake.disableKeyArgsForCall, struct {
		arg1 *kms.DisableKeyInput
	}{arg1})
	stub := fake.DisableKeyStub
	fakeReturns := fake.disableKeyReturns
	fake.recordInvocation("DisableKey", []interface{}{arg1})
	fake.disableKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DisableKeyCallCount() int {
	fake.disableKeyMutex.RLock()
	defer fake.disableKeyMutex.RUnlock()
	return len(fake.disableKeyArgsForCall)
}

func (fake *FakeKMSClient) DisableKeyCalls(stub func(*kms.DisableKeyInput) (*kms.DisableKeyOutput, error)) {
	fake.disableKeyMutex.Lock()
	defer fake.disableKeyMutex.Unlock()
	fake.DisableKeyStub = stub
}

func (fake *FakeKMSClient) DisableKeyArgsForCall(i int) *kms.DisableKeyInput {
	fake.disableKeyMutex.RLock()
	defer fake.disableKeyMutex.RUnlock()
	argsForCall := fake.disableKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DisableKeyReturns(result1 *kms.DisableKeyOutput, result2 error) {
	fake.disableKeyMutex.Lock()
	defer fake.disableKeyMutex.Unlock()
	fake.DisableKeyStub = nil
	fake.disableKeyReturns = struct {
		result1 *kms.DisableKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyReturnsOnCall(i int, result1 *kms.DisableKeyOutput, result2 error) {
	fake.disableKeyMutex.Lock()
	defer fake.disableKeyMutex.Unlock()
	fake.DisableKeyStub = nil
	if fake.disableKeyReturnsOnCall == nil {
		fake.disableKeyReturnsOnCall = make(map[int]struct {
			result1 *kms.DisableKeyOutput
			result2 error
		})
	}
	fake.disableKeyReturnsOnCall[i] = struct {
		result1 *kms.DisableKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyRequest(arg1 *kms.DisableKeyInput) (*request.Request, *kms.DisableKeyOutput) {
	fake.disableKeyRequestMutex.Lock()
	ret, specificReturn := fake.disableKeyRequestReturnsOnCall[len(fake.disableKeyRequestArgsForCall)]
	fake.disableKeyRequestArgsForCall = append(fake.disableKeyRequestArgsForCall, struct {
		arg1 *kms.DisableKeyInput
	}{arg1})
	stub := fake.DisableKeyRequestStub
	fakeReturns := fake.disableKeyRequestReturns
	fake.recordInvocation("DisableKeyRequest", []interface{}{arg1})
	fake.disableKeyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DisableKeyRequestCallCount() int {
	fake.disableKeyRequestMutex.RLock()
	defer fake.disableKeyRequestMutex.RUnlock()
	return len(fake.disableKeyRequestArgsForCall)
}

func (fake *FakeKMSClient) DisableKeyRequestCalls(stub func(*kms.DisableKeyInput) (*request.Request, *kms.DisableKeyOutput)) {
	fake.disableKeyRequestMutex.Lock()
	defer fake.disableKeyRequestMutex.Unlock()
	fake.DisableKeyRequestStub = stub
}

func (fake *FakeKMSClient) DisableKeyRequestArgsForCall(i int) *kms.DisableKeyInput {
	fake.disableKeyRequestMutex.RLock()
	defer fake.disableKeyRequestMutex.RUnlock()
	argsForCall := fake.disableKeyRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DisableKeyRequestReturns(result1 *request.Request, result2 *kms.DisableKeyOutput) {
	fake.disableKeyRequestMutex.Lock()
	defer fake.disableKeyRequestMutex.Unlock()
	fake.DisableKeyRequestStub = nil
	fake.disableKeyRequestReturns = struct {
		result1 *request.Request
		result2 *kms.DisableKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.DisableKeyOutput) {
	fake.disableKeyRequestMutex.Lock()
	defer fake.disableKeyRequestMutex.Unlock()
	fake.DisableKeyRequestStub = nil
	if fake.disableKeyRequestReturnsOnCall == nil {
		fake.disableKeyRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.DisableKeyOutput
		})
	}
	fake.disableKeyRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.DisableKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyRotation(arg1 *kms.DisableKeyRotationInput) (*kms.DisableKeyRotationOutput, error) {
	fake.disableKeyRotationMutex.Lock()
	ret, specificReturn := fake.disableKeyRotationReturnsOnCall[len(fake.disableKeyRotationArgsForCall)]
	fake.disableKeyRotationArgsForCall = append(fake.disableKeyRotationArgsForCall, struct {
		arg1 *kms.DisableKeyRotationInput
	}{arg1})
	stub := fake.DisableKeyRotationStub
	fakeReturns := fake.disableKeyRotationReturns
	fake.recordInvocation("DisableKeyRotation", []interface{}{arg1})
	fake.disableKeyRotationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DisableKeyRotationCallCount() int {
	fake.disableKeyRotationMutex.RLock()
	defer fake.disableKeyRotationMutex.RUnlock()
	return len(fake.disableKeyRotationArgsForCall)
}

func (fake *FakeKMSClient) DisableKeyRotationCalls(stub func(*kms.DisableKeyRotationInput) (*kms.DisableKeyRotationOutput, error)) {
	fake.disableKeyRotationMutex.Lock()
	defer fake.disableKeyRotationMutex.Unlock()
	fake.DisableKeyRotationStub = stub
}

func (fake *FakeKMSClient) DisableKeyRotationArgsForCall(i int) *kms.DisableKeyRotationInput {
	fake.disableKeyRotationMutex.RLock()
	defer fake.disableKeyRotationMutex.RUnlock()
	argsForCall := fake.disableKeyRotationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DisableKeyRotationReturns(result1 *kms.DisableKeyRotationOutput, result2 error) {
	fake.disableKeyRotationMutex.Lock()
	defer fake.disableKeyRotationMutex.Unlock()
	fake.DisableKeyRotationStub = nil
	fake.disableKeyRotationReturns = struct {
		result1 *kms.DisableKeyRotationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyRotationReturnsOnCall(i int, result1 *kms.DisableKeyRotationOutput, result2 error) {
	fake.disableKeyRotationMutex.Lock()
	defer fake.disableKeyRotationMutex.Unlock()
	fake.DisableKeyRotationStub = nil
	if fake.disableKeyRotationReturnsOnCall == nil {
		fake.disableKeyRotationReturnsOnCall = make(map[int]struct {
			result1 *kms.DisableKeyRotationOutput
			result2 error
		})
	}
	fake.disableKeyRotationReturnsOnCall[i] = struct {
		result1 *kms.DisableKeyRotationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyRotationRequest(arg1 *kms.DisableKeyRotationInput) (*request.Request, *kms.DisableKeyRotationOutput) {
	fake.disableKeyRotationRequestMutex.Lock()
	ret, specificReturn := fake.disableKeyRotationRequestReturnsOnCall[len(fake.disableKeyRotationRequestArgsForCall)]
	fake.disableKeyRotationRequestArgsForCall = append(fake.disableKeyRotationRequestArgsForCall, struct {
		arg1 *kms.DisableKeyRotationInput
	}{arg1})
	stub := fake.DisableKeyRotationRequestStub
	fakeReturns := fake.disableKeyRotationRequestReturns
	fake.recordInvocation("DisableKeyRotationRequest", []interface{}{arg1})
	fake.disableKeyRotationRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DisableKeyRotationRequestCallCount() int {
	fake.disableKeyRotationRequestMutex.RLock()
	defer fake.disableKeyRotationRequestMutex.RUnlock()
	return len(fake.disableKeyRotationRequestArgsForCall)
}

func (fake *FakeKMSClient) DisableKeyRotationRequestCalls(stub func(*kms.DisableKeyRotationInput) (*request.Request, *kms.DisableKeyRotationOutput)) {
	fake.disableKeyRotationRequestMutex.Lock()
	defer fake.disableKeyRotationRequestMutex.Unlock()
	fake.DisableKeyRotationRequestStub = stub
}

func (fake *FakeKMSClient) DisableKeyRotationRequestArgsForCall(i int) *kms.DisableKeyRotationInput {
	fake.disableKeyRotationRequestMutex.RLock()
	defer fake.disableKeyRotationRequestMutex.RUnlock()
	argsForCall := fake.disableKeyRotationRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DisableKeyRotationRequestReturns(result1 *request.Request, result2 *kms.DisableKeyRotationOutput) {
	fake.disableKeyRotationRequestMutex.Lock()
	defer fake.disableKeyRotationRequestMutex.Unlock()
	fake.DisableKeyRotationRequestStub = nil
	fake.disableKeyRotationRequestReturns = struct {
		result1 *request.Request
		result2 *kms.DisableKeyRotationOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyRotationRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.DisableKeyRotationOutput) {
	fake.disableKeyRotationRequestMutex.Lock()
	defer fake.disableKeyRotationRequestMutex.Unlock()
	fake.DisableKeyRotationRequestStub = nil
	if fake.disableKeyRotationRequestReturnsOnCall == nil {
		fake.disableKeyRotationRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.DisableKeyRotationOutput
		})
	}
	fake.disableKeyRotationRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.DisableKeyRotationOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyRotationWithContext(arg1 context.Context, arg2 *kms.DisableKeyRotationInput, arg3 ...request.Option) (*kms.DisableKeyRotationOutput, error) {
	fake.disableKeyRotationWithContextMutex.Lock()
	ret, specificReturn := fake.disableKeyRotationWithContextReturnsOnCall[len(fake.disableKeyRotationWithContextArgsForCall)]
	fake.disableKeyRotationWithContextArgsForCall = append(fake.disableKeyRotationWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.DisableKeyRotationInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DisableKeyRotationWithContextStub
	fakeReturns := fake.disableKeyRotationWithContextReturns
	fake.recordInvocation("DisableKeyRotationWithContext", []interface{}{arg1, arg2, arg3})
	fake.disableKeyRotationWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DisableKeyRotationWithContextCallCount() int {
	fake.disableKeyRotationWithContextMutex.RLock()
	defer fake.disableKeyRotationWithContextMutex.RUnlock()
	return len(fake.disableKeyRotationWithContextArgsForCall)
}

func (fake *FakeKMSClient) DisableKeyRotationWithContextCalls(stub func(context.Context, *kms.DisableKeyRotationInput, ...request.Option) (*kms.DisableKeyRotationOutput, error)) {
	fake.disableKeyRotationWithContextMutex.Lock()
	defer fake.disableKeyRotationWithContextMutex.Unlock()
	fake.DisableKeyRotationWithContextStub = stub
}

func (fake *FakeKMSClient) DisableKeyRotationWithContextArgsForCall(i int) (context.Context, *kms.DisableKeyRotationInput, []request.Option) {
	fake.disableKeyRotationWithContextMutex.RLock()
	defer fake.disableKeyRotationWithContextMutex.RUnlock()
	argsForCall := fake.disableKeyRotationWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) DisableKeyRotationWithContextReturns(result1 *kms.DisableKeyRotationOutput, result2 error) {
	fake.disableKeyRotationWithContextMutex.Lock()
	defer fake.disableKeyRotationWithContextMutex.Unlock()
	fake.DisableKeyRotationWithContextStub = nil
	fake.disableKeyRotationWithContextReturns = struct {
		result1 *kms.DisableKeyRotationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyRotationWithContextReturnsOnCall(i int, result1 *kms.DisableKeyRotationOutput, result2 error) {
	fake.disableKeyRotationWithContextMutex.Lock()
	defer fake.disableKeyRotationWithContextMutex.Unlock()
	fake.DisableKeyRotationWithContextStub = nil
	if fake.disableKeyRotationWithContextReturnsOnCall == nil {
		fake.disableKeyRotationWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.DisableKeyRotationOutput
			result2 error
		})
	}
	fake.disableKeyRotationWithContextReturnsOnCall[i] = struct {
		result1 *kms.DisableKeyRotationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyWithContext(arg1 context.Context, arg2 *kms.DisableKeyInput, arg3 ...request.Option) (*kms.DisableKeyOutput, error) {
	fake.disableKeyWithContextMutex.Lock()
	ret, specificReturn := fake.disableKeyWithContextReturnsOnCall[len(fake.disableKeyWithContextArgsForCall)]
	fake.disableKeyWithContextArgsForCall = append(fake.disableKeyWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.DisableKeyInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DisableKeyWithContextStub
	fakeReturns := fake.disableKeyWithContextReturns
	fake.recordInvocation("DisableKeyWithContext", []interface{}{arg1, arg2, arg3})
	fake.disableKeyWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DisableKeyWithContextCallCount() int {
	fake.disableKeyWithContextMutex.RLock()
	defer fake.disableKeyWithContextMutex.RUnlock()
	return len(fake.disableKeyWithContextArgsForCall)
}

func (fake *FakeKMSClient) DisableKeyWithContextCalls(stub func(context.Context, *kms.DisableKeyInput, ...request.Option) (*kms.DisableKeyOutput, error)) {
	fake.disableKeyWithContextMutex.Lock()
	defer fake.disableKeyWithContextMutex.Unlock()
	fake.DisableKeyWithContextStub = stub
}

func (fake *FakeKMSClient) DisableKeyWithContextArgsForCall(i int) (context.Context, *kms.DisableKeyInput, []request.Option) {
	fake.disableKeyWithContextMutex.RLock()
	defer fake.disableKeyWithContextMutex.RUnlock()
	argsForCall := fake.disableKeyWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) DisableKeyWithContextReturns(result1 *kms.DisableKeyOutput, result2 error) {
	fake.disableKeyWithContextMutex.Lock()
	defer fake.disableKeyWithContextMutex.Unlock()
	fake.DisableKeyWithContextStub = nil
	fake.disableKeyWithContextReturns = struct {
		result1 *kms.DisableKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisableKeyWithContextReturnsOnCall(i int, result1 *kms.DisableKeyOutput, result2 error) {
	fake.disableKeyWithContextMutex.Lock()
	defer fake.disableKeyWithContextMutex.Unlock()
	fake.DisableKeyWithContextStub = nil
	if fake.disableKeyWithContextReturnsOnCall == nil {
		fake.disableKeyWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.DisableKeyOutput
			result2 error
		})
	}
	fake.disableKeyWithContextReturnsOnCall[i] = struct {
		result1 *kms.DisableKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisconnectCustomKeyStore(arg1 *kms.DisconnectCustomKeyStoreInput) (*kms.DisconnectCustomKeyStoreOutput, error) {
	fake.disconnectCustomKeyStoreMutex.Lock()
	ret, specificReturn := fake.disconnectCustomKeyStoreReturnsOnCall[len(fake.disconnectCustomKeyStoreArgsForCall)]
	fake.disconnectCustomKeyStoreArgsForCall = append(fake.disconnectCustomKeyStoreArgsForCall, struct {
		arg1 *kms.DisconnectCustomKeyStoreInput
	}{arg1})
	stub := fake.DisconnectCustomKeyStoreStub
	fakeReturns := fake.disconnectCustomKeyStoreReturns
	fake.recordInvocation("DisconnectCustomKeyStore", []interface{}{arg1})
	fake.disconnectCustomKeyStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreCallCount() int {
	fake.disconnectCustomKeyStoreMutex.RLock()
	defer fake.disconnectCustomKeyStoreMutex.RUnlock()
	return len(fake.disconnectCustomKeyStoreArgsForCall)
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreCalls(stub func(*kms.DisconnectCustomKeyStoreInput) (*kms.DisconnectCustomKeyStoreOutput, error)) {
	fake.disconnectCustomKeyStoreMutex.Lock()
	defer fake.disconnectCustomKeyStoreMutex.Unlock()
	fake.DisconnectCustomKeyStoreStub = stub
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreArgsForCall(i int) *kms.DisconnectCustomKeyStoreInput {
	fake.disconnectCustomKeyStoreMutex.RLock()
	defer fake.disconnectCustomKeyStoreMutex.RUnlock()
	argsForCall := fake.disconnectCustomKeyStoreArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreReturns(result1 *kms.DisconnectCustomKeyStoreOutput, result2 error) {
	fake.disconnectCustomKeyStoreMutex.Lock()
	defer fake.disconnectCustomKeyStoreMutex.Unlock()
	fake.DisconnectCustomKeyStoreStub = nil
	fake.disconnectCustomKeyStoreReturns = struct {
		result1 *kms.DisconnectCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreReturnsOnCall(i int, result1 *kms.DisconnectCustomKeyStoreOutput, result2 error) {
	fake.disconnectCustomKeyStoreMutex.Lock()
	defer fake.disconnectCustomKeyStoreMutex.Unlock()
	fake.DisconnectCustomKeyStoreStub = nil
	if fake.disconnectCustomKeyStoreReturnsOnCall == nil {
		fake.disconnectCustomKeyStoreReturnsOnCall = make(map[int]struct {
			result1 *kms.DisconnectCustomKeyStoreOutput
			result2 error
		})
	}
	fake.disconnectCustomKeyStoreReturnsOnCall[i] = struct {
		result1 *kms.DisconnectCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreRequest(arg1 *kms.DisconnectCustomKeyStoreInput) (*request.Request, *kms.DisconnectCustomKeyStoreOutput) {
	fake.disconnectCustomKeyStoreRequestMutex.Lock()
	ret, specificReturn := fake.disconnectCustomKeyStoreRequestReturnsOnCall[len(fake.disconnectCustomKeyStoreRequestArgsForCall)]
	fake.disconnectCustomKeyStoreRequestArgsForCall = append(fake.disconnectCustomKeyStoreRequestArgsForCall, struct {
		arg1 *kms.DisconnectCustomKeyStoreInput
	}{arg1})
	stub := fake.DisconnectCustomKeyStoreRequestStub
	fakeReturns := fake.disconnectCustomKeyStoreRequestReturns
	fake.recordInvocation("DisconnectCustomKeyStoreRequest", []interface{}{arg1})
	fake.disconnectCustomKeyStoreRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreRequestCallCount() int {
	fake.disconnectCustomKeyStoreRequestMutex.RLock()
	defer fake.disconnectCustomKeyStoreRequestMutex.RUnlock()
	return len(fake.disconnectCustomKeyStoreRequestArgsForCall)
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreRequestCalls(stub func(*kms.DisconnectCustomKeyStoreInput) (*request.Request, *kms.DisconnectCustomKeyStoreOutput)) {
	fake.disconnectCustomKeyStoreRequestMutex.Lock()
	defer fake.disconnectCustomKeyStoreRequestMutex.Unlock()
	fake.DisconnectCustomKeyStoreRequestStub = stub
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreRequestArgsForCall(i int) *kms.DisconnectCustomKeyStoreInput {
	fake.disconnectCustomKeyStoreRequestMutex.RLock()
	defer fake.disconnectCustomKeyStoreRequestMutex.RUnlock()
	argsForCall := fake.disconnectCustomKeyStoreRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreRequestReturns(result1 *request.Request, result2 *kms.DisconnectCustomKeyStoreOutput) {
	fake.disconnectCustomKeyStoreRequestMutex.Lock()
	defer fake.disconnectCustomKeyStoreRequestMutex.Unlock()
	fake.DisconnectCustomKeyStoreRequestStub = nil
	fake.disconnectCustomKeyStoreRequestReturns = struct {
		result1 *request.Request
		result2 *kms.DisconnectCustomKeyStoreOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.DisconnectCustomKeyStoreOutput) {
	fake.disconnectCustomKeyStoreRequestMutex.Lock()
	defer fake.disconnectCustomKeyStoreRequestMutex.Unlock()
	fake.DisconnectCustomKeyStoreRequestStub = nil
	if fake.disconnectCustomKeyStoreRequestReturnsOnCall == nil {
		fake.disconnectCustomKeyStoreRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.DisconnectCustomKeyStoreOutput
		})
	}
	fake.disconnectCustomKeyStoreRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.DisconnectCustomKeyStoreOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreWithContext(arg1 context.Context, arg2 *kms.DisconnectCustomKeyStoreInput, arg3 ...request.Option) (*kms.DisconnectCustomKeyStoreOutput, error) {
	fake.disconnectCustomKeyStoreWithContextMutex.Lock()
	ret, specificReturn := fake.disconnectCustomKeyStoreWithContextReturnsOnCall[len(fake.disconnectCustomKeyStoreWithContextArgsForCall)]
	fake.disconnectCustomKeyStoreWithContextArgsForCall = append(fake.disconnectCustomKeyStoreWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.DisconnectCustomKeyStoreInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DisconnectCustomKeyStoreWithContextStub
	fakeReturns := fake.disconnectCustomKeyStoreWithContextReturns
	fake.recordInvocation("DisconnectCustomKeyStoreWithContext", []interface{}{arg1, arg2, arg3})
	fake.disconnectCustomKeyStoreWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreWithContextCallCount() int {
	fake.disconnectCustomKeyStoreWithContextMutex.RLock()
	defer fake.disconnectCustomKeyStoreWithContextMutex.RUnlock()
	return len(fake.disconnectCustomKeyStoreWithContextArgsForCall)
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreWithContextCalls(stub func(context.Context, *kms.DisconnectCustomKeyStoreInput, ...request.Option) (*kms.DisconnectCustomKeyStoreOutput, error)) {
	fake.disconnectCustomKeyStoreWithContextMutex.Lock()
	defer fake.disconnectCustomKeyStoreWithContextMutex.Unlock()
	fake.DisconnectCustomKeyStoreWithContextStub = stub
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreWithContextArgsForCall(i int) (context.Context, *kms.DisconnectCustomKeyStoreInput, []request.Option) {
	fake.disconnectCustomKeyStoreWithContextMutex.RLock()
	defer fake.disconnectCustomKeyStoreWithContextMutex.RUnlock()
	argsForCall := fake.disconnectCustomKeyStoreWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreWithContextReturns(result1 *kms.DisconnectCustomKeyStoreOutput, result2 error) {
	fake.disconnectCustomKeyStoreWithContextMutex.Lock()
	defer fake.disconnectCustomKeyStoreWithContextMutex.Unlock()
	fake.DisconnectCustomKeyStoreWithContextStub = nil
	fake.disconnectCustomKeyStoreWithContextReturns = struct {
		result1 *kms.DisconnectCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) DisconnectCustomKeyStoreWithContextReturnsOnCall(i int, result1 *kms.DisconnectCustomKeyStoreOutput, result2 error) {
	fake.disconnectCustomKeyStoreWithContextMutex.Lock()
	defer fake.disconnectCustomKeyStoreWithContextMutex.Unlock()
	fake.DisconnectCustomKeyStoreWithContextStub = nil
	if fake.disconnectCustomKeyStoreWithContextReturnsOnCall == nil {
		fake.disconnectCustomKeyStoreWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.DisconnectCustomKeyStoreOutput
			result2 error
		})
	}
	fake.disconnectCustomKeyStoreWithContextReturnsOnCall[i] = struct {
		result1 *kms.DisconnectCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKey(arg1 *kms.EnableKeyInput) (*kms.EnableKeyOutput, error) {
	fake.enableKeyMutex.Lock()
	ret, specificReturn := fake.enableKeyReturnsOnCall[len(fake.enableKeyArgsForCall)]
	fake.enableKeyArgsForCall = append(fake.enableKeyArgsForCall, struct {
		arg1 *kms.EnableKeyInput
	}{arg1})
	stub := fake.EnableKeyStub
	fakeReturns := fake.enableKeyReturns
	fake.recordInvocation("EnableKey", []interface{}{arg1})
	fake.enableKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) EnableKeyCallCount() int {
	fake.enableKeyMutex.RLock()
	defer fake.enableKeyMutex.RUnlock()
	return len(fake.enableKeyArgsForCall)
}

func (fake *FakeKMSClient) EnableKeyCalls(stub func(*kms.EnableKeyInput) (*kms.EnableKeyOutput, error)) {
	fake.enableKeyMutex.Lock()
	defer fake.enableKeyMutex.Unlock()
	fake.EnableKeyStub = stub
}

func (fake *FakeKMSClient) EnableKeyArgsForCall(i int) *kms.EnableKeyInput {
	fake.enableKeyMutex.RLock()
	defer fake.enableKeyMutex.RUnlock()
	argsForCall := fake.enableKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) EnableKeyReturns(result1 *kms.EnableKeyOutput, result2 error) {
	fake.enableKeyMutex.Lock()
	defer fake.enableKeyMutex.Unlock()
	fake.EnableKeyStub = nil
	fake.enableKeyReturns = struct {
		result1 *kms.EnableKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyReturnsOnCall(i int, result1 *kms.EnableKeyOutput, result2 error) {
	fake.enableKeyMutex.Lock()
	defer fake.enableKeyMutex.Unlock()
	fake.EnableKeyStub = nil
	if fake.enableKeyReturnsOnCall == nil {
		fake.enableKeyReturnsOnCall = make(map[int]struct {
			result1 *kms.EnableKeyOutput
			result2 error
		})
	}
	fake.enableKeyReturnsOnCall[i] = struct {
		result1 *kms.EnableKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyRequest(arg1 *kms.EnableKeyInput) (*request.Request, *kms.EnableKeyOutput) {
	fake.enableKeyRequestMutex.Lock()
	ret, specificReturn := fake.enableKeyRequestReturnsOnCall[len(fake.enableKeyRequestArgsForCall)]
	fake.enableKeyRequestArgsForCall = append(fake.enableKeyRequestArgsForCall, struct {
		arg1 *kms.EnableKeyInput
	}{arg1})
	stub := fake.EnableKeyRequestStub
	fakeReturns := fake.enableKeyRequestReturns
	fake.recordInvocation("EnableKeyRequest", []interface{}{arg1})
	fake.enableKeyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) EnableKeyRequestCallCount() int {
	fake.enableKeyRequestMutex.RLock()
	defer fake.enableKeyRequestMutex.RUnlock()
	return len(fake.enableKeyRequestArgsForCall)
}

func (fake *FakeKMSClient) EnableKeyRequestCalls(stub func(*kms.EnableKeyInput) (*request.Request, *kms.EnableKeyOutput)) {
	fake.enableKeyRequestMutex.Lock()
	defer fake.enableKeyRequestMutex.Unlock()
	fake.EnableKeyRequestStub = stub
}

func (fake *FakeKMSClient) EnableKeyRequestArgsForCall(i int) *kms.EnableKeyInput {
	fake.enableKeyRequestMutex.RLock()
	defer fake.enableKeyRequestMutex.RUnlock()
	argsForCall := fake.enableKeyRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) EnableKeyRequestReturns(result1 *request.Request, result2 *kms.EnableKeyOutput) {
	fake.enableKeyRequestMutex.Lock()
	defer fake.enableKeyRequestMutex.Unlock()
	fake.EnableKeyRequestStub = nil
	fake.enableKeyRequestReturns = struct {
		result1 *request.Request
		result2 *kms.EnableKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.EnableKeyOutput) {
	fake.enableKeyRequestMutex.Lock()
	defer fake.enableKeyRequestMutex.Unlock()
	fake.EnableKeyRequestStub = nil
	if fake.enableKeyRequestReturnsOnCall == nil {
		fake.enableKeyRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.EnableKeyOutput
		})
	}
	fake.enableKeyRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.EnableKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyRotation(arg1 *kms.EnableKeyRotationInput) (*kms.EnableKeyRotationOutput, error) {
	fake.enableKeyRotationMutex.Lock()
	ret, specificReturn := fake.enableKeyRotationReturnsOnCall[len(fake.enableKeyRotationArgsForCall)]
	fake.enableKeyRotationArgsForCall = append(fake.enableKeyRotationArgsForCall, struct {
		arg1 *kms.EnableKeyRotationInput
	}{arg1})
	stub := fake.EnableKeyRotationStub
	fakeReturns := fake.enableKeyRotationReturns
	fake.recordInvocation("EnableKeyRotation", []interface{}{arg1})
	fake.enableKeyRotationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) EnableKeyRotationCallCount() int {
	fake.enableKeyRotationMutex.RLock()
	defer fake.enableKeyRotationMutex.RUnlock()
	return len(fake.enableKeyRotationArgsForCall)
}

func (fake *FakeKMSClient) EnableKeyRotationCalls(stub func(*kms.EnableKeyRotationInput) (*kms.EnableKeyRotationOutput, error)) {
	fake.enableKeyRotationMutex.Lock()
	defer fake.enableKeyRotationMutex.Unlock()
	fake.EnableKeyRotationStub = stub
}

func (fake *FakeKMSClient) EnableKeyRotationArgsForCall(i int) *kms.EnableKeyRotationInput {
	fake.enableKeyRotationMutex.RLock()
	defer fake.enableKeyRotationMutex.RUnlock()
	argsForCall := fake.enableKeyRotationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) EnableKeyRotationReturns(result1 *kms.EnableKeyRotationOutput, result2 error) {
	fake.enableKeyRotationMutex.Lock()
	defer fake.enableKeyRotationMutex.Unlock()
	fake.EnableKeyRotationStub = nil
	fake.enableKeyRotationReturns = struct {
		result1 *kms.EnableKeyRotationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyRotationReturnsOnCall(i int, result1 *kms.EnableKeyRotationOutput, result2 error) {
	fake.enableKeyRotationMutex.Lock()
	defer fake.enableKeyRotationMutex.Unlock()
	fake.EnableKeyRotationStub = nil
	if fake.enableKeyRotationReturnsOnCall == nil {
		fake.enableKeyRotationReturnsOnCall = make(map[int]struct {
			result1 *kms.EnableKeyRotationOutput
			result2 error
		})
	}
	fake.enableKeyRotationReturnsOnCall[i] = struct {
		result1 *kms.EnableKeyRotationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyRotationRequest(arg1 *kms.EnableKeyRotationInput) (*request.Request, *kms.EnableKeyRotationOutput) {
	fake.enableKeyRotationRequestMutex.Lock()
	ret, specificReturn := fake.enableKeyRotationRequestReturnsOnCall[len(fake.enableKeyRotationRequestArgsForCall)]
	fake.enableKeyRotationRequestArgsForCall = append(fake.enableKeyRotationRequestArgsForCall, struct {
		arg1 *kms.EnableKeyRotationInput
	}{arg1})
	stub := fake.EnableKeyRotationRequestStub
	fakeReturns := fake.enableKeyRotationRequestReturns
	fake.recordInvocation("EnableKeyRotationRequest", []interface{}{arg1})
	fake.enableKeyRotationRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) EnableKeyRotationRequestCallCount() int {
	fake.enableKeyRotationRequestMutex.RLock()
	defer fake.enableKeyRotationRequestMutex.RUnlock()
	return len(fake.enableKeyRotationRequestArgsForCall)
}

func (fake *FakeKMSClient) EnableKeyRotationRequestCalls(stub func(*kms.EnableKeyRotationInput) (*request.Request, *kms.EnableKeyRotationOutput)) {
	fake.enableKeyRotationRequestMutex.Lock()
	defer fake.enableKeyRotationRequestMutex.Unlock()
	fake.EnableKeyRotationRequestStub = stub
}

func (fake *FakeKMSClient) EnableKeyRotationRequestArgsForCall(i int) *kms.EnableKeyRotationInput {
	fake.enableKeyRotationRequestMutex.RLock()
	defer fake.enableKeyRotationRequestMutex.RUnlock()
	argsForCall := fake.enableKeyRotationRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) EnableKeyRotationRequestReturns(result1 *request.Request, result2 *kms.EnableKeyRotationOutput) {
	fake.enableKeyRotationRequestMutex.Lock()
	defer fake.enableKeyRotationRequestMutex.Unlock()
	fake.EnableKeyRotationRequestStub = nil
	fake.enableKeyRotationRequestReturns = struct {
		result1 *request.Request
		result2 *kms.EnableKeyRotationOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyRotationRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.EnableKeyRotationOutput) {
	fake.enableKeyRotationRequestMutex.Lock()
	defer fake.enableKeyRotationRequestMutex.Unlock()
	fake.EnableKeyRotationRequestStub = nil
	if fake.enableKeyRotationRequestReturnsOnCall == nil {
		fake.enableKeyRotationRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.EnableKeyRotationOutput
		})
	}
	fake.enableKeyRotationRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.EnableKeyRotationOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyRotationWithContext(arg1 context.Context, arg2 *kms.EnableKeyRotationInput, arg3 ...request.Option) (*kms.EnableKeyRotationOutput, error) {
	fake.enableKeyRotationWithContextMutex.Lock()
	ret, specificReturn := fake.enableKeyRotationWithContextReturnsOnCall[len(fake.enableKeyRotationWithContextArgsForCall)]
	fake.enableKeyRotationWithContextArgsForCall = append(fake.enableKeyRotationWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.EnableKeyRotationInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.EnableKeyRotationWithContextStub
	fakeReturns := fake.enableKeyRotationWithContextReturns
	fake.recordInvocation("EnableKeyRotationWithContext", []interface{}{arg1, arg2, arg3})
	fake.enableKeyRotationWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) EnableKeyRotationWithContextCallCount() int {
	fake.enableKeyRotationWithContextMutex.RLock()
	defer fake.enableKeyRotationWithContextMutex.RUnlock()
	return len(fake.enableKeyRotationWithContextArgsForCall)
}

func (fake *FakeKMSClient) EnableKeyRotationWithContextCalls(stub func(context.Context, *kms.EnableKeyRotationInput, ...request.Option) (*kms.EnableKeyRotationOutput, error)) {
	fake.enableKeyRotationWithContextMutex.Lock()
	defer fake.enableKeyRotationWithContextMutex.Unlock()
	fake.EnableKeyRotationWithContextStub = stub
}

func (fake *FakeKMSClient) EnableKeyRotationWithContextArgsForCall(i int) (context.Context, *kms.EnableKeyRotationInput, []request.Option) {
	fake.enableKeyRotationWithContextMutex.RLock()
	defer fake.enableKeyRotationWithContextMutex.RUnlock()
	argsForCall := fake.enableKeyRotationWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) EnableKeyRotationWithContextReturns(result1 *kms.EnableKeyRotationOutput, result2 error) {
	fake.enableKeyRotationWithContextMutex.Lock()
	defer fake.enableKeyRotationWithContextMutex.Unlock()
	fake.EnableKeyRotationWithContextStub = nil
	fake.enableKeyRotationWithContextReturns = struct {
		result1 *kms.EnableKeyRotationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyRotationWithContextReturnsOnCall(i int, result1 *kms.EnableKeyRotationOutput, result2 error) {
	fake.enableKeyRotationWithContextMutex.Lock()
	defer fake.enableKeyRotationWithContextMutex.Unlock()
	fake.EnableKeyRotationWithContextStub = nil
	if fake.enableKeyRotationWithContextReturnsOnCall == nil {
		fake.enableKeyRotationWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.EnableKeyRotationOutput
			result2 error
		})
	}
	fake.enableKeyRotationWithContextReturnsOnCall[i] = struct {
		result1 *kms.EnableKeyRotationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyWithContext(arg1 context.Context, arg2 *kms.EnableKeyInput, arg3 ...request.Option) (*kms.EnableKeyOutput, error) {
	fake.enableKeyWithContextMutex.Lock()
	ret, specificReturn := fake.enableKeyWithContextReturnsOnCall[len(fake.enableKeyWithContextArgsForCall)]
	fake.enableKeyWithContextArgsForCall = append(fake.enableKeyWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.EnableKeyInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.EnableKeyWithContextStub
	fakeReturns := fake.enableKeyWithContextReturns
	fake.recordInvocation("EnableKeyWithContext", []interface{}{arg1, arg2, arg3})
	fake.enableKeyWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) EnableKeyWithContextCallCount() int {
	fake.enableKeyWithContextMutex.RLock()
	defer fake.enableKeyWithContextMutex.RUnlock()
	return len(fake.enableKeyWithContextArgsForCall)
}

func (fake *FakeKMSClient) EnableKeyWithContextCalls(stub func(context.Context, *kms.EnableKeyInput, ...request.Option) (*kms.EnableKeyOutput, error)) {
	fake.enableKeyWithContextMutex.Lock()
	defer fake.enableKeyWithContextMutex.Unlock()
	fake.EnableKeyWithContextStub = stub
}

func (fake *FakeKMSClient) EnableKeyWithContextArgsForCall(i int) (context.Context, *kms.EnableKeyInput, []request.Option) {
	fake.enableKeyWithContextMutex.RLock()
	defer fake.enableKeyWithContextMutex.RUnlock()
	argsForCall := fake.enableKeyWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) EnableKeyWithContextReturns(result1 *kms.EnableKeyOutput, result2 error) {
	fake.enableKeyWithContextMutex.Lock()
	defer fake.enableKeyWithContextMutex.Unlock()
	fake.EnableKeyWithContextStub = nil
	fake.enableKeyWithContextReturns = struct {
		result1 *kms.EnableKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EnableKeyWithContextReturnsOnCall(i int, result1 *kms.EnableKeyOutput, result2 error) {
	fake.enableKeyWithContextMutex.Lock()
	defer fake.enableKeyWithContextMutex.Unlock()
	fake.EnableKeyWithContextStub = nil
	if fake.enableKeyWithContextReturnsOnCall == nil {
		fake.enableKeyWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.EnableKeyOutput
			result2 error
		})
	}
	fake.enableKeyWithContextReturnsOnCall[i] = struct {
		result1 *kms.EnableKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) Encrypt(arg1 *kms.EncryptInput) (*kms.EncryptOutput, error) {
	fake.encryptMutex.Lock()
	ret, specificReturn := fake.encryptReturnsOnCall[len(fake.encryptArgsForCall)]
	fake.encryptArgsForCall = append(fake.encryptArgsForCall, struct {
		arg1 *kms.EncryptInput
	}{arg1})
	stub := fake.EncryptStub
	fakeReturns := fake.encryptReturns
	fake.recordInvocation("Encrypt", []interface{}{arg1})
	fake.encryptMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) EncryptCallCount() int {
	fake.encryptMutex.RLock()
	defer fake.encryptMutex.RUnlock()
	return len(fake.encryptArgsForCall)
}

func (fake *FakeKMSClient) EncryptCalls(stub func(*kms.EncryptInput) (*kms.EncryptOutput, error)) {
	fake.encryptMutex.Lock()
	defer fake.encryptMutex.Unlock()
	fake.EncryptStub = stub
}

func (fake *FakeKMSClient) EncryptArgsForCall(i int) *kms.EncryptInput {
	fake.encryptMutex.RLock()
	defer fake.encryptMutex.RUnlock()
	argsForCall := fake.encryptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) EncryptReturns(result1 *kms.EncryptOutput, result2 error) {
	fake.encryptMutex.Lock()
	defer fake.encryptMutex.Unlock()
	fake.EncryptStub = nil
	fake.encryptReturns = struct {
		result1 *kms.EncryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EncryptReturnsOnCall(i int, result1 *kms.EncryptOutput, result2 error) {
	fake.encryptMutex.Lock()
	defer fake.encryptMutex.Unlock()
	fake.EncryptStub = nil
	if fake.encryptReturnsOnCall == nil {
		fake.encryptReturnsOnCall = make(map[int]struct {
			result1 *kms.EncryptOutput
			result2 error
		})
	}
	fake.encryptReturnsOnCall[i] = struct {
		result1 *kms.EncryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EncryptRequest(arg1 *kms.EncryptInput) (*request.Request, *kms.EncryptOutput) {
	fake.encryptRequestMutex.Lock()
	ret, specificReturn := fake.encryptRequestReturnsOnCall[len(fake.encryptRequestArgsForCall)]
	fake.encryptRequestArgsForCall = append(fake.encryptRequestArgsForCall, struct {
		arg1 *kms.EncryptInput
	}{arg1})
	stub := fake.EncryptRequestStub
	fakeReturns := fake.encryptRequestReturns
	fake.recordInvocation("EncryptRequest", []interface{}{arg1})
	fake.encryptRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) EncryptRequestCallCount() int {
	fake.encryptRequestMutex.RLock()
	defer fake.encryptRequestMutex.RUnlock()
	return len(fake.encryptRequestArgsForCall)
}

func (fake *FakeKMSClient) EncryptRequestCalls(stub func(*kms.EncryptInput) (*request.Request, *kms.EncryptOutput)) {
	fake.encryptRequestMutex.Lock()
	defer fake.encryptRequestMutex.Unlock()
	fake.EncryptRequestStub = stub
}

func (fake *FakeKMSClient) EncryptRequestArgsForCall(i int) *kms.EncryptInput {
	fake.encryptRequestMutex.RLock()
	defer fake.encryptRequestMutex.RUnlock()
	argsForCall := fake.encryptRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) EncryptRequestReturns(result1 *request.Request, result2 *kms.EncryptOutput) {
	fake.encryptRequestMutex.Lock()
	defer fake.encryptRequestMutex.Unlock()
	fake.EncryptRequestStub = nil
	fake.encryptRequestReturns = struct {
		result1 *request.Request
		result2 *kms.EncryptOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) EncryptRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.EncryptOutput) {
	fake.encryptRequestMutex.Lock()
	defer fake.encryptRequestMutex.Unlock()
	fake.EncryptRequestStub = nil
	if fake.encryptRequestReturnsOnCall == nil {
		fake.encryptRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.EncryptOutput
		})
	}
	fake.encryptRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.EncryptOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) EncryptWithContext(arg1 context.Context, arg2 *kms.EncryptInput, arg3 ...request.Option) (*kms.EncryptOutput, error) {
	fake.encryptWithContextMutex.Lock()
	ret, specificReturn := fake.encryptWithContextReturnsOnCall[len(fake.encryptWithContextArgsForCall)]
	fake.encryptWithContextArgsForCall = append(fake.encryptWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.EncryptInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.EncryptWithContextStub
	fakeReturns := fake.encryptWithContextReturns
	fake.recordInvocation("EncryptWithContext", []interface{}{arg1, arg2, arg3})
	fake.encryptWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) EncryptWithContextCallCount() int {
	fake.encryptWithContextMutex.RLock()
	defer fake.encryptWithContextMutex.RUnlock()
	return len(fake.encryptWithContextArgsForCall)
}

func (fake *FakeKMSClient) EncryptWithContextCalls(stub func(context.Context, *kms.EncryptInput, ...request.Option) (*kms.EncryptOutput, error)) {
	fake.encryptWithContextMutex.Lock()
	defer fake.encryptWithContextMutex.Unlock()
	fake.EncryptWithContextStub = stub
}

func (fake *FakeKMSClient) EncryptWithContextArgsForCall(i int) (context.Context, *kms.EncryptInput, []request.Option) {
	fake.encryptWithContextMutex.RLock()
	defer fake.encryptWithContextMutex.RUnlock()
	argsForCall := fake.encryptWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) EncryptWithContextReturns(result1 *kms.EncryptOutput, result2 error) {
	fake.encryptWithContextMutex.Lock()
	defer fake.encryptWithContextMutex.Unlock()
	fake.EncryptWithContextStub = nil
	fake.encryptWithContextReturns = struct {
		result1 *kms.EncryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) EncryptWithContextReturnsOnCall(i int, result1 *kms.EncryptOutput, result2 error) {
	fake.encryptWithContextMutex.Lock()
	defer fake.encryptWithContextMutex.Unlock()
	fake.EncryptWithContextStub = nil
	if fake.encryptWithContextReturnsOnCall == nil {
		fake.encryptWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.EncryptOutput
			result2 error
		})
	}
	fake.encryptWithContextReturnsOnCall[i] = struct {
		result1 *kms.EncryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKey(arg1 *kms.GenerateDataKeyInput) (*kms.GenerateDataKeyOutput, error) {
	fake.generateDataKeyMutex.Lock()
	ret, specificReturn := fake.generateDataKeyReturnsOnCall[len(fake.generateDataKeyArgsForCall)]
	fake.generateDataKeyArgsForCall = append(fake.generateDataKeyArgsForCall, struct {
		arg1 *kms.GenerateDataKeyInput
	}{arg1})
	stub := fake.GenerateDataKeyStub
	fakeReturns := fake.generateDataKeyReturns
	fake.recordInvocation("GenerateDataKey", []interface{}{arg1})
	fake.generateDataKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyCallCount() int {
	fake.generateDataKeyMutex.RLock()
	defer fake.generateDataKeyMutex.RUnlock()
	return len(fake.generateDataKeyArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyCalls(stub func(*kms.GenerateDataKeyInput) (*kms.GenerateDataKeyOutput, error)) {
	fake.generateDataKeyMutex.Lock()
	defer fake.generateDataKeyMutex.Unlock()
	fake.GenerateDataKeyStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyArgsForCall(i int) *kms.GenerateDataKeyInput {
	fake.generateDataKeyMutex.RLock()
	defer fake.generateDataKeyMutex.RUnlock()
	argsForCall := fake.generateDataKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateDataKeyReturns(result1 *kms.GenerateDataKeyOutput, result2 error) {
	fake.generateDataKeyMutex.Lock()
	defer fake.generateDataKeyMutex.Unlock()
	fake.GenerateDataKeyStub = nil
	fake.generateDataKeyReturns = struct {
		result1 *kms.GenerateDataKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyReturnsOnCall(i int, result1 *kms.GenerateDataKeyOutput, result2 error) {
	fake.generateDataKeyMutex.Lock()
	defer fake.generateDataKeyMutex.Unlock()
	fake.GenerateDataKeyStub = nil
	if fake.generateDataKeyReturnsOnCall == nil {
		fake.generateDataKeyReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateDataKeyOutput
			result2 error
		})
	}
	fake.generateDataKeyReturnsOnCall[i] = struct {
		result1 *kms.GenerateDataKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPair(arg1 *kms.GenerateDataKeyPairInput) (*kms.GenerateDataKeyPairOutput, error) {
	fake.generateDataKeyPairMutex.Lock()
	ret, specificReturn := fake.generateDataKeyPairReturnsOnCall[len(fake.generateDataKeyPairArgsForCall)]
	fake.generateDataKeyPairArgsForCall = append(fake.generateDataKeyPairArgsForCall, struct {
		arg1 *kms.GenerateDataKeyPairInput
	}{arg1})
	stub := fake.GenerateDataKeyPairStub
	fakeReturns := fake.generateDataKeyPairReturns
	fake.recordInvocation("GenerateDataKeyPair", []interface{}{arg1})
	fake.generateDataKeyPairMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyPairCallCount() int {
	fake.generateDataKeyPairMutex.RLock()
	defer fake.generateDataKeyPairMutex.RUnlock()
	return len(fake.generateDataKeyPairArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyPairCalls(stub func(*kms.GenerateDataKeyPairInput) (*kms.GenerateDataKeyPairOutput, error)) {
	fake.generateDataKeyPairMutex.Lock()
	defer fake.generateDataKeyPairMutex.Unlock()
	fake.GenerateDataKeyPairStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyPairArgsForCall(i int) *kms.GenerateDataKeyPairInput {
	fake.generateDataKeyPairMutex.RLock()
	defer fake.generateDataKeyPairMutex.RUnlock()
	argsForCall := fake.generateDataKeyPairArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateDataKeyPairReturns(result1 *kms.GenerateDataKeyPairOutput, result2 error) {
	fake.generateDataKeyPairMutex.Lock()
	defer fake.generateDataKeyPairMutex.Unlock()
	fake.GenerateDataKeyPairStub = nil
	fake.generateDataKeyPairReturns = struct {
		result1 *kms.GenerateDataKeyPairOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairReturnsOnCall(i int, result1 *kms.GenerateDataKeyPairOutput, result2 error) {
	fake.generateDataKeyPairMutex.Lock()
	defer fake.generateDataKeyPairMutex.Unlock()
	fake.GenerateDataKeyPairStub = nil
	if fake.generateDataKeyPairReturnsOnCall == nil {
		fake.generateDataKeyPairReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateDataKeyPairOutput
			result2 error
		})
	}
	fake.generateDataKeyPairReturnsOnCall[i] = struct {
		result1 *kms.GenerateDataKeyPairOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairRequest(arg1 *kms.GenerateDataKeyPairInput) (*request.Request, *kms.GenerateDataKeyPairOutput) {
	fake.generateDataKeyPairRequestMutex.Lock()
	ret, specificReturn := fake.generateDataKeyPairRequestReturnsOnCall[len(fake.generateDataKeyPairRequestArgsForCall)]
	fake.generateDataKeyPairRequestArgsForCall = append(fake.generateDataKeyPairRequestArgsForCall, struct {
		arg1 *kms.GenerateDataKeyPairInput
	}{arg1})
	stub := fake.GenerateDataKeyPairRequestStub
	fakeReturns := fake.generateDataKeyPairRequestReturns
	fake.recordInvocation("GenerateDataKeyPairRequest", []interface{}{arg1})
	fake.generateDataKeyPairRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyPairRequestCallCount() int {
	fake.generateDataKeyPairRequestMutex.RLock()
	defer fake.generateDataKeyPairRequestMutex.RUnlock()
	return len(fake.generateDataKeyPairRequestArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyPairRequestCalls(stub func(*kms.GenerateDataKeyPairInput) (*request.Request, *kms.GenerateDataKeyPairOutput)) {
	fake.generateDataKeyPairRequestMutex.Lock()
	defer fake.generateDataKeyPairRequestMutex.Unlock()
	fake.GenerateDataKeyPairRequestStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyPairRequestArgsForCall(i int) *kms.GenerateDataKeyPairInput {
	fake.generateDataKeyPairRequestMutex.RLock()
	defer fake.generateDataKeyPairRequestMutex.RUnlock()
	argsForCall := fake.generateDataKeyPairRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateDataKeyPairRequestReturns(result1 *request.Request, result2 *kms.GenerateDataKeyPairOutput) {
	fake.generateDataKeyPairRequestMutex.Lock()
	defer fake.generateDataKeyPairRequestMutex.Unlock()
	fake.GenerateDataKeyPairRequestStub = nil
	fake.generateDataKeyPairRequestReturns = struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyPairOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.GenerateDataKeyPairOutput) {
	fake.generateDataKeyPairRequestMutex.Lock()
	defer fake.generateDataKeyPairRequestMutex.Unlock()
	fake.GenerateDataKeyPairRequestStub = nil
	if fake.generateDataKeyPairRequestReturnsOnCall == nil {
		fake.generateDataKeyPairRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.GenerateDataKeyPairOutput
		})
	}
	fake.generateDataKeyPairRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyPairOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithContext(arg1 context.Context, arg2 *kms.GenerateDataKeyPairInput, arg3 ...request.Option) (*kms.GenerateDataKeyPairOutput, error) {
	fake.generateDataKeyPairWithContextMutex.Lock()
	ret, specificReturn := fake.generateDataKeyPairWithContextReturnsOnCall[len(fake.generateDataKeyPairWithContextArgsForCall)]
	fake.generateDataKeyPairWithContextArgsForCall = append(fake.generateDataKeyPairWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.GenerateDataKeyPairInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GenerateDataKeyPairWithContextStub
	fakeReturns := fake.generateDataKeyPairWithContextReturns
	fake.recordInvocation("GenerateDataKeyPairWithContext", []interface{}{arg1, arg2, arg3})
	fake.generateDataKeyPairWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithContextCallCount() int {
	fake.generateDataKeyPairWithContextMutex.RLock()
	defer fake.generateDataKeyPairWithContextMutex.RUnlock()
	return len(fake.generateDataKeyPairWithContextArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithContextCalls(stub func(context.Context, *kms.GenerateDataKeyPairInput, ...request.Option) (*kms.GenerateDataKeyPairOutput, error)) {
	fake.generateDataKeyPairWithContextMutex.Lock()
	defer fake.generateDataKeyPairWithContextMutex.Unlock()
	fake.GenerateDataKeyPairWithContextStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithContextArgsForCall(i int) (context.Context, *kms.GenerateDataKeyPairInput, []request.Option) {
	fake.generateDataKeyPairWithContextMutex.RLock()
	defer fake.generateDataKeyPairWithContextMutex.RUnlock()
	argsForCall := fake.generateDataKeyPairWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithContextReturns(result1 *kms.GenerateDataKeyPairOutput, result2 error) {
	fake.generateDataKeyPairWithContextMutex.Lock()
	defer fake.generateDataKeyPairWithContextMutex.Unlock()
	fake.GenerateDataKeyPairWithContextStub = nil
	fake.generateDataKeyPairWithContextReturns = struct {
		result1 *kms.GenerateDataKeyPairOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithContextReturnsOnCall(i int, result1 *kms.GenerateDataKeyPairOutput, result2 error) {
	fake.generateDataKeyPairWithContextMutex.Lock()
	defer fake.generateDataKeyPairWithContextMutex.Unlock()
	fake.GenerateDataKeyPairWithContextStub = nil
	if fake.generateDataKeyPairWithContextReturnsOnCall == nil {
		fake.generateDataKeyPairWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateDataKeyPairOutput
			result2 error
		})
	}
	fake.generateDataKeyPairWithContextReturnsOnCall[i] = struct {
		result1 *kms.GenerateDataKeyPairOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintext(arg1 *kms.GenerateDataKeyPairWithoutPlaintextInput) (*kms.GenerateDataKeyPairWithoutPlaintextOutput, error) {
	fake.generateDataKeyPairWithoutPlaintextMutex.Lock()
	ret, specificReturn := fake.generateDataKeyPairWithoutPlaintextReturnsOnCall[len(fake.generateDataKeyPairWithoutPlaintextArgsForCall)]
	fake.generateDataKeyPairWithoutPlaintextArgsForCall = append(fake.generateDataKeyPairWithoutPlaintextArgsForCall, struct {
		arg1 *kms.GenerateDataKeyPairWithoutPlaintextInput
	}{arg1})
	stub := fake.GenerateDataKeyPairWithoutPlaintextStub
	fakeReturns := fake.generateDataKeyPairWithoutPlaintextReturns
	fake.recordInvocation("GenerateDataKeyPairWithoutPlaintext", []interface{}{arg1})
	fake.generateDataKeyPairWithoutPlaintextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextCallCount() int {
	fake.generateDataKeyPairWithoutPlaintextMutex.RLock()
	defer fake.generateDataKeyPairWithoutPlaintextMutex.RUnlock()
	return len(fake.generateDataKeyPairWithoutPlaintextArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextCalls(stub func(*kms.GenerateDataKeyPairWithoutPlaintextInput) (*kms.GenerateDataKeyPairWithoutPlaintextOutput, error)) {
	fake.generateDataKeyPairWithoutPlaintextMutex.Lock()
	defer fake.generateDataKeyPairWithoutPlaintextMutex.Unlock()
	fake.GenerateDataKeyPairWithoutPlaintextStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextArgsForCall(i int) *kms.GenerateDataKeyPairWithoutPlaintextInput {
	fake.generateDataKeyPairWithoutPlaintextMutex.RLock()
	defer fake.generateDataKeyPairWithoutPlaintextMutex.RUnlock()
	argsForCall := fake.generateDataKeyPairWithoutPlaintextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextReturns(result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput, result2 error) {
	fake.generateDataKeyPairWithoutPlaintextMutex.Lock()
	defer fake.generateDataKeyPairWithoutPlaintextMutex.Unlock()
	fake.GenerateDataKeyPairWithoutPlaintextStub = nil
	fake.generateDataKeyPairWithoutPlaintextReturns = struct {
		result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextReturnsOnCall(i int, result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput, result2 error) {
	fake.generateDataKeyPairWithoutPlaintextMutex.Lock()
	defer fake.generateDataKeyPairWithoutPlaintextMutex.Unlock()
	fake.GenerateDataKeyPairWithoutPlaintextStub = nil
	if fake.generateDataKeyPairWithoutPlaintextReturnsOnCall == nil {
		fake.generateDataKeyPairWithoutPlaintextReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput
			result2 error
		})
	}
	fake.generateDataKeyPairWithoutPlaintextReturnsOnCall[i] = struct {
		result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextRequest(arg1 *kms.GenerateDataKeyPairWithoutPlaintextInput) (*request.Request, *kms.GenerateDataKeyPairWithoutPlaintextOutput) {
	fake.generateDataKeyPairWithoutPlaintextRequestMutex.Lock()
	ret, specificReturn := fake.generateDataKeyPairWithoutPlaintextRequestReturnsOnCall[len(fake.generateDataKeyPairWithoutPlaintextRequestArgsForCall)]
	fake.generateDataKeyPairWithoutPlaintextRequestArgsForCall = append(fake.generateDataKeyPairWithoutPlaintextRequestArgsForCall, struct {
		arg1 *kms.GenerateDataKeyPairWithoutPlaintextInput
	}{arg1})
	stub := fake.GenerateDataKeyPairWithoutPlaintextRequestStub
	fakeReturns := fake.generateDataKeyPairWithoutPlaintextRequestReturns
	fake.recordInvocation("GenerateDataKeyPairWithoutPlaintextRequest", []interface{}{arg1})
	fake.generateDataKeyPairWithoutPlaintextRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextRequestCallCount() int {
	fake.generateDataKeyPairWithoutPlaintextRequestMutex.RLock()
	defer fake.generateDataKeyPairWithoutPlaintextRequestMutex.RUnlock()
	return len(fake.generateDataKeyPairWithoutPlaintextRequestArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextRequestCalls(stub func(*kms.GenerateDataKeyPairWithoutPlaintextInput) (*request.Request, *kms.GenerateDataKeyPairWithoutPlaintextOutput)) {
	fake.generateDataKeyPairWithoutPlaintextRequestMutex.Lock()
	defer fake.generateDataKeyPairWithoutPlaintextRequestMutex.Unlock()
	fake.GenerateDataKeyPairWithoutPlaintextRequestStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextRequestArgsForCall(i int) *kms.GenerateDataKeyPairWithoutPlaintextInput {
	fake.generateDataKeyPairWithoutPlaintextRequestMutex.RLock()
	defer fake.generateDataKeyPairWithoutPlaintextRequestMutex.RUnlock()
	argsForCall := fake.generateDataKeyPairWithoutPlaintextRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextRequestReturns(result1 *request.Request, result2 *kms.GenerateDataKeyPairWithoutPlaintextOutput) {
	fake.generateDataKeyPairWithoutPlaintextRequestMutex.Lock()
	defer fake.generateDataKeyPairWithoutPlaintextRequestMutex.Unlock()
	fake.GenerateDataKeyPairWithoutPlaintextRequestStub = nil
	fake.generateDataKeyPairWithoutPlaintextRequestReturns = struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyPairWithoutPlaintextOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.GenerateDataKeyPairWithoutPlaintextOutput) {
	fake.generateDataKeyPairWithoutPlaintextRequestMutex.Lock()
	defer fake.generateDataKeyPairWithoutPlaintextRequestMutex.Unlock()
	fake.GenerateDataKeyPairWithoutPlaintextRequestStub = nil
	if fake.generateDataKeyPairWithoutPlaintextRequestReturnsOnCall == nil {
		fake.generateDataKeyPairWithoutPlaintextRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.GenerateDataKeyPairWithoutPlaintextOutput
		})
	}
	fake.generateDataKeyPairWithoutPlaintextRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyPairWithoutPlaintextOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextWithContext(arg1 context.Context, arg2 *kms.GenerateDataKeyPairWithoutPlaintextInput, arg3 ...request.Option) (*kms.GenerateDataKeyPairWithoutPlaintextOutput, error) {
	fake.generateDataKeyPairWithoutPlaintextWithContextMutex.Lock()
	ret, specificReturn := fake.generateDataKeyPairWithoutPlaintextWithContextReturnsOnCall[len(fake.generateDataKeyPairWithoutPlaintextWithContextArgsForCall)]
	fake.generateDataKeyPairWithoutPlaintextWithContextArgsForCall = append(fake.generateDataKeyPairWithoutPlaintextWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.GenerateDataKeyPairWithoutPlaintextInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GenerateDataKeyPairWithoutPlaintextWithContextStub
	fakeReturns := fake.generateDataKeyPairWithoutPlaintextWithContextReturns
	fake.recordInvocation("GenerateDataKeyPairWithoutPlaintextWithContext", []interface{}{arg1, arg2, arg3})
	fake.generateDataKeyPairWithoutPlaintextWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextWithContextCallCount() int {
	fake.generateDataKeyPairWithoutPlaintextWithContextMutex.RLock()
	defer fake.generateDataKeyPairWithoutPlaintextWithContextMutex.RUnlock()
	return len(fake.generateDataKeyPairWithoutPlaintextWithContextArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextWithContextCalls(stub func(context.Context, *kms.GenerateDataKeyPairWithoutPlaintextInput, ...request.Option) (*kms.GenerateDataKeyPairWithoutPlaintextOutput, error)) {
	fake.generateDataKeyPairWithoutPlaintextWithContextMutex.Lock()
	defer fake.generateDataKeyPairWithoutPlaintextWithContextMutex.Unlock()
	fake.GenerateDataKeyPairWithoutPlaintextWithContextStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextWithContextArgsForCall(i int) (context.Context, *kms.GenerateDataKeyPairWithoutPlaintextInput, []request.Option) {
	fake.generateDataKeyPairWithoutPlaintextWithContextMutex.RLock()
	defer fake.generateDataKeyPairWithoutPlaintextWithContextMutex.RUnlock()
	argsForCall := fake.generateDataKeyPairWithoutPlaintextWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextWithContextReturns(result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput, result2 error) {
	fake.generateDataKeyPairWithoutPlaintextWithContextMutex.Lock()
	defer fake.generateDataKeyPairWithoutPlaintextWithContextMutex.Unlock()
	fake.GenerateDataKeyPairWithoutPlaintextWithContextStub = nil
	fake.generateDataKeyPairWithoutPlaintextWithContextReturns = struct {
		result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyPairWithoutPlaintextWithContextReturnsOnCall(i int, result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput, result2 error) {
	fake.generateDataKeyPairWithoutPlaintextWithContextMutex.Lock()
	defer fake.generateDataKeyPairWithoutPlaintextWithContextMutex.Unlock()
	fake.GenerateDataKeyPairWithoutPlaintextWithContextStub = nil
	if fake.generateDataKeyPairWithoutPlaintextWithContextReturnsOnCall == nil {
		fake.generateDataKeyPairWithoutPlaintextWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput
			result2 error
		})
	}
	fake.generateDataKeyPairWithoutPlaintextWithContextReturnsOnCall[i] = struct {
		result1 *kms.GenerateDataKeyPairWithoutPlaintextOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyRequest(arg1 *kms.GenerateDataKeyInput) (*request.Request, *kms.GenerateDataKeyOutput) {
	fake.generateDataKeyRequestMutex.Lock()
	ret, specificReturn := fake.generateDataKeyRequestReturnsOnCall[len(fake.generateDataKeyRequestArgsForCall)]
	fake.generateDataKeyRequestArgsForCall = append(fake.generateDataKeyRequestArgsForCall, struct {
		arg1 *kms.GenerateDataKeyInput
	}{arg1})
	stub := fake.GenerateDataKeyRequestStub
	fakeReturns := fake.generateDataKeyRequestReturns
	fake.recordInvocation("GenerateDataKeyRequest", []interface{}{arg1})
	fake.generateDataKeyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyRequestCallCount() int {
	fake.generateDataKeyRequestMutex.RLock()
	defer fake.generateDataKeyRequestMutex.RUnlock()
	return len(fake.generateDataKeyRequestArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyRequestCalls(stub func(*kms.GenerateDataKeyInput) (*request.Request, *kms.GenerateDataKeyOutput)) {
	fake.generateDataKeyRequestMutex.Lock()
	defer fake.generateDataKeyRequestMutex.Unlock()
	fake.GenerateDataKeyRequestStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyRequestArgsForCall(i int) *kms.GenerateDataKeyInput {
	fake.generateDataKeyRequestMutex.RLock()
	defer fake.generateDataKeyRequestMutex.RUnlock()
	argsForCall := fake.generateDataKeyRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateDataKeyRequestReturns(result1 *request.Request, result2 *kms.GenerateDataKeyOutput) {
	fake.generateDataKeyRequestMutex.Lock()
	defer fake.generateDataKeyRequestMutex.Unlock()
	fake.GenerateDataKeyRequestStub = nil
	fake.generateDataKeyRequestReturns = struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.GenerateDataKeyOutput) {
	fake.generateDataKeyRequestMutex.Lock()
	defer fake.generateDataKeyRequestMutex.Unlock()
	fake.GenerateDataKeyRequestStub = nil
	if fake.generateDataKeyRequestReturnsOnCall == nil {
		fake.generateDataKeyRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.GenerateDataKeyOutput
		})
	}
	fake.generateDataKeyRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyWithContext(arg1 context.Context, arg2 *kms.GenerateDataKeyInput, arg3 ...request.Option) (*kms.GenerateDataKeyOutput, error) {
	fake.generateDataKeyWithContextMutex.Lock()
	ret, specificReturn := fake.generateDataKeyWithContextReturnsOnCall[len(fake.generateDataKeyWithContextArgsForCall)]
	fake.generateDataKeyWithContextArgsForCall = append(fake.generateDataKeyWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.GenerateDataKeyInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GenerateDataKeyWithContextStub
	fakeReturns := fake.generateDataKeyWithContextReturns
	fake.recordInvocation("GenerateDataKeyWithContext", []interface{}{arg1, arg2, arg3})
	fake.generateDataKeyWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyWithContextCallCount() int {
	fake.generateDataKeyWithContextMutex.RLock()
	defer fake.generateDataKeyWithContextMutex.RUnlock()
	return len(fake.generateDataKeyWithContextArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyWithContextCalls(stub func(context.Context, *kms.GenerateDataKeyInput, ...request.Option) (*kms.GenerateDataKeyOutput, error)) {
	fake.generateDataKeyWithContextMutex.Lock()
	defer fake.generateDataKeyWithContextMutex.Unlock()
	fake.GenerateDataKeyWithContextStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyWithContextArgsForCall(i int) (context.Context, *kms.GenerateDataKeyInput, []request.Option) {
	fake.generateDataKeyWithContextMutex.RLock()
	defer fake.generateDataKeyWithContextMutex.RUnlock()
	argsForCall := fake.generateDataKeyWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) GenerateDataKeyWithContextReturns(result1 *kms.GenerateDataKeyOutput, result2 error) {
	fake.generateDataKeyWithContextMutex.Lock()
	defer fake.generateDataKeyWithContextMutex.Unlock()
	fake.GenerateDataKeyWithContextStub = nil
	fake.generateDataKeyWithContextReturns = struct {
		result1 *kms.GenerateDataKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyWithContextReturnsOnCall(i int, result1 *kms.GenerateDataKeyOutput, result2 error) {
	fake.generateDataKeyWithContextMutex.Lock()
	defer fake.generateDataKeyWithContextMutex.Unlock()
	fake.GenerateDataKeyWithContextStub = nil
	if fake.generateDataKeyWithContextReturnsOnCall == nil {
		fake.generateDataKeyWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateDataKeyOutput
			result2 error
		})
	}
	fake.generateDataKeyWithContextReturnsOnCall[i] = struct {
		result1 *kms.GenerateDataKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintext(arg1 *kms.GenerateDataKeyWithoutPlaintextInput) (*kms.GenerateDataKeyWithoutPlaintextOutput, error) {
	fake.generateDataKeyWithoutPlaintextMutex.Lock()
	ret, specificReturn := fake.generateDataKeyWithoutPlaintextReturnsOnCall[len(fake.generateDataKeyWithoutPlaintextArgsForCall)]
	fake.generateDataKeyWithoutPlaintextArgsForCall = append(fake.generateDataKeyWithoutPlaintextArgsForCall, struct {
		arg1 *kms.GenerateDataKeyWithoutPlaintextInput
	}{arg1})
	stub := fake.GenerateDataKeyWithoutPlaintextStub
	fakeReturns := fake.generateDataKeyWithoutPlaintextReturns
	fake.recordInvocation("GenerateDataKeyWithoutPlaintext", []interface{}{arg1})
	fake.generateDataKeyWithoutPlaintextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextCallCount() int {
	fake.generateDataKeyWithoutPlaintextMutex.RLock()
	defer fake.generateDataKeyWithoutPlaintextMutex.RUnlock()
	return len(fake.generateDataKeyWithoutPlaintextArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextCalls(stub func(*kms.GenerateDataKeyWithoutPlaintextInput) (*kms.GenerateDataKeyWithoutPlaintextOutput, error)) {
	fake.generateDataKeyWithoutPlaintextMutex.Lock()
	defer fake.generateDataKeyWithoutPlaintextMutex.Unlock()
	fake.GenerateDataKeyWithoutPlaintextStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextArgsForCall(i int) *kms.GenerateDataKeyWithoutPlaintextInput {
	fake.generateDataKeyWithoutPlaintextMutex.RLock()
	defer fake.generateDataKeyWithoutPlaintextMutex.RUnlock()
	argsForCall := fake.generateDataKeyWithoutPlaintextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextReturns(result1 *kms.GenerateDataKeyWithoutPlaintextOutput, result2 error) {
	fake.generateDataKeyWithoutPlaintextMutex.Lock()
	defer fake.generateDataKeyWithoutPlaintextMutex.Unlock()
	fake.GenerateDataKeyWithoutPlaintextStub = nil
	fake.generateDataKeyWithoutPlaintextReturns = struct {
		result1 *kms.GenerateDataKeyWithoutPlaintextOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextReturnsOnCall(i int, result1 *kms.GenerateDataKeyWithoutPlaintextOutput, result2 error) {
	fake.generateDataKeyWithoutPlaintextMutex.Lock()
	defer fake.generateDataKeyWithoutPlaintextMutex.Unlock()
	fake.GenerateDataKeyWithoutPlaintextStub = nil
	if fake.generateDataKeyWithoutPlaintextReturnsOnCall == nil {
		fake.generateDataKeyWithoutPlaintextReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateDataKeyWithoutPlaintextOutput
			result2 error
		})
	}
	fake.generateDataKeyWithoutPlaintextReturnsOnCall[i] = struct {
		result1 *kms.GenerateDataKeyWithoutPlaintextOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextRequest(arg1 *kms.GenerateDataKeyWithoutPlaintextInput) (*request.Request, *kms.GenerateDataKeyWithoutPlaintextOutput) {
	fake.generateDataKeyWithoutPlaintextRequestMutex.Lock()
	ret, specificReturn := fake.generateDataKeyWithoutPlaintextRequestReturnsOnCall[len(fake.generateDataKeyWithoutPlaintextRequestArgsForCall)]
	fake.generateDataKeyWithoutPlaintextRequestArgsForCall = append(fake.generateDataKeyWithoutPlaintextRequestArgsForCall, struct {
		arg1 *kms.GenerateDataKeyWithoutPlaintextInput
	}{arg1})
	stub := fake.GenerateDataKeyWithoutPlaintextRequestStub
	fakeReturns := fake.generateDataKeyWithoutPlaintextRequestReturns
	fake.recordInvocation("GenerateDataKeyWithoutPlaintextRequest", []interface{}{arg1})
	fake.generateDataKeyWithoutPlaintextRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextRequestCallCount() int {
	fake.generateDataKeyWithoutPlaintextRequestMutex.RLock()
	defer fake.generateDataKeyWithoutPlaintextRequestMutex.RUnlock()
	return len(fake.generateDataKeyWithoutPlaintextRequestArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextRequestCalls(stub func(*kms.GenerateDataKeyWithoutPlaintextInput) (*request.Request, *kms.GenerateDataKeyWithoutPlaintextOutput)) {
	fake.generateDataKeyWithoutPlaintextRequestMutex.Lock()
	defer fake.generateDataKeyWithoutPlaintextRequestMutex.Unlock()
	fake.GenerateDataKeyWithoutPlaintextRequestStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextRequestArgsForCall(i int) *kms.GenerateDataKeyWithoutPlaintextInput {
	fake.generateDataKeyWithoutPlaintextRequestMutex.RLock()
	defer fake.generateDataKeyWithoutPlaintextRequestMutex.RUnlock()
	argsForCall := fake.generateDataKeyWithoutPlaintextRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextRequestReturns(result1 *request.Request, result2 *kms.GenerateDataKeyWithoutPlaintextOutput) {
	fake.generateDataKeyWithoutPlaintextRequestMutex.Lock()
	defer fake.generateDataKeyWithoutPlaintextRequestMutex.Unlock()
	fake.GenerateDataKeyWithoutPlaintextRequestStub = nil
	fake.generateDataKeyWithoutPlaintextRequestReturns = struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyWithoutPlaintextOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.GenerateDataKeyWithoutPlaintextOutput) {
	fake.generateDataKeyWithoutPlaintextRequestMutex.Lock()
	defer fake.generateDataKeyWithoutPlaintextRequestMutex.Unlock()
	fake.GenerateDataKeyWithoutPlaintextRequestStub = nil
	if fake.generateDataKeyWithoutPlaintextRequestReturnsOnCall == nil {
		fake.generateDataKeyWithoutPlaintextRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.GenerateDataKeyWithoutPlaintextOutput
		})
	}
	fake.generateDataKeyWithoutPlaintextRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.GenerateDataKeyWithoutPlaintextOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextWithContext(arg1 context.Context, arg2 *kms.GenerateDataKeyWithoutPlaintextInput, arg3 ...request.Option) (*kms.GenerateDataKeyWithoutPlaintextOutput, error) {
	fake.generateDataKeyWithoutPlaintextWithContextMutex.Lock()
	ret, specificReturn := fake.generateDataKeyWithoutPlaintextWithContextReturnsOnCall[len(fake.generateDataKeyWithoutPlaintextWithContextArgsForCall)]
	fake.generateDataKeyWithoutPlaintextWithContextArgsForCall = append(fake.generateDataKeyWithoutPlaintextWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.GenerateDataKeyWithoutPlaintextInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GenerateDataKeyWithoutPlaintextWithContextStub
	fakeReturns := fake.generateDataKeyWithoutPlaintextWithContextReturns
	fake.recordInvocation("GenerateDataKeyWithoutPlaintextWithContext", []interface{}{arg1, arg2, arg3})
	fake.generateDataKeyWithoutPlaintextWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextWithContextCallCount() int {
	fake.generateDataKeyWithoutPlaintextWithContextMutex.RLock()
	defer fake.generateDataKeyWithoutPlaintextWithContextMutex.RUnlock()
	return len(fake.generateDataKeyWithoutPlaintextWithContextArgsForCall)
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextWithContextCalls(stub func(context.Context, *kms.GenerateDataKeyWithoutPlaintextInput, ...request.Option) (*kms.GenerateDataKeyWithoutPlaintextOutput, error)) {
	fake.generateDataKeyWithoutPlaintextWithContextMutex.Lock()
	defer fake.generateDataKeyWithoutPlaintextWithContextMutex.Unlock()
	fake.GenerateDataKeyWithoutPlaintextWithContextStub = stub
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextWithContextArgsForCall(i int) (context.Context, *kms.GenerateDataKeyWithoutPlaintextInput, []request.Option) {
	fake.generateDataKeyWithoutPlaintextWithContextMutex.RLock()
	defer fake.generateDataKeyWithoutPlaintextWithContextMutex.RUnlock()
	argsForCall := fake.generateDataKeyWithoutPlaintextWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextWithContextReturns(result1 *kms.GenerateDataKeyWithoutPlaintextOutput, result2 error) {
	fake.generateDataKeyWithoutPlaintextWithContextMutex.Lock()
	defer fake.generateDataKeyWithoutPlaintextWithContextMutex.Unlock()
	fake.GenerateDataKeyWithoutPlaintextWithContextStub = nil
	fake.generateDataKeyWithoutPlaintextWithContextReturns = struct {
		result1 *kms.GenerateDataKeyWithoutPlaintextOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateDataKeyWithoutPlaintextWithContextReturnsOnCall(i int, result1 *kms.GenerateDataKeyWithoutPlaintextOutput, result2 error) {
	fake.generateDataKeyWithoutPlaintextWithContextMutex.Lock()
	defer fake.generateDataKeyWithoutPlaintextWithContextMutex.Unlock()
	fake.GenerateDataKeyWithoutPlaintextWithContextStub = nil
	if fake.generateDataKeyWithoutPlaintextWithContextReturnsOnCall == nil {
		fake.generateDataKeyWithoutPlaintextWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateDataKeyWithoutPlaintextOutput
			result2 error
		})
	}
	fake.generateDataKeyWithoutPlaintextWithContextReturnsOnCall[i] = struct {
		result1 *kms.GenerateDataKeyWithoutPlaintextOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateMac(arg1 *kms.GenerateMacInput) (*kms.GenerateMacOutput, error) {
	fake.generateMacMutex.Lock()
	ret, specificReturn := fake.generateMacReturnsOnCall[len(fake.generateMacArgsForCall)]
	fake.generateMacArgsForCall = append(fake.generateMacArgsForCall, struct {
		arg1 *kms.GenerateMacInput
	}{arg1})
	stub := fake.GenerateMacStub
	fakeReturns := fake.generateMacReturns
	fake.recordInvocation("GenerateMac", []interface{}{arg1})
	fake.generateMacMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateMacCallCount() int {
	fake.generateMacMutex.RLock()
	defer fake.generateMacMutex.RUnlock()
	return len(fake.generateMacArgsForCall)
}

func (fake *FakeKMSClient) GenerateMacCalls(stub func(*kms.GenerateMacInput) (*kms.GenerateMacOutput, error)) {
	fake.generateMacMutex.Lock()
	defer fake.generateMacMutex.Unlock()
	fake.GenerateMacStub = stub
}

func (fake *FakeKMSClient) GenerateMacArgsForCall(i int) *kms.GenerateMacInput {
	fake.generateMacMutex.RLock()
	defer fake.generateMacMutex.RUnlock()
	argsForCall := fake.generateMacArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateMacReturns(result1 *kms.GenerateMacOutput, result2 error) {
	fake.generateMacMutex.Lock()
	defer fake.generateMacMutex.Unlock()
	fake.GenerateMacStub = nil
	fake.generateMacReturns = struct {
		result1 *kms.GenerateMacOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateMacReturnsOnCall(i int, result1 *kms.GenerateMacOutput, result2 error) {
	fake.generateMacMutex.Lock()
	defer fake.generateMacMutex.Unlock()
	fake.GenerateMacStub = nil
	if fake.generateMacReturnsOnCall == nil {
		fake.generateMacReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateMacOutput
			result2 error
		})
	}
	fake.generateMacReturnsOnCall[i] = struct {
		result1 *kms.GenerateMacOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateMacRequest(arg1 *kms.GenerateMacInput) (*request.Request, *kms.GenerateMacOutput) {
	fake.generateMacRequestMutex.Lock()
	ret, specificReturn := fake.generateMacRequestReturnsOnCall[len(fake.generateMacRequestArgsForCall)]
	fake.generateMacRequestArgsForCall = append(fake.generateMacRequestArgsForCall, struct {
		arg1 *kms.GenerateMacInput
	}{arg1})
	stub := fake.GenerateMacRequestStub
	fakeReturns := fake.generateMacRequestReturns
	fake.recordInvocation("GenerateMacRequest", []interface{}{arg1})
	fake.generateMacRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateMacRequestCallCount() int {
	fake.generateMacRequestMutex.RLock()
	defer fake.generateMacRequestMutex.RUnlock()
	return len(fake.generateMacRequestArgsForCall)
}

func (fake *FakeKMSClient) GenerateMacRequestCalls(stub func(*kms.GenerateMacInput) (*request.Request, *kms.GenerateMacOutput)) {
	fake.generateMacRequestMutex.Lock()
	defer fake.generateMacRequestMutex.Unlock()
	fake.GenerateMacRequestStub = stub
}

func (fake *FakeKMSClient) GenerateMacRequestArgsForCall(i int) *kms.GenerateMacInput {
	fake.generateMacRequestMutex.RLock()
	defer fake.generateMacRequestMutex.RUnlock()
	argsForCall := fake.generateMacRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateMacRequestReturns(result1 *request.Request, result2 *kms.GenerateMacOutput) {
	fake.generateMacRequestMutex.Lock()
	defer fake.generateMacRequestMutex.Unlock()
	fake.GenerateMacRequestStub = nil
	fake.generateMacRequestReturns = struct {
		result1 *request.Request
		result2 *kms.GenerateMacOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateMacRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.GenerateMacOutput) {
	fake.generateMacRequestMutex.Lock()
	defer fake.generateMacRequestMutex.Unlock()
	fake.GenerateMacRequestStub = nil
	if fake.generateMacRequestReturnsOnCall == nil {
		fake.generateMacRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.GenerateMacOutput
		})
	}
	fake.generateMacRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.GenerateMacOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateMacWithContext(arg1 context.Context, arg2 *kms.GenerateMacInput, arg3 ...request.Option) (*kms.GenerateMacOutput, error) {
	fake.generateMacWithContextMutex.Lock()
	ret, specificReturn := fake.generateMacWithContextReturnsOnCall[len(fake.generateMacWithContextArgsForCall)]
	fake.generateMacWithContextArgsForCall = append(fake.generateMacWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.GenerateMacInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GenerateMacWithContextStub
	fakeReturns := fake.generateMacWithContextReturns
	fake.recordInvocation("GenerateMacWithContext", []interface{}{arg1, arg2, arg3})
	fake.generateMacWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateMacWithContextCallCount() int {
	fake.generateMacWithContextMutex.RLock()
	defer fake.generateMacWithContextMutex.RUnlock()
	return len(fake.generateMacWithContextArgsForCall)
}

func (fake *FakeKMSClient) GenerateMacWithContextCalls(stub func(context.Context, *kms.GenerateMacInput, ...request.Option) (*kms.GenerateMacOutput, error)) {
	fake.generateMacWithContextMutex.Lock()
	defer fake.generateMacWithContextMutex.Unlock()
	fake.GenerateMacWithContextStub = stub
}

func (fake *FakeKMSClient) GenerateMacWithContextArgsForCall(i int) (context.Context, *kms.GenerateMacInput, []request.Option) {
	fake.generateMacWithContextMutex.RLock()
	defer fake.generateMacWithContextMutex.RUnlock()
	argsForCall := fake.generateMacWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) GenerateMacWithContextReturns(result1 *kms.GenerateMacOutput, result2 error) {
	fake.generateMacWithContextMutex.Lock()
	defer fake.generateMacWithContextMutex.Unlock()
	fake.GenerateMacWithContextStub = nil
	fake.generateMacWithContextReturns = struct {
		result1 *kms.GenerateMacOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateMacWithContextReturnsOnCall(i int, result1 *kms.GenerateMacOutput, result2 error) {
	fake.generateMacWithContextMutex.Lock()
	defer fake.generateMacWithContextMutex.Unlock()
	fake.GenerateMacWithContextStub = nil
	if fake.generateMacWithContextReturnsOnCall == nil {
		fake.generateMacWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateMacOutput
			result2 error
		})
	}
	fake.generateMacWithContextReturnsOnCall[i] = struct {
		result1 *kms.GenerateMacOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateRandom(arg1 *kms.GenerateRandomInput) (*kms.GenerateRandomOutput, error) {
	fake.generateRandomMutex.Lock()
	ret, specificReturn := fake.generateRandomReturnsOnCall[len(fake.generateRandomArgsForCall)]
	fake.generateRandomArgsForCall = append(fake.generateRandomArgsForCall, struct {
		arg1 *kms.GenerateRandomInput
	}{arg1})
	stub := fake.GenerateRandomStub
	fakeReturns := fake.generateRandomReturns
	fake.recordInvocation("GenerateRandom", []interface{}{arg1})
	fake.generateRandomMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateRandomCallCount() int {
	fake.generateRandomMutex.RLock()
	defer fake.generateRandomMutex.RUnlock()
	return len(fake.generateRandomArgsForCall)
}

func (fake *FakeKMSClient) GenerateRandomCalls(stub func(*kms.GenerateRandomInput) (*kms.GenerateRandomOutput, error)) {
	fake.generateRandomMutex.Lock()
	defer fake.generateRandomMutex.Unlock()
	fake.GenerateRandomStub = stub
}

func (fake *FakeKMSClient) GenerateRandomArgsForCall(i int) *kms.GenerateRandomInput {
	fake.generateRandomMutex.RLock()
	defer fake.generateRandomMutex.RUnlock()
	argsForCall := fake.generateRandomArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateRandomReturns(result1 *kms.GenerateRandomOutput, result2 error) {
	fake.generateRandomMutex.Lock()
	defer fake.generateRandomMutex.Unlock()
	fake.GenerateRandomStub = nil
	fake.generateRandomReturns = struct {
		result1 *kms.GenerateRandomOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateRandomReturnsOnCall(i int, result1 *kms.GenerateRandomOutput, result2 error) {
	fake.generateRandomMutex.Lock()
	defer fake.generateRandomMutex.Unlock()
	fake.GenerateRandomStub = nil
	if fake.generateRandomReturnsOnCall == nil {
		fake.generateRandomReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateRandomOutput
			result2 error
		})
	}
	fake.generateRandomReturnsOnCall[i] = struct {
		result1 *kms.GenerateRandomOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateRandomRequest(arg1 *kms.GenerateRandomInput) (*request.Request, *kms.GenerateRandomOutput) {
	fake.generateRandomRequestMutex.Lock()
	ret, specificReturn := fake.generateRandomRequestReturnsOnCall[len(fake.generateRandomRequestArgsForCall)]
	fake.generateRandomRequestArgsForCall = append(fake.generateRandomRequestArgsForCall, struct {
		arg1 *kms.GenerateRandomInput
	}{arg1})
	stub := fake.GenerateRandomRequestStub
	fakeReturns := fake.generateRandomRequestReturns
	fake.recordInvocation("GenerateRandomRequest", []interface{}{arg1})
	fake.generateRandomRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateRandomRequestCallCount() int {
	fake.generateRandomRequestMutex.RLock()
	defer fake.generateRandomRequestMutex.RUnlock()
	return len(fake.generateRandomRequestArgsForCall)
}

func (fake *FakeKMSClient) GenerateRandomRequestCalls(stub func(*kms.GenerateRandomInput) (*request.Request, *kms.GenerateRandomOutput)) {
	fake.generateRandomRequestMutex.Lock()
	defer fake.generateRandomRequestMutex.Unlock()
	fake.GenerateRandomRequestStub = stub
}

func (fake *FakeKMSClient) GenerateRandomRequestArgsForCall(i int) *kms.GenerateRandomInput {
	fake.generateRandomRequestMutex.RLock()
	defer fake.generateRandomRequestMutex.RUnlock()
	argsForCall := fake.generateRandomRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GenerateRandomRequestReturns(result1 *request.Request, result2 *kms.GenerateRandomOutput) {
	fake.generateRandomRequestMutex.Lock()
	defer fake.generateRandomRequestMutex.Unlock()
	fake.GenerateRandomRequestStub = nil
	fake.generateRandomRequestReturns = struct {
		result1 *request.Request
		result2 *kms.GenerateRandomOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateRandomRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.GenerateRandomOutput) {
	fake.generateRandomRequestMutex.Lock()
	defer fake.generateRandomRequestMutex.Unlock()
	fake.GenerateRandomRequestStub = nil
	if fake.generateRandomRequestReturnsOnCall == nil {
		fake.generateRandomRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.GenerateRandomOutput
		})
	}
	fake.generateRandomRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.GenerateRandomOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateRandomWithContext(arg1 context.Context, arg2 *kms.GenerateRandomInput, arg3 ...request.Option) (*kms.GenerateRandomOutput, error) {
	fake.generateRandomWithContextMutex.Lock()
	ret, specificReturn := fake.generateRandomWithContextReturnsOnCall[len(fake.generateRandomWithContextArgsForCall)]
	fake.generateRandomWithContextArgsForCall = append(fake.generateRandomWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.GenerateRandomInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GenerateRandomWithContextStub
	fakeReturns := fake.generateRandomWithContextReturns
	fake.recordInvocation("GenerateRandomWithContext", []interface{}{arg1, arg2, arg3})
	fake.generateRandomWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GenerateRandomWithContextCallCount() int {
	fake.generateRandomWithContextMutex.RLock()
	defer fake.generateRandomWithContextMutex.RUnlock()
	return len(fake.generateRandomWithContextArgsForCall)
}

func (fake *FakeKMSClient) GenerateRandomWithContextCalls(stub func(context.Context, *kms.GenerateRandomInput, ...request.Option) (*kms.GenerateRandomOutput, error)) {
	fake.generateRandomWithContextMutex.Lock()
	defer fake.generateRandomWithContextMutex.Unlock()
	fake.GenerateRandomWithContextStub = stub
}

func (fake *FakeKMSClient) GenerateRandomWithContextArgsForCall(i int) (context.Context, *kms.GenerateRandomInput, []request.Option) {
	fake.generateRandomWithContextMutex.RLock()
	defer fake.generateRandomWithContextMutex.RUnlock()
	argsForCall := fake.generateRandomWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) GenerateRandomWithContextReturns(result1 *kms.GenerateRandomOutput, result2 error) {
	fake.generateRandomWithContextMutex.Lock()
	defer fake.generateRandomWithContextMutex.Unlock()
	fake.GenerateRandomWithContextStub = nil
	fake.generateRandomWithContextReturns = struct {
		result1 *kms.GenerateRandomOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GenerateRandomWithContextReturnsOnCall(i int, result1 *kms.GenerateRandomOutput, result2 error) {
	fake.generateRandomWithContextMutex.Lock()
	defer fake.generateRandomWithContextMutex.Unlock()
	fake.GenerateRandomWithContextStub = nil
	if fake.generateRandomWithContextReturnsOnCall == nil {
		fake.generateRandomWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.GenerateRandomOutput
			result2 error
		})
	}
	fake.generateRandomWithContextReturnsOnCall[i] = struct {
		result1 *kms.GenerateRandomOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyPolicy(arg1 *kms.GetKeyPolicyInput) (*kms.GetKeyPolicyOutput, error) {
	fake.getKeyPolicyMutex.Lock()
	ret, specificReturn := fake.getKeyPolicyReturnsOnCall[len(fake.getKeyPolicyArgsForCall)]
	fake.getKeyPolicyArgsForCall = append(fake.getKeyPolicyArgsForCall, struct {
		arg1 *kms.GetKeyPolicyInput
	}{arg1})
	stub := fake.GetKeyPolicyStub
	fakeReturns := fake.getKeyPolicyReturns
	fake.recordInvocation("GetKeyPolicy", []interface{}{arg1})
	fake.getKeyPolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetKeyPolicyCallCount() int {
	fake.getKeyPolicyMutex.RLock()
	defer fake.getKeyPolicyMutex.RUnlock()
	return len(fake.getKeyPolicyArgsForCall)
}

func (fake *FakeKMSClient) GetKeyPolicyCalls(stub func(*kms.GetKeyPolicyInput) (*kms.GetKeyPolicyOutput, error)) {
	fake.getKeyPolicyMutex.Lock()
	defer fake.getKeyPolicyMutex.Unlock()
	fake.GetKeyPolicyStub = stub
}

func (fake *FakeKMSClient) GetKeyPolicyArgsForCall(i int) *kms.GetKeyPolicyInput {
	fake.getKeyPolicyMutex.RLock()
	defer fake.getKeyPolicyMutex.RUnlock()
	argsForCall := fake.getKeyPolicyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GetKeyPolicyReturns(result1 *kms.GetKeyPolicyOutput, result2 error) {
	fake.getKeyPolicyMutex.Lock()
	defer fake.getKeyPolicyMutex.Unlock()
	fake.GetKeyPolicyStub = nil
	fake.getKeyPolicyReturns = struct {
		result1 *kms.GetKeyPolicyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyPolicyReturnsOnCall(i int, result1 *kms.GetKeyPolicyOutput, result2 error) {
	fake.getKeyPolicyMutex.Lock()
	defer fake.getKeyPolicyMutex.Unlock()
	fake.GetKeyPolicyStub = nil
	if fake.getKeyPolicyReturnsOnCall == nil {
		fake.getKeyPolicyReturnsOnCall = make(map[int]struct {
			result1 *kms.GetKeyPolicyOutput
			result2 error
		})
	}
	fake.getKeyPolicyReturnsOnCall[i] = struct {
		result1 *kms.GetKeyPolicyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyPolicyRequest(arg1 *kms.GetKeyPolicyInput) (*request.Request, *kms.GetKeyPolicyOutput) {
	fake.getKeyPolicyRequestMutex.Lock()
	ret, specificReturn := fake.getKeyPolicyRequestReturnsOnCall[len(fake.getKeyPolicyRequestArgsForCall)]
	fake.getKeyPolicyRequestArgsForCall = append(fake.getKeyPolicyRequestArgsForCall, struct {
		arg1 *kms.GetKeyPolicyInput
	}{arg1})
	stub := fake.GetKeyPolicyRequestStub
	fakeReturns := fake.getKeyPolicyRequestReturns
	fake.recordInvocation("GetKeyPolicyRequest", []interface{}{arg1})
	fake.getKeyPolicyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetKeyPolicyRequestCallCount() int {
	fake.getKeyPolicyRequestMutex.RLock()
	defer fake.getKeyPolicyRequestMutex.RUnlock()
	return len(fake.getKeyPolicyRequestArgsForCall)
}

func (fake *FakeKMSClient) GetKeyPolicyRequestCalls(stub func(*kms.GetKeyPolicyInput) (*request.Request, *kms.GetKeyPolicyOutput)) {
	fake.getKeyPolicyRequestMutex.Lock()
	defer fake.getKeyPolicyRequestMutex.Unlock()
	fake.GetKeyPolicyRequestStub = stub
}

func (fake *FakeKMSClient) GetKeyPolicyRequestArgsForCall(i int) *kms.GetKeyPolicyInput {
	fake.getKeyPolicyRequestMutex.RLock()
	defer fake.getKeyPolicyRequestMutex.RUnlock()
	argsForCall := fake.getKeyPolicyRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GetKeyPolicyRequestReturns(result1 *request.Request, result2 *kms.GetKeyPolicyOutput) {
	fake.getKeyPolicyRequestMutex.Lock()
	defer fake.getKeyPolicyRequestMutex.Unlock()
	fake.GetKeyPolicyRequestStub = nil
	fake.getKeyPolicyRequestReturns = struct {
		result1 *request.Request
		result2 *kms.GetKeyPolicyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyPolicyRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.GetKeyPolicyOutput) {
	fake.getKeyPolicyRequestMutex.Lock()
	defer fake.getKeyPolicyRequestMutex.Unlock()
	fake.GetKeyPolicyRequestStub = nil
	if fake.getKeyPolicyRequestReturnsOnCall == nil {
		fake.getKeyPolicyRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.GetKeyPolicyOutput
		})
	}
	fake.getKeyPolicyRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.GetKeyPolicyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyPolicyWithContext(arg1 context.Context, arg2 *kms.GetKeyPolicyInput, arg3 ...request.Option) (*kms.GetKeyPolicyOutput, error) {
	fake.getKeyPolicyWithContextMutex.Lock()
	ret, specificReturn := fake.getKeyPolicyWithContextReturnsOnCall[len(fake.getKeyPolicyWithContextArgsForCall)]
	fake.getKeyPolicyWithContextArgsForCall = append(fake.getKeyPolicyWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.GetKeyPolicyInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GetKeyPolicyWithContextStub
	fakeReturns := fake.getKeyPolicyWithContextReturns
	fake.recordInvocation("GetKeyPolicyWithContext", []interface{}{arg1, arg2, arg3})
	fake.getKeyPolicyWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetKeyPolicyWithContextCallCount() int {
	fake.getKeyPolicyWithContextMutex.RLock()
	defer fake.getKeyPolicyWithContextMutex.RUnlock()
	return len(fake.getKeyPolicyWithContextArgsForCall)
}

func (fake *FakeKMSClient) GetKeyPolicyWithContextCalls(stub func(context.Context, *kms.GetKeyPolicyInput, ...request.Option) (*kms.GetKeyPolicyOutput, error)) {
	fake.getKeyPolicyWithContextMutex.Lock()
	defer fake.getKeyPolicyWithContextMutex.Unlock()
	fake.GetKeyPolicyWithContextStub = stub
}

func (fake *FakeKMSClient) GetKeyPolicyWithContextArgsForCall(i int) (context.Context, *kms.GetKeyPolicyInput, []request.Option) {
	fake.getKeyPolicyWithContextMutex.RLock()
	defer fake.getKeyPolicyWithContextMutex.RUnlock()
	argsForCall := fake.getKeyPolicyWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) GetKeyPolicyWithContextReturns(result1 *kms.GetKeyPolicyOutput, result2 error) {
	fake.getKeyPolicyWithContextMutex.Lock()
	defer fake.getKeyPolicyWithContextMutex.Unlock()
	fake.GetKeyPolicyWithContextStub = nil
	fake.getKeyPolicyWithContextReturns = struct {
		result1 *kms.GetKeyPolicyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyPolicyWithContextReturnsOnCall(i int, result1 *kms.GetKeyPolicyOutput, result2 error) {
	fake.getKeyPolicyWithContextMutex.Lock()
	defer fake.getKeyPolicyWithContextMutex.Unlock()
	fake.GetKeyPolicyWithContextStub = nil
	if fake.getKeyPolicyWithContextReturnsOnCall == nil {
		fake.getKeyPolicyWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.GetKeyPolicyOutput
			result2 error
		})
	}
	fake.getKeyPolicyWithContextReturnsOnCall[i] = struct {
		result1 *kms.GetKeyPolicyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyRotationStatus(arg1 *kms.GetKeyRotationStatusInput) (*kms.GetKeyRotationStatusOutput, error) {
	fake.getKeyRotationStatusMutex.Lock()
	ret, specificReturn := fake.getKeyRotationStatusReturnsOnCall[len(fake.getKeyRotationStatusArgsForCall)]
	fake.getKeyRotationStatusArgsForCall = append(fake.getKeyRotationStatusArgsForCall, struct {
		arg1 *kms.GetKeyRotationStatusInput
	}{arg1})
	stub := fake.GetKeyRotationStatusStub
	fakeReturns := fake.getKeyRotationStatusReturns
	fake.recordInvocation("GetKeyRotationStatus", []interface{}{arg1})
	fake.getKeyRotationStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetKeyRotationStatusCallCount() int {
	fake.getKeyRotationStatusMutex.RLock()
	defer fake.getKeyRotationStatusMutex.RUnlock()
	return len(fake.getKeyRotationStatusArgsForCall)
}

func (fake *FakeKMSClient) GetKeyRotationStatusCalls(stub func(*kms.GetKeyRotationStatusInput) (*kms.GetKeyRotationStatusOutput, error)) {
	fake.getKeyRotationStatusMutex.Lock()
	defer fake.getKeyRotationStatusMutex.Unlock()
	fake.GetKeyRotationStatusStub = stub
}

func (fake *FakeKMSClient) GetKeyRotationStatusArgsForCall(i int) *kms.GetKeyRotationStatusInput {
	fake.getKeyRotationStatusMutex.RLock()
	defer fake.getKeyRotationStatusMutex.RUnlock()
	argsForCall := fake.getKeyRotationStatusArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GetKeyRotationStatusReturns(result1 *kms.GetKeyRotationStatusOutput, result2 error) {
	fake.getKeyRotationStatusMutex.Lock()
	defer fake.getKeyRotationStatusMutex.Unlock()
	fake.GetKeyRotationStatusStub = nil
	fake.getKeyRotationStatusReturns = struct {
		result1 *kms.GetKeyRotationStatusOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyRotationStatusReturnsOnCall(i int, result1 *kms.GetKeyRotationStatusOutput, result2 error) {
	fake.getKeyRotationStatusMutex.Lock()
	defer fake.getKeyRotationStatusMutex.Unlock()
	fake.GetKeyRotationStatusStub = nil
	if fake.getKeyRotationStatusReturnsOnCall == nil {
		fake.getKeyRotationStatusReturnsOnCall = make(map[int]struct {
			result1 *kms.GetKeyRotationStatusOutput
			result2 error
		})
	}
	fake.getKeyRotationStatusReturnsOnCall[i] = struct {
		result1 *kms.GetKeyRotationStatusOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyRotationStatusRequest(arg1 *kms.GetKeyRotationStatusInput) (*request.Request, *kms.GetKeyRotationStatusOutput) {
	fake.getKeyRotationStatusRequestMutex.Lock()
	ret, specificReturn := fake.getKeyRotationStatusRequestReturnsOnCall[len(fake.getKeyRotationStatusRequestArgsForCall)]
	fake.getKeyRotationStatusRequestArgsForCall = append(fake.getKeyRotationStatusRequestArgsForCall, struct {
		arg1 *kms.GetKeyRotationStatusInput
	}{arg1})
	stub := fake.GetKeyRotationStatusRequestStub
	fakeReturns := fake.getKeyRotationStatusRequestReturns
	fake.recordInvocation("GetKeyRotationStatusRequest", []interface{}{arg1})
	fake.getKeyRotationStatusRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetKeyRotationStatusRequestCallCount() int {
	fake.getKeyRotationStatusRequestMutex.RLock()
	defer fake.getKeyRotationStatusRequestMutex.RUnlock()
	return len(fake.getKeyRotationStatusRequestArgsForCall)
}

func (fake *FakeKMSClient) GetKeyRotationStatusRequestCalls(stub func(*kms.GetKeyRotationStatusInput) (*request.Request, *kms.GetKeyRotationStatusOutput)) {
	fake.getKeyRotationStatusRequestMutex.Lock()
	defer fake.getKeyRotationStatusRequestMutex.Unlock()
	fake.GetKeyRotationStatusRequestStub = stub
}

func (fake *FakeKMSClient) GetKeyRotationStatusRequestArgsForCall(i int) *kms.GetKeyRotationStatusInput {
	fake.getKeyRotationStatusRequestMutex.RLock()
	defer fake.getKeyRotationStatusRequestMutex.RUnlock()
	argsForCall := fake.getKeyRotationStatusRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GetKeyRotationStatusRequestReturns(result1 *request.Request, result2 *kms.GetKeyRotationStatusOutput) {
	fake.getKeyRotationStatusRequestMutex.Lock()
	defer fake.getKeyRotationStatusRequestMutex.Unlock()
	fake.GetKeyRotationStatusRequestStub = nil
	fake.getKeyRotationStatusRequestReturns = struct {
		result1 *request.Request
		result2 *kms.GetKeyRotationStatusOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyRotationStatusRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.GetKeyRotationStatusOutput) {
	fake.getKeyRotationStatusRequestMutex.Lock()
	defer fake.getKeyRotationStatusRequestMutex.Unlock()
	fake.GetKeyRotationStatusRequestStub = nil
	if fake.getKeyRotationStatusRequestReturnsOnCall == nil {
		fake.getKeyRotationStatusRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.GetKeyRotationStatusOutput
		})
	}
	fake.getKeyRotationStatusRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.GetKeyRotationStatusOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyRotationStatusWithContext(arg1 context.Context, arg2 *kms.GetKeyRotationStatusInput, arg3 ...request.Option) (*kms.GetKeyRotationStatusOutput, error) {
	fake.getKeyRotationStatusWithContextMutex.Lock()
	ret, specificReturn := fake.getKeyRotationStatusWithContextReturnsOnCall[len(fake.getKeyRotationStatusWithContextArgsForCall)]
	fake.getKeyRotationStatusWithContextArgsForCall = append(fake.getKeyRotationStatusWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.GetKeyRotationStatusInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GetKeyRotationStatusWithContextStub
	fakeReturns := fake.getKeyRotationStatusWithContextReturns
	fake.recordInvocation("GetKeyRotationStatusWithContext", []interface{}{arg1, arg2, arg3})
	fake.getKeyRotationStatusWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetKeyRotationStatusWithContextCallCount() int {
	fake.getKeyRotationStatusWithContextMutex.RLock()
	defer fake.getKeyRotationStatusWithContextMutex.RUnlock()
	return len(fake.getKeyRotationStatusWithContextArgsForCall)
}

func (fake *FakeKMSClient) GetKeyRotationStatusWithContextCalls(stub func(context.Context, *kms.GetKeyRotationStatusInput, ...request.Option) (*kms.GetKeyRotationStatusOutput, error)) {
	fake.getKeyRotationStatusWithContextMutex.Lock()
	defer fake.getKeyRotationStatusWithContextMutex.Unlock()
	fake.GetKeyRotationStatusWithContextStub = stub
}

func (fake *FakeKMSClient) GetKeyRotationStatusWithContextArgsForCall(i int) (context.Context, *kms.GetKeyRotationStatusInput, []request.Option) {
	fake.getKeyRotationStatusWithContextMutex.RLock()
	defer fake.getKeyRotationStatusWithContextMutex.RUnlock()
	argsForCall := fake.getKeyRotationStatusWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) GetKeyRotationStatusWithContextReturns(result1 *kms.GetKeyRotationStatusOutput, result2 error) {
	fake.getKeyRotationStatusWithContextMutex.Lock()
	defer fake.getKeyRotationStatusWithContextMutex.Unlock()
	fake.GetKeyRotationStatusWithContextStub = nil
	fake.getKeyRotationStatusWithContextReturns = struct {
		result1 *kms.GetKeyRotationStatusOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetKeyRotationStatusWithContextReturnsOnCall(i int, result1 *kms.GetKeyRotationStatusOutput, result2 error) {
	fake.getKeyRotationStatusWithContextMutex.Lock()
	defer fake.getKeyRotationStatusWithContextMutex.Unlock()
	fake.GetKeyRotationStatusWithContextStub = nil
	if fake.getKeyRotationStatusWithContextReturnsOnCall == nil {
		fake.getKeyRotationStatusWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.GetKeyRotationStatusOutput
			result2 error
		})
	}
	fake.getKeyRotationStatusWithContextReturnsOnCall[i] = struct {
		result1 *kms.GetKeyRotationStatusOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetParametersForImport(arg1 *kms.GetParametersForImportInput) (*kms.GetParametersForImportOutput, error) {
	fake.getParametersForImportMutex.Lock()
	ret, specificReturn := fake.getParametersForImportReturnsOnCall[len(fake.getParametersForImportArgsForCall)]
	fake.getParametersForImportArgsForCall = append(fake.getParametersForImportArgsForCall, struct {
		arg1 *kms.GetParametersForImportInput
	}{arg1})
	stub := fake.GetParametersForImportStub
	fakeReturns := fake.getParametersForImportReturns
	fake.recordInvocation("GetParametersForImport", []interface{}{arg1})
	fake.getParametersForImportMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetParametersForImportCallCount() int {
	fake.getParametersForImportMutex.RLock()
	defer fake.getParametersForImportMutex.RUnlock()
	return len(fake.getParametersForImportArgsForCall)
}

func (fake *FakeKMSClient) GetParametersForImportCalls(stub func(*kms.GetParametersForImportInput) (*kms.GetParametersForImportOutput, error)) {
	fake.getParametersForImportMutex.Lock()
	defer fake.getParametersForImportMutex.Unlock()
	fake.GetParametersForImportStub = stub
}

func (fake *FakeKMSClient) GetParametersForImportArgsForCall(i int) *kms.GetParametersForImportInput {
	fake.getParametersForImportMutex.RLock()
	defer fake.getParametersForImportMutex.RUnlock()
	argsForCall := fake.getParametersForImportArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GetParametersForImportReturns(result1 *kms.GetParametersForImportOutput, result2 error) {
	fake.getParametersForImportMutex.Lock()
	defer fake.getParametersForImportMutex.Unlock()
	fake.GetParametersForImportStub = nil
	fake.getParametersForImportReturns = struct {
		result1 *kms.GetParametersForImportOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetParametersForImportReturnsOnCall(i int, result1 *kms.GetParametersForImportOutput, result2 error) {
	fake.getParametersForImportMutex.Lock()
	defer fake.getParametersForImportMutex.Unlock()
	fake.GetParametersForImportStub = nil
	if fake.getParametersForImportReturnsOnCall == nil {
		fake.getParametersForImportReturnsOnCall = make(map[int]struct {
			result1 *kms.GetParametersForImportOutput
			result2 error
		})
	}
	fake.getParametersForImportReturnsOnCall[i] = struct {
		result1 *kms.GetParametersForImportOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetParametersForImportRequest(arg1 *kms.GetParametersForImportInput) (*request.Request, *kms.GetParametersForImportOutput) {
	fake.getParametersForImportRequestMutex.Lock()
	ret, specificReturn := fake.getParametersForImportRequestReturnsOnCall[len(fake.getParametersForImportRequestArgsForCall)]
	fake.getParametersForImportRequestArgsForCall = append(fake.getParametersForImportRequestArgsForCall, struct {
		arg1 *kms.GetParametersForImportInput
	}{arg1})
	stub := fake.GetParametersForImportRequestStub
	fakeReturns := fake.getParametersForImportRequestReturns
	fake.recordInvocation("GetParametersForImportRequest", []interface{}{arg1})
	fake.getParametersForImportRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetParametersForImportRequestCallCount() int {
	fake.getParametersForImportRequestMutex.RLock()
	defer fake.getParametersForImportRequestMutex.RUnlock()
	return len(fake.getParametersForImportRequestArgsForCall)
}

func (fake *FakeKMSClient) GetParametersForImportRequestCalls(stub func(*kms.GetParametersForImportInput) (*request.Request, *kms.GetParametersForImportOutput)) {
	fake.getParametersForImportRequestMutex.Lock()
	defer fake.getParametersForImportRequestMutex.Unlock()
	fake.GetParametersForImportRequestStub = stub
}

func (fake *FakeKMSClient) GetParametersForImportRequestArgsForCall(i int) *kms.GetParametersForImportInput {
	fake.getParametersForImportRequestMutex.RLock()
	defer fake.getParametersForImportRequestMutex.RUnlock()
	argsForCall := fake.getParametersForImportRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GetParametersForImportRequestReturns(result1 *request.Request, result2 *kms.GetParametersForImportOutput) {
	fake.getParametersForImportRequestMutex.Lock()
	defer fake.getParametersForImportRequestMutex.Unlock()
	fake.GetParametersForImportRequestStub = nil
	fake.getParametersForImportRequestReturns = struct {
		result1 *request.Request
		result2 *kms.GetParametersForImportOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GetParametersForImportRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.GetParametersForImportOutput) {
	fake.getParametersForImportRequestMutex.Lock()
	defer fake.getParametersForImportRequestMutex.Unlock()
	fake.GetParametersForImportRequestStub = nil
	if fake.getParametersForImportRequestReturnsOnCall == nil {
		fake.getParametersForImportRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.GetParametersForImportOutput
		})
	}
	fake.getParametersForImportRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.GetParametersForImportOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GetParametersForImportWithContext(arg1 context.Context, arg2 *kms.GetParametersForImportInput, arg3 ...request.Option) (*kms.GetParametersForImportOutput, error) {
	fake.getParametersForImportWithContextMutex.Lock()
	ret, specificReturn := fake.getParametersForImportWithContextReturnsOnCall[len(fake.getParametersForImportWithContextArgsForCall)]
	fake.getParametersForImportWithContextArgsForCall = append(fake.getParametersForImportWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.GetParametersForImportInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GetParametersForImportWithContextStub
	fakeReturns := fake.getParametersForImportWithContextReturns
	fake.recordInvocation("GetParametersForImportWithContext", []interface{}{arg1, arg2, arg3})
	fake.getParametersForImportWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetParametersForImportWithContextCallCount() int {
	fake.getParametersForImportWithContextMutex.RLock()
	defer fake.getParametersForImportWithContextMutex.RUnlock()
	return len(fake.getParametersForImportWithContextArgsForCall)
}

func (fake *FakeKMSClient) GetParametersForImportWithContextCalls(stub func(context.Context, *kms.GetParametersForImportInput, ...request.Option) (*kms.GetParametersForImportOutput, error)) {
	fake.getParametersForImportWithContextMutex.Lock()
	defer fake.getParametersForImportWithContextMutex.Unlock()
	fake.GetParametersForImportWithContextStub = stub
}

func (fake *FakeKMSClient) GetParametersForImportWithContextArgsForCall(i int) (context.Context, *kms.GetParametersForImportInput, []request.Option) {
	fake.getParametersForImportWithContextMutex.RLock()
	defer fake.getParametersForImportWithContextMutex.RUnlock()
	argsForCall := fake.getParametersForImportWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) GetParametersForImportWithContextReturns(result1 *kms.GetParametersForImportOutput, result2 error) {
	fake.getParametersForImportWithContextMutex.Lock()
	defer fake.getParametersForImportWithContextMutex.Unlock()
	fake.GetParametersForImportWithContextStub = nil
	fake.getParametersForImportWithContextReturns = struct {
		result1 *kms.GetParametersForImportOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetParametersForImportWithContextReturnsOnCall(i int, result1 *kms.GetParametersForImportOutput, result2 error) {
	fake.getParametersForImportWithContextMutex.Lock()
	defer fake.getParametersForImportWithContextMutex.Unlock()
	fake.GetParametersForImportWithContextStub = nil
	if fake.getParametersForImportWithContextReturnsOnCall == nil {
		fake.getParametersForImportWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.GetParametersForImportOutput
			result2 error
		})
	}
	fake.getParametersForImportWithContextReturnsOnCall[i] = struct {
		result1 *kms.GetParametersForImportOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetPublicKey(arg1 *kms.GetPublicKeyInput) (*kms.GetPublicKeyOutput, error) {
	fake.getPublicKeyMutex.Lock()
	ret, specificReturn := fake.getPublicKeyReturnsOnCall[len(fake.getPublicKeyArgsForCall)]
	fake.getPublicKeyArgsForCall = append(fake.getPublicKeyArgsForCall, struct {
		arg1 *kms.GetPublicKeyInput
	}{arg1})
	stub := fake.GetPublicKeyStub
	fakeReturns := fake.getPublicKeyReturns
	fake.recordInvocation("GetPublicKey", []interface{}{arg1})
	fake.getPublicKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetPublicKeyCallCount() int {
	fake.getPublicKeyMutex.RLock()
	defer fake.getPublicKeyMutex.RUnlock()
	return len(fake.getPublicKeyArgsForCall)
}

func (fake *FakeKMSClient) GetPublicKeyCalls(stub func(*kms.GetPublicKeyInput) (*kms.GetPublicKeyOutput, error)) {
	fake.getPublicKeyMutex.Lock()
	defer fake.getPublicKeyMutex.Unlock()
	fake.GetPublicKeyStub = stub
}

func (fake *FakeKMSClient) GetPublicKeyArgsForCall(i int) *kms.GetPublicKeyInput {
	fake.getPublicKeyMutex.RLock()
	defer fake.getPublicKeyMutex.RUnlock()
	argsForCall := fake.getPublicKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GetPublicKeyReturns(result1 *kms.GetPublicKeyOutput, result2 error) {
	fake.getPublicKeyMutex.Lock()
	defer fake.getPublicKeyMutex.Unlock()
	fake.GetPublicKeyStub = nil
	fake.getPublicKeyReturns = struct {
		result1 *kms.GetPublicKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetPublicKeyReturnsOnCall(i int, result1 *kms.GetPublicKeyOutput, result2 error) {
	fake.getPublicKeyMutex.Lock()
	defer fake.getPublicKeyMutex.Unlock()
	fake.GetPublicKeyStub = nil
	if fake.getPublicKeyReturnsOnCall == nil {
		fake.getPublicKeyReturnsOnCall = make(map[int]struct {
			result1 *kms.GetPublicKeyOutput
			result2 error
		})
	}
	fake.getPublicKeyReturnsOnCall[i] = struct {
		result1 *kms.GetPublicKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetPublicKeyRequest(arg1 *kms.GetPublicKeyInput) (*request.Request, *kms.GetPublicKeyOutput) {
	fake.getPublicKeyRequestMutex.Lock()
	ret, specificReturn := fake.getPublicKeyRequestReturnsOnCall[len(fake.getPublicKeyRequestArgsForCall)]
	fake.getPublicKeyRequestArgsForCall = append(fake.getPublicKeyRequestArgsForCall, struct {
		arg1 *kms.GetPublicKeyInput
	}{arg1})
	stub := fake.GetPublicKeyRequestStub
	fakeReturns := fake.getPublicKeyRequestReturns
	fake.recordInvocation("GetPublicKeyRequest", []interface{}{arg1})
	fake.getPublicKeyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetPublicKeyRequestCallCount() int {
	fake.getPublicKeyRequestMutex.RLock()
	defer fake.getPublicKeyRequestMutex.RUnlock()
	return len(fake.getPublicKeyRequestArgsForCall)
}

func (fake *FakeKMSClient) GetPublicKeyRequestCalls(stub func(*kms.GetPublicKeyInput) (*request.Request, *kms.GetPublicKeyOutput)) {
	fake.getPublicKeyRequestMutex.Lock()
	defer fake.getPublicKeyRequestMutex.Unlock()
	fake.GetPublicKeyRequestStub = stub
}

func (fake *FakeKMSClient) GetPublicKeyRequestArgsForCall(i int) *kms.GetPublicKeyInput {
	fake.getPublicKeyRequestMutex.RLock()
	defer fake.getPublicKeyRequestMutex.RUnlock()
	argsForCall := fake.getPublicKeyRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) GetPublicKeyRequestReturns(result1 *request.Request, result2 *kms.GetPublicKeyOutput) {
	fake.getPublicKeyRequestMutex.Lock()
	defer fake.getPublicKeyRequestMutex.Unlock()
	fake.GetPublicKeyRequestStub = nil
	fake.getPublicKeyRequestReturns = struct {
		result1 *request.Request
		result2 *kms.GetPublicKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GetPublicKeyRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.GetPublicKeyOutput) {
	fake.getPublicKeyRequestMutex.Lock()
	defer fake.getPublicKeyRequestMutex.Unlock()
	fake.GetPublicKeyRequestStub = nil
	if fake.getPublicKeyRequestReturnsOnCall == nil {
		fake.getPublicKeyRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.GetPublicKeyOutput
		})
	}
	fake.getPublicKeyRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.GetPublicKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) GetPublicKeyWithContext(arg1 context.Context, arg2 *kms.GetPublicKeyInput, arg3 ...request.Option) (*kms.GetPublicKeyOutput, error) {
	fake.getPublicKeyWithContextMutex.Lock()
	ret, specificReturn := fake.getPublicKeyWithContextReturnsOnCall[len(fake.getPublicKeyWithContextArgsForCall)]
	fake.getPublicKeyWithContextArgsForCall = append(fake.getPublicKeyWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.GetPublicKeyInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GetPublicKeyWithContextStub
	fakeReturns := fake.getPublicKeyWithContextReturns
	fake.recordInvocation("GetPublicKeyWithContext", []interface{}{arg1, arg2, arg3})
	fake.getPublicKeyWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) GetPublicKeyWithContextCallCount() int {
	fake.getPublicKeyWithContextMutex.RLock()
	defer fake.getPublicKeyWithContextMutex.RUnlock()
	return len(fake.getPublicKeyWithContextArgsForCall)
}

func (fake *FakeKMSClient) GetPublicKeyWithContextCalls(stub func(context.Context, *kms.GetPublicKeyInput, ...request.Option) (*kms.GetPublicKeyOutput, error)) {
	fake.getPublicKeyWithContextMutex.Lock()
	defer fake.getPublicKeyWithContextMutex.Unlock()
	fake.GetPublicKeyWithContextStub = stub
}

func (fake *FakeKMSClient) GetPublicKeyWithContextArgsForCall(i int) (context.Context, *kms.GetPublicKeyInput, []request.Option) {
	fake.getPublicKeyWithContextMutex.RLock()
	defer fake.getPublicKeyWithContextMutex.RUnlock()
	argsForCall := fake.getPublicKeyWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) GetPublicKeyWithContextReturns(result1 *kms.GetPublicKeyOutput, result2 error) {
	fake.getPublicKeyWithContextMutex.Lock()
	defer fake.getPublicKeyWithContextMutex.Unlock()
	fake.GetPublicKeyWithContextStub = nil
	fake.getPublicKeyWithContextReturns = struct {
		result1 *kms.GetPublicKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) GetPublicKeyWithContextReturnsOnCall(i int, result1 *kms.GetPublicKeyOutput, result2 error) {
	fake.getPublicKeyWithContextMutex.Lock()
	defer fake.getPublicKeyWithContextMutex.Unlock()
	fake.GetPublicKeyWithContextStub = nil
	if fake.getPublicKeyWithContextReturnsOnCall == nil {
		fake.getPublicKeyWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.GetPublicKeyOutput
			result2 error
		})
	}
	fake.getPublicKeyWithContextReturnsOnCall[i] = struct {
		result1 *kms.GetPublicKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ImportKeyMaterial(arg1 *kms.ImportKeyMaterialInput) (*kms.ImportKeyMaterialOutput, error) {
	fake.importKeyMaterialMutex.Lock()
	ret, specificReturn := fake.importKeyMaterialReturnsOnCall[len(fake.importKeyMaterialArgsForCall)]
	fake.importKeyMaterialArgsForCall = append(fake.importKeyMaterialArgsForCall, struct {
		arg1 *kms.ImportKeyMaterialInput
	}{arg1})
	stub := fake.ImportKeyMaterialStub
	fakeReturns := fake.importKeyMaterialReturns
	fake.recordInvocation("ImportKeyMaterial", []interface{}{arg1})
	fake.importKeyMaterialMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ImportKeyMaterialCallCount() int {
	fake.importKeyMaterialMutex.RLock()
	defer fake.importKeyMaterialMutex.RUnlock()
	return len(fake.importKeyMaterialArgsForCall)
}

func (fake *FakeKMSClient) ImportKeyMaterialCalls(stub func(*kms.ImportKeyMaterialInput) (*kms.ImportKeyMaterialOutput, error)) {
	fake.importKeyMaterialMutex.Lock()
	defer fake.importKeyMaterialMutex.Unlock()
	fake.ImportKeyMaterialStub = stub
}

func (fake *FakeKMSClient) ImportKeyMaterialArgsForCall(i int) *kms.ImportKeyMaterialInput {
	fake.importKeyMaterialMutex.RLock()
	defer fake.importKeyMaterialMutex.RUnlock()
	argsForCall := fake.importKeyMaterialArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ImportKeyMaterialReturns(result1 *kms.ImportKeyMaterialOutput, result2 error) {
	fake.importKeyMaterialMutex.Lock()
	defer fake.importKeyMaterialMutex.Unlock()
	fake.ImportKeyMaterialStub = nil
	fake.importKeyMaterialReturns = struct {
		result1 *kms.ImportKeyMaterialOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ImportKeyMaterialReturnsOnCall(i int, result1 *kms.ImportKeyMaterialOutput, result2 error) {
	fake.importKeyMaterialMutex.Lock()
	defer fake.importKeyMaterialMutex.Unlock()
	fake.ImportKeyMaterialStub = nil
	if fake.importKeyMaterialReturnsOnCall == nil {
		fake.importKeyMaterialReturnsOnCall = make(map[int]struct {
			result1 *kms.ImportKeyMaterialOutput
			result2 error
		})
	}
	fake.importKeyMaterialReturnsOnCall[i] = struct {
		result1 *kms.ImportKeyMaterialOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ImportKeyMaterialRequest(arg1 *kms.ImportKeyMaterialInput) (*request.Request, *kms.ImportKeyMaterialOutput) {
	fake.importKeyMaterialRequestMutex.Lock()
	ret, specificReturn := fake.importKeyMaterialRequestReturnsOnCall[len(fake.importKeyMaterialRequestArgsForCall)]
	fake.importKeyMaterialRequestArgsForCall = append(fake.importKeyMaterialRequestArgsForCall, struct {
		arg1 *kms.ImportKeyMaterialInput
	}{arg1})
	stub := fake.ImportKeyMaterialRequestStub
	fakeReturns := fake.importKeyMaterialRequestReturns
	fake.recordInvocation("ImportKeyMaterialRequest", []interface{}{arg1})
	fake.importKeyMaterialRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ImportKeyMaterialRequestCallCount() int {
	fake.importKeyMaterialRequestMutex.RLock()
	defer fake.importKeyMaterialRequestMutex.RUnlock()
	return len(fake.importKeyMaterialRequestArgsForCall)
}

func (fake *FakeKMSClient) ImportKeyMaterialRequestCalls(stub func(*kms.ImportKeyMaterialInput) (*request.Request, *kms.ImportKeyMaterialOutput)) {
	fake.importKeyMaterialRequestMutex.Lock()
	defer fake.importKeyMaterialRequestMutex.Unlock()
	fake.ImportKeyMaterialRequestStub = stub
}

func (fake *FakeKMSClient) ImportKeyMaterialRequestArgsForCall(i int) *kms.ImportKeyMaterialInput {
	fake.importKeyMaterialRequestMutex.RLock()
	defer fake.importKeyMaterialRequestMutex.RUnlock()
	argsForCall := fake.importKeyMaterialRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ImportKeyMaterialRequestReturns(result1 *request.Request, result2 *kms.ImportKeyMaterialOutput) {
	fake.importKeyMaterialRequestMutex.Lock()
	defer fake.importKeyMaterialRequestMutex.Unlock()
	fake.ImportKeyMaterialRequestStub = nil
	fake.importKeyMaterialRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ImportKeyMaterialOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ImportKeyMaterialRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ImportKeyMaterialOutput) {
	fake.importKeyMaterialRequestMutex.Lock()
	defer fake.importKeyMaterialRequestMutex.Unlock()
	fake.ImportKeyMaterialRequestStub = nil
	if fake.importKeyMaterialRequestReturnsOnCall == nil {
		fake.importKeyMaterialRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ImportKeyMaterialOutput
		})
	}
	fake.importKeyMaterialRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ImportKeyMaterialOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ImportKeyMaterialWithContext(arg1 context.Context, arg2 *kms.ImportKeyMaterialInput, arg3 ...request.Option) (*kms.ImportKeyMaterialOutput, error) {
	fake.importKeyMaterialWithContextMutex.Lock()
	ret, specificReturn := fake.importKeyMaterialWithContextReturnsOnCall[len(fake.importKeyMaterialWithContextArgsForCall)]
	fake.importKeyMaterialWithContextArgsForCall = append(fake.importKeyMaterialWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ImportKeyMaterialInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ImportKeyMaterialWithContextStub
	fakeReturns := fake.importKeyMaterialWithContextReturns
	fake.recordInvocation("ImportKeyMaterialWithContext", []interface{}{arg1, arg2, arg3})
	fake.importKeyMaterialWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ImportKeyMaterialWithContextCallCount() int {
	fake.importKeyMaterialWithContextMutex.RLock()
	defer fake.importKeyMaterialWithContextMutex.RUnlock()
	return len(fake.importKeyMaterialWithContextArgsForCall)
}

func (fake *FakeKMSClient) ImportKeyMaterialWithContextCalls(stub func(context.Context, *kms.ImportKeyMaterialInput, ...request.Option) (*kms.ImportKeyMaterialOutput, error)) {
	fake.importKeyMaterialWithContextMutex.Lock()
	defer fake.importKeyMaterialWithContextMutex.Unlock()
	fake.ImportKeyMaterialWithContextStub = stub
}

func (fake *FakeKMSClient) ImportKeyMaterialWithContextArgsForCall(i int) (context.Context, *kms.ImportKeyMaterialInput, []request.Option) {
	fake.importKeyMaterialWithContextMutex.RLock()
	defer fake.importKeyMaterialWithContextMutex.RUnlock()
	argsForCall := fake.importKeyMaterialWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ImportKeyMaterialWithContextReturns(result1 *kms.ImportKeyMaterialOutput, result2 error) {
	fake.importKeyMaterialWithContextMutex.Lock()
	defer fake.importKeyMaterialWithContextMutex.Unlock()
	fake.ImportKeyMaterialWithContextStub = nil
	fake.importKeyMaterialWithContextReturns = struct {
		result1 *kms.ImportKeyMaterialOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ImportKeyMaterialWithContextReturnsOnCall(i int, result1 *kms.ImportKeyMaterialOutput, result2 error) {
	fake.importKeyMaterialWithContextMutex.Lock()
	defer fake.importKeyMaterialWithContextMutex.Unlock()
	fake.ImportKeyMaterialWithContextStub = nil
	if fake.importKeyMaterialWithContextReturnsOnCall == nil {
		fake.importKeyMaterialWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ImportKeyMaterialOutput
			result2 error
		})
	}
	fake.importKeyMaterialWithContextReturnsOnCall[i] = struct {
		result1 *kms.ImportKeyMaterialOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListAliases(arg1 *kms.ListAliasesInput) (*kms.ListAliasesOutput, error) {
	fake.listAliasesMutex.Lock()
	ret, specificReturn := fake.listAliasesReturnsOnCall[len(fake.listAliasesArgsForCall)]
	fake.listAliasesArgsForCall = append(fake.listAliasesArgsForCall, struct {
		arg1 *kms.ListAliasesInput
	}{arg1})
	stub := fake.ListAliasesStub
	fakeReturns := fake.listAliasesReturns
	fake.recordInvocation("ListAliases", []interface{}{arg1})
	fake.listAliasesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListAliasesCallCount() int {
	fake.listAliasesMutex.RLock()
	defer fake.listAliasesMutex.RUnlock()
	return len(fake.listAliasesArgsForCall)
}

func (fake *FakeKMSClient) ListAliasesCalls(stub func(*kms.ListAliasesInput) (*kms.ListAliasesOutput, error)) {
	fake.listAliasesMutex.Lock()
	defer fake.listAliasesMutex.Unlock()
	fake.ListAliasesStub = stub
}

func (fake *FakeKMSClient) ListAliasesArgsForCall(i int) *kms.ListAliasesInput {
	fake.listAliasesMutex.RLock()
	defer fake.listAliasesMutex.RUnlock()
	argsForCall := fake.listAliasesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListAliasesReturns(result1 *kms.ListAliasesOutput, result2 error) {
	fake.listAliasesMutex.Lock()
	defer fake.listAliasesMutex.Unlock()
	fake.ListAliasesStub = nil
	fake.listAliasesReturns = struct {
		result1 *kms.ListAliasesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListAliasesReturnsOnCall(i int, result1 *kms.ListAliasesOutput, result2 error) {
	fake.listAliasesMutex.Lock()
	defer fake.listAliasesMutex.Unlock()
	fake.ListAliasesStub = nil
	if fake.listAliasesReturnsOnCall == nil {
		fake.listAliasesReturnsOnCall = make(map[int]struct {
			result1 *kms.ListAliasesOutput
			result2 error
		})
	}
	fake.listAliasesReturnsOnCall[i] = struct {
		result1 *kms.ListAliasesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListAliasesPages(arg1 *kms.ListAliasesInput, arg2 func(*kms.ListAliasesOutput, bool) bool) error {
	fake.listAliasesPagesMutex.Lock()
	ret, specificReturn := fake.listAliasesPagesReturnsOnCall[len(fake.listAliasesPagesArgsForCall)]
	fake.listAliasesPagesArgsForCall = append(fake.listAliasesPagesArgsForCall, struct {
		arg1 *kms.ListAliasesInput
		arg2 func(*kms.ListAliasesOutput, bool) bool
	}{arg1, arg2})
	stub := fake.ListAliasesPagesStub
	fakeReturns := fake.listAliasesPagesReturns
	fake.recordInvocation("ListAliasesPages", []interface{}{arg1, arg2})
	fake.listAliasesPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKMSClient) ListAliasesPagesCallCount() int {
	fake.listAliasesPagesMutex.RLock()
	defer fake.listAliasesPagesMutex.RUnlock()
	return len(fake.listAliasesPagesArgsForCall)
}

func (fake *FakeKMSClient) ListAliasesPagesCalls(stub func(*kms.ListAliasesInput, func(*kms.ListAliasesOutput, bool) bool) error) {
	fake.listAliasesPagesMutex.Lock()
	defer fake.listAliasesPagesMutex.Unlock()
	fake.ListAliasesPagesStub = stub
}

func (fake *FakeKMSClient) ListAliasesPagesArgsForCall(i int) (*kms.ListAliasesInput, func(*kms.ListAliasesOutput, bool) bool) {
	fake.listAliasesPagesMutex.RLock()
	defer fake.listAliasesPagesMutex.RUnlock()
	argsForCall := fake.listAliasesPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKMSClient) ListAliasesPagesReturns(result1 error) {
	fake.listAliasesPagesMutex.Lock()
	defer fake.listAliasesPagesMutex.Unlock()
	fake.ListAliasesPagesStub = nil
	fake.listAliasesPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListAliasesPagesReturnsOnCall(i int, result1 error) {
	fake.listAliasesPagesMutex.Lock()
	defer fake.listAliasesPagesMutex.Unlock()
	fake.ListAliasesPagesStub = nil
	if fake.listAliasesPagesReturnsOnCall == nil {
		fake.listAliasesPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listAliasesPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListAliasesPagesWithContext(arg1 context.Context, arg2 *kms.ListAliasesInput, arg3 func(*kms.ListAliasesOutput, bool) bool, arg4 ...request.Option) error {
	fake.listAliasesPagesWithContextMutex.Lock()
	ret, specificReturn := fake.listAliasesPagesWithContextReturnsOnCall[len(fake.listAliasesPagesWithContextArgsForCall)]
	fake.listAliasesPagesWithContextArgsForCall = append(fake.listAliasesPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ListAliasesInput
		arg3 func(*kms.ListAliasesOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListAliasesPagesWithContextStub
	fakeReturns := fake.listAliasesPagesWithContextReturns
	fake.recordInvocation("ListAliasesPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.listAliasesPagesWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKMSClient) ListAliasesPagesWithContextCallCount() int {
	fake.listAliasesPagesWithContextMutex.RLock()
	defer fake.listAliasesPagesWithContextMutex.RUnlock()
	return len(fake.listAliasesPagesWithContextArgsForCall)
}

func (fake *FakeKMSClient) ListAliasesPagesWithContextCalls(stub func(context.Context, *kms.ListAliasesInput, func(*kms.ListAliasesOutput, bool) bool, ...request.Option) error) {
	fake.listAliasesPagesWithContextMutex.Lock()
	defer fake.listAliasesPagesWithContextMutex.Unlock()
	fake.ListAliasesPagesWithContextStub = stub
}

func (fake *FakeKMSClient) ListAliasesPagesWithContextArgsForCall(i int) (context.Context, *kms.ListAliasesInput, func(*kms.ListAliasesOutput, bool) bool, []request.Option) {
	fake.listAliasesPagesWithContextMutex.RLock()
	defer fake.listAliasesPagesWithContextMutex.RUnlock()
	argsForCall := fake.listAliasesPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeKMSClient) ListAliasesPagesWithContextReturns(result1 error) {
	fake.listAliasesPagesWithContextMutex.Lock()
	defer fake.listAliasesPagesWithContextMutex.Unlock()
	fake.ListAliasesPagesWithContextStub = nil
	fake.listAliasesPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListAliasesPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.listAliasesPagesWithContextMutex.Lock()
	defer fake.listAliasesPagesWithContextMutex.Unlock()
	fake.ListAliasesPagesWithContextStub = nil
	if fake.listAliasesPagesWithContextReturnsOnCall == nil {
		fake.listAliasesPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listAliasesPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListAliasesRequest(arg1 *kms.ListAliasesInput) (*request.Request, *kms.ListAliasesOutput) {
	fake.listAliasesRequestMutex.Lock()
	ret, specificReturn := fake.listAliasesRequestReturnsOnCall[len(fake.listAliasesRequestArgsForCall)]
	fake.listAliasesRequestArgsForCall = append(fake.listAliasesRequestArgsForCall, struct {
		arg1 *kms.ListAliasesInput
	}{arg1})
	stub := fake.ListAliasesRequestStub
	fakeReturns := fake.listAliasesRequestReturns
	fake.recordInvocation("ListAliasesRequest", []interface{}{arg1})
	fake.listAliasesRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListAliasesRequestCallCount() int {
	fake.listAliasesRequestMutex.RLock()
	defer fake.listAliasesRequestMutex.RUnlock()
	return len(fake.listAliasesRequestArgsForCall)
}

func (fake *FakeKMSClient) ListAliasesRequestCalls(stub func(*kms.ListAliasesInput) (*request.Request, *kms.ListAliasesOutput)) {
	fake.listAliasesRequestMutex.Lock()
	defer fake.listAliasesRequestMutex.Unlock()
	fake.ListAliasesRequestStub = stub
}

func (fake *FakeKMSClient) ListAliasesRequestArgsForCall(i int) *kms.ListAliasesInput {
	fake.listAliasesRequestMutex.RLock()
	defer fake.listAliasesRequestMutex.RUnlock()
	argsForCall := fake.listAliasesRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListAliasesRequestReturns(result1 *request.Request, result2 *kms.ListAliasesOutput) {
	fake.listAliasesRequestMutex.Lock()
	defer fake.listAliasesRequestMutex.Unlock()
	fake.ListAliasesRequestStub = nil
	fake.listAliasesRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ListAliasesOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ListAliasesRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ListAliasesOutput) {
	fake.listAliasesRequestMutex.Lock()
	defer fake.listAliasesRequestMutex.Unlock()
	fake.ListAliasesRequestStub = nil
	if fake.listAliasesRequestReturnsOnCall == nil {
		fake.listAliasesRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ListAliasesOutput
		})
	}
	fake.listAliasesRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ListAliasesOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ListAliasesWithContext(arg1 context.Context, arg2 *kms.ListAliasesInput, arg3 ...request.Option) (*kms.ListAliasesOutput, error) {
	fake.listAliasesWithContextMutex.Lock()
	ret, specificReturn := fake.listAliasesWithContextReturnsOnCall[len(fake.listAliasesWithContextArgsForCall)]
	fake.listAliasesWithContextArgsForCall = append(fake.listAliasesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ListAliasesInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ListAliasesWithContextStub
	fakeReturns := fake.listAliasesWithContextReturns
	fake.recordInvocation("ListAliasesWithContext", []interface{}{arg1, arg2, arg3})
	fake.listAliasesWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListAliasesWithContextCallCount() int {
	fake.listAliasesWithContextMutex.RLock()
	defer fake.listAliasesWithContextMutex.RUnlock()
	return len(fake.listAliasesWithContextArgsForCall)
}

func (fake *FakeKMSClient) ListAliasesWithContextCalls(stub func(context.Context, *kms.ListAliasesInput, ...request.Option) (*kms.ListAliasesOutput, error)) {
	fake.listAliasesWithContextMutex.Lock()
	defer fake.listAliasesWithContextMutex.Unlock()
	fake.ListAliasesWithContextStub = stub
}

func (fake *FakeKMSClient) ListAliasesWithContextArgsForCall(i int) (context.Context, *kms.ListAliasesInput, []request.Option) {
	fake.listAliasesWithContextMutex.RLock()
	defer fake.listAliasesWithContextMutex.RUnlock()
	argsForCall := fake.listAliasesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ListAliasesWithContextReturns(result1 *kms.ListAliasesOutput, result2 error) {
	fake.listAliasesWithContextMutex.Lock()
	defer fake.listAliasesWithContextMutex.Unlock()
	fake.ListAliasesWithContextStub = nil
	fake.listAliasesWithContextReturns = struct {
		result1 *kms.ListAliasesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListAliasesWithContextReturnsOnCall(i int, result1 *kms.ListAliasesOutput, result2 error) {
	fake.listAliasesWithContextMutex.Lock()
	defer fake.listAliasesWithContextMutex.Unlock()
	fake.ListAliasesWithContextStub = nil
	if fake.listAliasesWithContextReturnsOnCall == nil {
		fake.listAliasesWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ListAliasesOutput
			result2 error
		})
	}
	fake.listAliasesWithContextReturnsOnCall[i] = struct {
		result1 *kms.ListAliasesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListGrants(arg1 *kms.ListGrantsInput) (*kms.ListGrantsResponse, error) {
	fake.listGrantsMutex.Lock()
	ret, specificReturn := fake.listGrantsReturnsOnCall[len(fake.listGrantsArgsForCall)]
	fake.listGrantsArgsForCall = append(fake.listGrantsArgsForCall, struct {
		arg1 *kms.ListGrantsInput
	}{arg1})
	stub := fake.ListGrantsStub
	fakeReturns := fake.listGrantsReturns
	fake.recordInvocation("ListGrants", []interface{}{arg1})
	fake.listGrantsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListGrantsCallCount() int {
	fake.listGrantsMutex.RLock()
	defer fake.listGrantsMutex.RUnlock()
	return len(fake.listGrantsArgsForCall)
}

func (fake *FakeKMSClient) ListGrantsCalls(stub func(*kms.ListGrantsInput) (*kms.ListGrantsResponse, error)) {
	fake.listGrantsMutex.Lock()
	defer fake.listGrantsMutex.Unlock()
	fake.ListGrantsStub = stub
}

func (fake *FakeKMSClient) ListGrantsArgsForCall(i int) *kms.ListGrantsInput {
	fake.listGrantsMutex.RLock()
	defer fake.listGrantsMutex.RUnlock()
	argsForCall := fake.listGrantsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListGrantsReturns(result1 *kms.ListGrantsResponse, result2 error) {
	fake.listGrantsMutex.Lock()
	defer fake.listGrantsMutex.Unlock()
	fake.ListGrantsStub = nil
	fake.listGrantsReturns = struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListGrantsReturnsOnCall(i int, result1 *kms.ListGrantsResponse, result2 error) {
	fake.listGrantsMutex.Lock()
	defer fake.listGrantsMutex.Unlock()
	fake.ListGrantsStub = nil
	if fake.listGrantsReturnsOnCall == nil {
		fake.listGrantsReturnsOnCall = make(map[int]struct {
			result1 *kms.ListGrantsResponse
			result2 error
		})
	}
	fake.listGrantsReturnsOnCall[i] = struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListGrantsPages(arg1 *kms.ListGrantsInput, arg2 func(*kms.ListGrantsResponse, bool) bool) error {
	fake.listGrantsPagesMutex.Lock()
	ret, specificReturn := fake.listGrantsPagesReturnsOnCall[len(fake.listGrantsPagesArgsForCall)]
	fake.listGrantsPagesArgsForCall = append(fake.listGrantsPagesArgsForCall, struct {
		arg1 *kms.ListGrantsInput
		arg2 func(*kms.ListGrantsResponse, bool) bool
	}{arg1, arg2})
	stub := fake.ListGrantsPagesStub
	fakeReturns := fake.listGrantsPagesReturns
	fake.recordInvocation("ListGrantsPages", []interface{}{arg1, arg2})
	fake.listGrantsPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKMSClient) ListGrantsPagesCallCount() int {
	fake.listGrantsPagesMutex.RLock()
	defer fake.listGrantsPagesMutex.RUnlock()
	return len(fake.listGrantsPagesArgsForCall)
}

func (fake *FakeKMSClient) ListGrantsPagesCalls(stub func(*kms.ListGrantsInput, func(*kms.ListGrantsResponse, bool) bool) error) {
	fake.listGrantsPagesMutex.Lock()
	defer fake.listGrantsPagesMutex.Unlock()
	fake.ListGrantsPagesStub = stub
}

func (fake *FakeKMSClient) ListGrantsPagesArgsForCall(i int) (*kms.ListGrantsInput, func(*kms.ListGrantsResponse, bool) bool) {
	fake.listGrantsPagesMutex.RLock()
	defer fake.listGrantsPagesMutex.RUnlock()
	argsForCall := fake.listGrantsPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKMSClient) ListGrantsPagesReturns(result1 error) {
	fake.listGrantsPagesMutex.Lock()
	defer fake.listGrantsPagesMutex.Unlock()
	fake.ListGrantsPagesStub = nil
	fake.listGrantsPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListGrantsPagesReturnsOnCall(i int, result1 error) {
	fake.listGrantsPagesMutex.Lock()
	defer fake.listGrantsPagesMutex.Unlock()
	fake.ListGrantsPagesStub = nil
	if fake.listGrantsPagesReturnsOnCall == nil {
		fake.listGrantsPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listGrantsPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListGrantsPagesWithContext(arg1 context.Context, arg2 *kms.ListGrantsInput, arg3 func(*kms.ListGrantsResponse, bool) bool, arg4 ...request.Option) error {
	fake.listGrantsPagesWithContextMutex.Lock()
	ret, specificReturn := fake.listGrantsPagesWithContextReturnsOnCall[len(fake.listGrantsPagesWithContextArgsForCall)]
	fake.listGrantsPagesWithContextArgsForCall = append(fake.listGrantsPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ListGrantsInput
		arg3 func(*kms.ListGrantsResponse, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListGrantsPagesWithContextStub
	fakeReturns := fake.listGrantsPagesWithContextReturns
	fake.recordInvocation("ListGrantsPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.listGrantsPagesWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKMSClient) ListGrantsPagesWithContextCallCount() int {
	fake.listGrantsPagesWithContextMutex.RLock()
	defer fake.listGrantsPagesWithContextMutex.RUnlock()
	return len(fake.listGrantsPagesWithContextArgsForCall)
}

func (fake *FakeKMSClient) ListGrantsPagesWithContextCalls(stub func(context.Context, *kms.ListGrantsInput, func(*kms.ListGrantsResponse, bool) bool, ...request.Option) error) {
	fake.listGrantsPagesWithContextMutex.Lock()
	defer fake.listGrantsPagesWithContextMutex.Unlock()
	fake.ListGrantsPagesWithContextStub = stub
}

func (fake *FakeKMSClient) ListGrantsPagesWithContextArgsForCall(i int) (context.Context, *kms.ListGrantsInput, func(*kms.ListGrantsResponse, bool) bool, []request.Option) {
	fake.listGrantsPagesWithContextMutex.RLock()
	defer fake.listGrantsPagesWithContextMutex.RUnlock()
	argsForCall := fake.listGrantsPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeKMSClient) ListGrantsPagesWithContextReturns(result1 error) {
	fake.listGrantsPagesWithContextMutex.Lock()
	defer fake.listGrantsPagesWithContextMutex.Unlock()
	fake.ListGrantsPagesWithContextStub = nil
	fake.listGrantsPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListGrantsPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.listGrantsPagesWithContextMutex.Lock()
	defer fake.listGrantsPagesWithContextMutex.Unlock()
	fake.ListGrantsPagesWithContextStub = nil
	if fake.listGrantsPagesWithContextReturnsOnCall == nil {
		fake.listGrantsPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listGrantsPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListGrantsRequest(arg1 *kms.ListGrantsInput) (*request.Request, *kms.ListGrantsResponse) {
	fake.listGrantsRequestMutex.Lock()
	ret, specificReturn := fake.listGrantsRequestReturnsOnCall[len(fake.listGrantsRequestArgsForCall)]
	fake.listGrantsRequestArgsForCall = append(fake.listGrantsRequestArgsForCall, struct {
		arg1 *kms.ListGrantsInput
	}{arg1})
	stub := fake.ListGrantsRequestStub
	fakeReturns := fake.listGrantsRequestReturns
	fake.recordInvocation("ListGrantsRequest", []interface{}{arg1})
	fake.listGrantsRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListGrantsRequestCallCount() int {
	fake.listGrantsRequestMutex.RLock()
	defer fake.listGrantsRequestMutex.RUnlock()
	return len(fake.listGrantsRequestArgsForCall)
}

func (fake *FakeKMSClient) ListGrantsRequestCalls(stub func(*kms.ListGrantsInput) (*request.Request, *kms.ListGrantsResponse)) {
	fake.listGrantsRequestMutex.Lock()
	defer fake.listGrantsRequestMutex.Unlock()
	fake.ListGrantsRequestStub = stub
}

func (fake *FakeKMSClient) ListGrantsRequestArgsForCall(i int) *kms.ListGrantsInput {
	fake.listGrantsRequestMutex.RLock()
	defer fake.listGrantsRequestMutex.RUnlock()
	argsForCall := fake.listGrantsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListGrantsRequestReturns(result1 *request.Request, result2 *kms.ListGrantsResponse) {
	fake.listGrantsRequestMutex.Lock()
	defer fake.listGrantsRequestMutex.Unlock()
	fake.ListGrantsRequestStub = nil
	fake.listGrantsRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ListGrantsResponse
	}{result1, result2}
}

func (fake *FakeKMSClient) ListGrantsRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ListGrantsResponse) {
	fake.listGrantsRequestMutex.Lock()
	defer fake.listGrantsRequestMutex.Unlock()
	fake.ListGrantsRequestStub = nil
	if fake.listGrantsRequestReturnsOnCall == nil {
		fake.listGrantsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ListGrantsResponse
		})
	}
	fake.listGrantsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ListGrantsResponse
	}{result1, result2}
}

func (fake *FakeKMSClient) ListGrantsWithContext(arg1 context.Context, arg2 *kms.ListGrantsInput, arg3 ...request.Option) (*kms.ListGrantsResponse, error) {
	fake.listGrantsWithContextMutex.Lock()
	ret, specificReturn := fake.listGrantsWithContextReturnsOnCall[len(fake.listGrantsWithContextArgsForCall)]
	fake.listGrantsWithContextArgsForCall = append(fake.listGrantsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ListGrantsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ListGrantsWithContextStub
	fakeReturns := fake.listGrantsWithContextReturns
	fake.recordInvocation("ListGrantsWithContext", []interface{}{arg1, arg2, arg3})
	fake.listGrantsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListGrantsWithContextCallCount() int {
	fake.listGrantsWithContextMutex.RLock()
	defer fake.listGrantsWithContextMutex.RUnlock()
	return len(fake.listGrantsWithContextArgsForCall)
}

func (fake *FakeKMSClient) ListGrantsWithContextCalls(stub func(context.Context, *kms.ListGrantsInput, ...request.Option) (*kms.ListGrantsResponse, error)) {
	fake.listGrantsWithContextMutex.Lock()
	defer fake.listGrantsWithContextMutex.Unlock()
	fake.ListGrantsWithContextStub = stub
}

func (fake *FakeKMSClient) ListGrantsWithContextArgsForCall(i int) (context.Context, *kms.ListGrantsInput, []request.Option) {
	fake.listGrantsWithContextMutex.RLock()
	defer fake.listGrantsWithContextMutex.RUnlock()
	argsForCall := fake.listGrantsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ListGrantsWithContextReturns(result1 *kms.ListGrantsResponse, result2 error) {
	fake.listGrantsWithContextMutex.Lock()
	defer fake.listGrantsWithContextMutex.Unlock()
	fake.ListGrantsWithContextStub = nil
	fake.listGrantsWithContextReturns = struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListGrantsWithContextReturnsOnCall(i int, result1 *kms.ListGrantsResponse, result2 error) {
	fake.listGrantsWithContextMutex.Lock()
	defer fake.listGrantsWithContextMutex.Unlock()
	fake.ListGrantsWithContextStub = nil
	if fake.listGrantsWithContextReturnsOnCall == nil {
		fake.listGrantsWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ListGrantsResponse
			result2 error
		})
	}
	fake.listGrantsWithContextReturnsOnCall[i] = struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeyPolicies(arg1 *kms.ListKeyPoliciesInput) (*kms.ListKeyPoliciesOutput, error) {
	fake.listKeyPoliciesMutex.Lock()
	ret, specificReturn := fake.listKeyPoliciesReturnsOnCall[len(fake.listKeyPoliciesArgsForCall)]
	fake.listKeyPoliciesArgsForCall = append(fake.listKeyPoliciesArgsForCall, struct {
		arg1 *kms.ListKeyPoliciesInput
	}{arg1})
	stub := fake.ListKeyPoliciesStub
	fakeReturns := fake.listKeyPoliciesReturns
	fake.recordInvocation("ListKeyPolicies", []interface{}{arg1})
	fake.listKeyPoliciesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListKeyPoliciesCallCount() int {
	fake.listKeyPoliciesMutex.RLock()
	defer fake.listKeyPoliciesMutex.RUnlock()
	return len(fake.listKeyPoliciesArgsForCall)
}

func (fake *FakeKMSClient) ListKeyPoliciesCalls(stub func(*kms.ListKeyPoliciesInput) (*kms.ListKeyPoliciesOutput, error)) {
	fake.listKeyPoliciesMutex.Lock()
	defer fake.listKeyPoliciesMutex.Unlock()
	fake.ListKeyPoliciesStub = stub
}

func (fake *FakeKMSClient) ListKeyPoliciesArgsForCall(i int) *kms.ListKeyPoliciesInput {
	fake.listKeyPoliciesMutex.RLock()
	defer fake.listKeyPoliciesMutex.RUnlock()
	argsForCall := fake.listKeyPoliciesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListKeyPoliciesReturns(result1 *kms.ListKeyPoliciesOutput, result2 error) {
	fake.listKeyPoliciesMutex.Lock()
	defer fake.listKeyPoliciesMutex.Unlock()
	fake.ListKeyPoliciesStub = nil
	fake.listKeyPoliciesReturns = struct {
		result1 *kms.ListKeyPoliciesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeyPoliciesReturnsOnCall(i int, result1 *kms.ListKeyPoliciesOutput, result2 error) {
	fake.listKeyPoliciesMutex.Lock()
	defer fake.listKeyPoliciesMutex.Unlock()
	fake.ListKeyPoliciesStub = nil
	if fake.listKeyPoliciesReturnsOnCall == nil {
		fake.listKeyPoliciesReturnsOnCall = make(map[int]struct {
			result1 *kms.ListKeyPoliciesOutput
			result2 error
		})
	}
	fake.listKeyPoliciesReturnsOnCall[i] = struct {
		result1 *kms.ListKeyPoliciesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeyPoliciesPages(arg1 *kms.ListKeyPoliciesInput, arg2 func(*kms.ListKeyPoliciesOutput, bool) bool) error {
	fake.listKeyPoliciesPagesMutex.Lock()
	ret, specificReturn := fake.listKeyPoliciesPagesReturnsOnCall[len(fake.listKeyPoliciesPagesArgsForCall)]
	fake.listKeyPoliciesPagesArgsForCall = append(fake.listKeyPoliciesPagesArgsForCall, struct {
		arg1 *kms.ListKeyPoliciesInput
		arg2 func(*kms.ListKeyPoliciesOutput, bool) bool
	}{arg1, arg2})
	stub := fake.ListKeyPoliciesPagesStub
	fakeReturns := fake.listKeyPoliciesPagesReturns
	fake.recordInvocation("ListKeyPoliciesPages", []interface{}{arg1, arg2})
	fake.listKeyPoliciesPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesCallCount() int {
	fake.listKeyPoliciesPagesMutex.RLock()
	defer fake.listKeyPoliciesPagesMutex.RUnlock()
	return len(fake.listKeyPoliciesPagesArgsForCall)
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesCalls(stub func(*kms.ListKeyPoliciesInput, func(*kms.ListKeyPoliciesOutput, bool) bool) error) {
	fake.listKeyPoliciesPagesMutex.Lock()
	defer fake.listKeyPoliciesPagesMutex.Unlock()
	fake.ListKeyPoliciesPagesStub = stub
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesArgsForCall(i int) (*kms.ListKeyPoliciesInput, func(*kms.ListKeyPoliciesOutput, bool) bool) {
	fake.listKeyPoliciesPagesMutex.RLock()
	defer fake.listKeyPoliciesPagesMutex.RUnlock()
	argsForCall := fake.listKeyPoliciesPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesReturns(result1 error) {
	fake.listKeyPoliciesPagesMutex.Lock()
	defer fake.listKeyPoliciesPagesMutex.Unlock()
	fake.ListKeyPoliciesPagesStub = nil
	fake.listKeyPoliciesPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesReturnsOnCall(i int, result1 error) {
	fake.listKeyPoliciesPagesMutex.Lock()
	defer fake.listKeyPoliciesPagesMutex.Unlock()
	fake.ListKeyPoliciesPagesStub = nil
	if fake.listKeyPoliciesPagesReturnsOnCall == nil {
		fake.listKeyPoliciesPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listKeyPoliciesPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesWithContext(arg1 context.Context, arg2 *kms.ListKeyPoliciesInput, arg3 func(*kms.ListKeyPoliciesOutput, bool) bool, arg4 ...request.Option) error {
	fake.listKeyPoliciesPagesWithContextMutex.Lock()
	ret, specificReturn := fake.listKeyPoliciesPagesWithContextReturnsOnCall[len(fake.listKeyPoliciesPagesWithContextArgsForCall)]
	fake.listKeyPoliciesPagesWithContextArgsForCall = append(fake.listKeyPoliciesPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ListKeyPoliciesInput
		arg3 func(*kms.ListKeyPoliciesOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListKeyPoliciesPagesWithContextStub
	fakeReturns := fake.listKeyPoliciesPagesWithContextReturns
	fake.recordInvocation("ListKeyPoliciesPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.listKeyPoliciesPagesWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesWithContextCallCount() int {
	fake.listKeyPoliciesPagesWithContextMutex.RLock()
	defer fake.listKeyPoliciesPagesWithContextMutex.RUnlock()
	return len(fake.listKeyPoliciesPagesWithContextArgsForCall)
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesWithContextCalls(stub func(context.Context, *kms.ListKeyPoliciesInput, func(*kms.ListKeyPoliciesOutput, bool) bool, ...request.Option) error) {
	fake.listKeyPoliciesPagesWithContextMutex.Lock()
	defer fake.listKeyPoliciesPagesWithContextMutex.Unlock()
	fake.ListKeyPoliciesPagesWithContextStub = stub
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesWithContextArgsForCall(i int) (context.Context, *kms.ListKeyPoliciesInput, func(*kms.ListKeyPoliciesOutput, bool) bool, []request.Option) {
	fake.listKeyPoliciesPagesWithContextMutex.RLock()
	defer fake.listKeyPoliciesPagesWithContextMutex.RUnlock()
	argsForCall := fake.listKeyPoliciesPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesWithContextReturns(result1 error) {
	fake.listKeyPoliciesPagesWithContextMutex.Lock()
	defer fake.listKeyPoliciesPagesWithContextMutex.Unlock()
	fake.ListKeyPoliciesPagesWithContextStub = nil
	fake.listKeyPoliciesPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListKeyPoliciesPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.listKeyPoliciesPagesWithContextMutex.Lock()
	defer fake.listKeyPoliciesPagesWithContextMutex.Unlock()
	fake.ListKeyPoliciesPagesWithContextStub = nil
	if fake.listKeyPoliciesPagesWithContextReturnsOnCall == nil {
		fake.listKeyPoliciesPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listKeyPoliciesPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListKeyPoliciesRequest(arg1 *kms.ListKeyPoliciesInput) (*request.Request, *kms.ListKeyPoliciesOutput) {
	fake.listKeyPoliciesRequestMutex.Lock()
	ret, specificReturn := fake.listKeyPoliciesRequestReturnsOnCall[len(fake.listKeyPoliciesRequestArgsForCall)]
	fake.listKeyPoliciesRequestArgsForCall = append(fake.listKeyPoliciesRequestArgsForCall, struct {
		arg1 *kms.ListKeyPoliciesInput
	}{arg1})
	stub := fake.ListKeyPoliciesRequestStub
	fakeReturns := fake.listKeyPoliciesRequestReturns
	fake.recordInvocation("ListKeyPoliciesRequest", []interface{}{arg1})
	fake.listKeyPoliciesRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListKeyPoliciesRequestCallCount() int {
	fake.listKeyPoliciesRequestMutex.RLock()
	defer fake.listKeyPoliciesRequestMutex.RUnlock()
	return len(fake.listKeyPoliciesRequestArgsForCall)
}

func (fake *FakeKMSClient) ListKeyPoliciesRequestCalls(stub func(*kms.ListKeyPoliciesInput) (*request.Request, *kms.ListKeyPoliciesOutput)) {
	fake.listKeyPoliciesRequestMutex.Lock()
	defer fake.listKeyPoliciesRequestMutex.Unlock()
	fake.ListKeyPoliciesRequestStub = stub
}

func (fake *FakeKMSClient) ListKeyPoliciesRequestArgsForCall(i int) *kms.ListKeyPoliciesInput {
	fake.listKeyPoliciesRequestMutex.RLock()
	defer fake.listKeyPoliciesRequestMutex.RUnlock()
	argsForCall := fake.listKeyPoliciesRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListKeyPoliciesRequestReturns(result1 *request.Request, result2 *kms.ListKeyPoliciesOutput) {
	fake.listKeyPoliciesRequestMutex.Lock()
	defer fake.listKeyPoliciesRequestMutex.Unlock()
	fake.ListKeyPoliciesRequestStub = nil
	fake.listKeyPoliciesRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ListKeyPoliciesOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeyPoliciesRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ListKeyPoliciesOutput) {
	fake.listKeyPoliciesRequestMutex.Lock()
	defer fake.listKeyPoliciesRequestMutex.Unlock()
	fake.ListKeyPoliciesRequestStub = nil
	if fake.listKeyPoliciesRequestReturnsOnCall == nil {
		fake.listKeyPoliciesRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ListKeyPoliciesOutput
		})
	}
	fake.listKeyPoliciesRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ListKeyPoliciesOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeyPoliciesWithContext(arg1 context.Context, arg2 *kms.ListKeyPoliciesInput, arg3 ...request.Option) (*kms.ListKeyPoliciesOutput, error) {
	fake.listKeyPoliciesWithContextMutex.Lock()
	ret, specificReturn := fake.listKeyPoliciesWithContextReturnsOnCall[len(fake.listKeyPoliciesWithContextArgsForCall)]
	fake.listKeyPoliciesWithContextArgsForCall = append(fake.listKeyPoliciesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ListKeyPoliciesInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ListKeyPoliciesWithContextStub
	fakeReturns := fake.listKeyPoliciesWithContextReturns
	fake.recordInvocation("ListKeyPoliciesWithContext", []interface{}{arg1, arg2, arg3})
	fake.listKeyPoliciesWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListKeyPoliciesWithContextCallCount() int {
	fake.listKeyPoliciesWithContextMutex.RLock()
	defer fake.listKeyPoliciesWithContextMutex.RUnlock()
	return len(fake.listKeyPoliciesWithContextArgsForCall)
}

func (fake *FakeKMSClient) ListKeyPoliciesWithContextCalls(stub func(context.Context, *kms.ListKeyPoliciesInput, ...request.Option) (*kms.ListKeyPoliciesOutput, error)) {
	fake.listKeyPoliciesWithContextMutex.Lock()
	defer fake.listKeyPoliciesWithContextMutex.Unlock()
	fake.ListKeyPoliciesWithContextStub = stub
}

func (fake *FakeKMSClient) ListKeyPoliciesWithContextArgsForCall(i int) (context.Context, *kms.ListKeyPoliciesInput, []request.Option) {
	fake.listKeyPoliciesWithContextMutex.RLock()
	defer fake.listKeyPoliciesWithContextMutex.RUnlock()
	argsForCall := fake.listKeyPoliciesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ListKeyPoliciesWithContextReturns(result1 *kms.ListKeyPoliciesOutput, result2 error) {
	fake.listKeyPoliciesWithContextMutex.Lock()
	defer fake.listKeyPoliciesWithContextMutex.Unlock()
	fake.ListKeyPoliciesWithContextStub = nil
	fake.listKeyPoliciesWithContextReturns = struct {
		result1 *kms.ListKeyPoliciesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeyPoliciesWithContextReturnsOnCall(i int, result1 *kms.ListKeyPoliciesOutput, result2 error) {
	fake.listKeyPoliciesWithContextMutex.Lock()
	defer fake.listKeyPoliciesWithContextMutex.Unlock()
	fake.ListKeyPoliciesWithContextStub = nil
	if fake.listKeyPoliciesWithContextReturnsOnCall == nil {
		fake.listKeyPoliciesWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ListKeyPoliciesOutput
			result2 error
		})
	}
	fake.listKeyPoliciesWithContextReturnsOnCall[i] = struct {
		result1 *kms.ListKeyPoliciesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeys(arg1 *kms.ListKeysInput) (*kms.ListKeysOutput, error) {
	fake.listKeysMutex.Lock()
	ret, specificReturn := fake.listKeysReturnsOnCall[len(fake.listKeysArgsForCall)]
	fake.listKeysArgsForCall = append(fake.listKeysArgsForCall, struct {
		arg1 *kms.ListKeysInput
	}{arg1})
	stub := fake.ListKeysStub
	fakeReturns := fake.listKeysReturns
	fake.recordInvocation("ListKeys", []interface{}{arg1})
	fake.listKeysMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListKeysCallCount() int {
	fake.listKeysMutex.RLock()
	defer fake.listKeysMutex.RUnlock()
	return len(fake.listKeysArgsForCall)
}

func (fake *FakeKMSClient) ListKeysCalls(stub func(*kms.ListKeysInput) (*kms.ListKeysOutput, error)) {
	fake.listKeysMutex.Lock()
	defer fake.listKeysMutex.Unlock()
	fake.ListKeysStub = stub
}

func (fake *FakeKMSClient) ListKeysArgsForCall(i int) *kms.ListKeysInput {
	fake.listKeysMutex.RLock()
	defer fake.listKeysMutex.RUnlock()
	argsForCall := fake.listKeysArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListKeysReturns(result1 *kms.ListKeysOutput, result2 error) {
	fake.listKeysMutex.Lock()
	defer fake.listKeysMutex.Unlock()
	fake.ListKeysStub = nil
	fake.listKeysReturns = struct {
		result1 *kms.ListKeysOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeysReturnsOnCall(i int, result1 *kms.ListKeysOutput, result2 error) {
	fake.listKeysMutex.Lock()
	defer fake.listKeysMutex.Unlock()
	fake.ListKeysStub = nil
	if fake.listKeysReturnsOnCall == nil {
		fake.listKeysReturnsOnCall = make(map[int]struct {
			result1 *kms.ListKeysOutput
			result2 error
		})
	}
	fake.listKeysReturnsOnCall[i] = struct {
		result1 *kms.ListKeysOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeysPages(arg1 *kms.ListKeysInput, arg2 func(*kms.ListKeysOutput, bool) bool) error {
	fake.listKeysPagesMutex.Lock()
	ret, specificReturn := fake.listKeysPagesReturnsOnCall[len(fake.listKeysPagesArgsForCall)]
	fake.listKeysPagesArgsForCall = append(fake.listKeysPagesArgsForCall, struct {
		arg1 *kms.ListKeysInput
		arg2 func(*kms.ListKeysOutput, bool) bool
	}{arg1, arg2})
	stub := fake.ListKeysPagesStub
	fakeReturns := fake.listKeysPagesReturns
	fake.recordInvocation("ListKeysPages", []interface{}{arg1, arg2})
	fake.listKeysPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKMSClient) ListKeysPagesCallCount() int {
	fake.listKeysPagesMutex.RLock()
	defer fake.listKeysPagesMutex.RUnlock()
	return len(fake.listKeysPagesArgsForCall)
}

func (fake *FakeKMSClient) ListKeysPagesCalls(stub func(*kms.ListKeysInput, func(*kms.ListKeysOutput, bool) bool) error) {
	fake.listKeysPagesMutex.Lock()
	defer fake.listKeysPagesMutex.Unlock()
	fake.ListKeysPagesStub = stub
}

func (fake *FakeKMSClient) ListKeysPagesArgsForCall(i int) (*kms.ListKeysInput, func(*kms.ListKeysOutput, bool) bool) {
	fake.listKeysPagesMutex.RLock()
	defer fake.listKeysPagesMutex.RUnlock()
	argsForCall := fake.listKeysPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKMSClient) ListKeysPagesReturns(result1 error) {
	fake.listKeysPagesMutex.Lock()
	defer fake.listKeysPagesMutex.Unlock()
	fake.ListKeysPagesStub = nil
	fake.listKeysPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListKeysPagesReturnsOnCall(i int, result1 error) {
	fake.listKeysPagesMutex.Lock()
	defer fake.listKeysPagesMutex.Unlock()
	fake.ListKeysPagesStub = nil
	if fake.listKeysPagesReturnsOnCall == nil {
		fake.listKeysPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listKeysPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListKeysPagesWithContext(arg1 context.Context, arg2 *kms.ListKeysInput, arg3 func(*kms.ListKeysOutput, bool) bool, arg4 ...request.Option) error {
	fake.listKeysPagesWithContextMutex.Lock()
	ret, specificReturn := fake.listKeysPagesWithContextReturnsOnCall[len(fake.listKeysPagesWithContextArgsForCall)]
	fake.listKeysPagesWithContextArgsForCall = append(fake.listKeysPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ListKeysInput
		arg3 func(*kms.ListKeysOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListKeysPagesWithContextStub
	fakeReturns := fake.listKeysPagesWithContextReturns
	fake.recordInvocation("ListKeysPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.listKeysPagesWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKMSClient) ListKeysPagesWithContextCallCount() int {
	fake.listKeysPagesWithContextMutex.RLock()
	defer fake.listKeysPagesWithContextMutex.RUnlock()
	return len(fake.listKeysPagesWithContextArgsForCall)
}

func (fake *FakeKMSClient) ListKeysPagesWithContextCalls(stub func(context.Context, *kms.ListKeysInput, func(*kms.ListKeysOutput, bool) bool, ...request.Option) error) {
	fake.listKeysPagesWithContextMutex.Lock()
	defer fake.listKeysPagesWithContextMutex.Unlock()
	fake.ListKeysPagesWithContextStub = stub
}

func (fake *FakeKMSClient) ListKeysPagesWithContextArgsForCall(i int) (context.Context, *kms.ListKeysInput, func(*kms.ListKeysOutput, bool) bool, []request.Option) {
	fake.listKeysPagesWithContextMutex.RLock()
	defer fake.listKeysPagesWithContextMutex.RUnlock()
	argsForCall := fake.listKeysPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeKMSClient) ListKeysPagesWithContextReturns(result1 error) {
	fake.listKeysPagesWithContextMutex.Lock()
	defer fake.listKeysPagesWithContextMutex.Unlock()
	fake.ListKeysPagesWithContextStub = nil
	fake.listKeysPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListKeysPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.listKeysPagesWithContextMutex.Lock()
	defer fake.listKeysPagesWithContextMutex.Unlock()
	fake.ListKeysPagesWithContextStub = nil
	if fake.listKeysPagesWithContextReturnsOnCall == nil {
		fake.listKeysPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listKeysPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKMSClient) ListKeysRequest(arg1 *kms.ListKeysInput) (*request.Request, *kms.ListKeysOutput) {
	fake.listKeysRequestMutex.Lock()
	ret, specificReturn := fake.listKeysRequestReturnsOnCall[len(fake.listKeysRequestArgsForCall)]
	fake.listKeysRequestArgsForCall = append(fake.listKeysRequestArgsForCall, struct {
		arg1 *kms.ListKeysInput
	}{arg1})
	stub := fake.ListKeysRequestStub
	fakeReturns := fake.listKeysRequestReturns
	fake.recordInvocation("ListKeysRequest", []interface{}{arg1})
	fake.listKeysRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListKeysRequestCallCount() int {
	fake.listKeysRequestMutex.RLock()
	defer fake.listKeysRequestMutex.RUnlock()
	return len(fake.listKeysRequestArgsForCall)
}

func (fake *FakeKMSClient) ListKeysRequestCalls(stub func(*kms.ListKeysInput) (*request.Request, *kms.ListKeysOutput)) {
	fake.listKeysRequestMutex.Lock()
	defer fake.listKeysRequestMutex.Unlock()
	fake.ListKeysRequestStub = stub
}

func (fake *FakeKMSClient) ListKeysRequestArgsForCall(i int) *kms.ListKeysInput {
	fake.listKeysRequestMutex.RLock()
	defer fake.listKeysRequestMutex.RUnlock()
	argsForCall := fake.listKeysRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListKeysRequestReturns(result1 *request.Request, result2 *kms.ListKeysOutput) {
	fake.listKeysRequestMutex.Lock()
	defer fake.listKeysRequestMutex.Unlock()
	fake.ListKeysRequestStub = nil
	fake.listKeysRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ListKeysOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeysRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ListKeysOutput) {
	fake.listKeysRequestMutex.Lock()
	defer fake.listKeysRequestMutex.Unlock()
	fake.ListKeysRequestStub = nil
	if fake.listKeysRequestReturnsOnCall == nil {
		fake.listKeysRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ListKeysOutput
		})
	}
	fake.listKeysRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ListKeysOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeysWithContext(arg1 context.Context, arg2 *kms.ListKeysInput, arg3 ...request.Option) (*kms.ListKeysOutput, error) {
	fake.listKeysWithContextMutex.Lock()
	ret, specificReturn := fake.listKeysWithContextReturnsOnCall[len(fake.listKeysWithContextArgsForCall)]
	fake.listKeysWithContextArgsForCall = append(fake.listKeysWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ListKeysInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ListKeysWithContextStub
	fakeReturns := fake.listKeysWithContextReturns
	fake.recordInvocation("ListKeysWithContext", []interface{}{arg1, arg2, arg3})
	fake.listKeysWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListKeysWithContextCallCount() int {
	fake.listKeysWithContextMutex.RLock()
	defer fake.listKeysWithContextMutex.RUnlock()
	return len(fake.listKeysWithContextArgsForCall)
}

func (fake *FakeKMSClient) ListKeysWithContextCalls(stub func(context.Context, *kms.ListKeysInput, ...request.Option) (*kms.ListKeysOutput, error)) {
	fake.listKeysWithContextMutex.Lock()
	defer fake.listKeysWithContextMutex.Unlock()
	fake.ListKeysWithContextStub = stub
}

func (fake *FakeKMSClient) ListKeysWithContextArgsForCall(i int) (context.Context, *kms.ListKeysInput, []request.Option) {
	fake.listKeysWithContextMutex.RLock()
	defer fake.listKeysWithContextMutex.RUnlock()
	argsForCall := fake.listKeysWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ListKeysWithContextReturns(result1 *kms.ListKeysOutput, result2 error) {
	fake.listKeysWithContextMutex.Lock()
	defer fake.listKeysWithContextMutex.Unlock()
	fake.ListKeysWithContextStub = nil
	fake.listKeysWithContextReturns = struct {
		result1 *kms.ListKeysOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListKeysWithContextReturnsOnCall(i int, result1 *kms.ListKeysOutput, result2 error) {
	fake.listKeysWithContextMutex.Lock()
	defer fake.listKeysWithContextMutex.Unlock()
	fake.ListKeysWithContextStub = nil
	if fake.listKeysWithContextReturnsOnCall == nil {
		fake.listKeysWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ListKeysOutput
			result2 error
		})
	}
	fake.listKeysWithContextReturnsOnCall[i] = struct {
		result1 *kms.ListKeysOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListResourceTags(arg1 *kms.ListResourceTagsInput) (*kms.ListResourceTagsOutput, error) {
	fake.listResourceTagsMutex.Lock()
	ret, specificReturn := fake.listResourceTagsReturnsOnCall[len(fake.listResourceTagsArgsForCall)]
	fake.listResourceTagsArgsForCall = append(fake.listResourceTagsArgsForCall, struct {
		arg1 *kms.ListResourceTagsInput
	}{arg1})
	stub := fake.ListResourceTagsStub
	fakeReturns := fake.listResourceTagsReturns
	fake.recordInvocation("ListResourceTags", []interface{}{arg1})
	fake.listResourceTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListResourceTagsCallCount() int {
	fake.listResourceTagsMutex.RLock()
	defer fake.listResourceTagsMutex.RUnlock()
	return len(fake.listResourceTagsArgsForCall)
}

func (fake *FakeKMSClient) ListResourceTagsCalls(stub func(*kms.ListResourceTagsInput) (*kms.ListResourceTagsOutput, error)) {
	fake.listResourceTagsMutex.Lock()
	defer fake.listResourceTagsMutex.Unlock()
	fake.ListResourceTagsStub = stub
}

func (fake *FakeKMSClient) ListResourceTagsArgsForCall(i int) *kms.ListResourceTagsInput {
	fake.listResourceTagsMutex.RLock()
	defer fake.listResourceTagsMutex.RUnlock()
	argsForCall := fake.listResourceTagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListResourceTagsReturns(result1 *kms.ListResourceTagsOutput, result2 error) {
	fake.listResourceTagsMutex.Lock()
	defer fake.listResourceTagsMutex.Unlock()
	fake.ListResourceTagsStub = nil
	fake.listResourceTagsReturns = struct {
		result1 *kms.ListResourceTagsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListResourceTagsReturnsOnCall(i int, result1 *kms.ListResourceTagsOutput, result2 error) {
	fake.listResourceTagsMutex.Lock()
	defer fake.listResourceTagsMutex.Unlock()
	fake.ListResourceTagsStub = nil
	if fake.listResourceTagsReturnsOnCall == nil {
		fake.listResourceTagsReturnsOnCall = make(map[int]struct {
			result1 *kms.ListResourceTagsOutput
			result2 error
		})
	}
	fake.listResourceTagsReturnsOnCall[i] = struct {
		result1 *kms.ListResourceTagsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListResourceTagsRequest(arg1 *kms.ListResourceTagsInput) (*request.Request, *kms.ListResourceTagsOutput) {
	fake.listResourceTagsRequestMutex.Lock()
	ret, specificReturn := fake.listResourceTagsRequestReturnsOnCall[len(fake.listResourceTagsRequestArgsForCall)]
	fake.listResourceTagsRequestArgsForCall = append(fake.listResourceTagsRequestArgsForCall, struct {
		arg1 *kms.ListResourceTagsInput
	}{arg1})
	stub := fake.ListResourceTagsRequestStub
	fakeReturns := fake.listResourceTagsRequestReturns
	fake.recordInvocation("ListResourceTagsRequest", []interface{}{arg1})
	fake.listResourceTagsRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListResourceTagsRequestCallCount() int {
	fake.listResourceTagsRequestMutex.RLock()
	defer fake.listResourceTagsRequestMutex.RUnlock()
	return len(fake.listResourceTagsRequestArgsForCall)
}

func (fake *FakeKMSClient) ListResourceTagsRequestCalls(stub func(*kms.ListResourceTagsInput) (*request.Request, *kms.ListResourceTagsOutput)) {
	fake.listResourceTagsRequestMutex.Lock()
	defer fake.listResourceTagsRequestMutex.Unlock()
	fake.ListResourceTagsRequestStub = stub
}

func (fake *FakeKMSClient) ListResourceTagsRequestArgsForCall(i int) *kms.ListResourceTagsInput {
	fake.listResourceTagsRequestMutex.RLock()
	defer fake.listResourceTagsRequestMutex.RUnlock()
	argsForCall := fake.listResourceTagsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListResourceTagsRequestReturns(result1 *request.Request, result2 *kms.ListResourceTagsOutput) {
	fake.listResourceTagsRequestMutex.Lock()
	defer fake.listResourceTagsRequestMutex.Unlock()
	fake.ListResourceTagsRequestStub = nil
	fake.listResourceTagsRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ListResourceTagsOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ListResourceTagsRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ListResourceTagsOutput) {
	fake.listResourceTagsRequestMutex.Lock()
	defer fake.listResourceTagsRequestMutex.Unlock()
	fake.ListResourceTagsRequestStub = nil
	if fake.listResourceTagsRequestReturnsOnCall == nil {
		fake.listResourceTagsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ListResourceTagsOutput
		})
	}
	fake.listResourceTagsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ListResourceTagsOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ListResourceTagsWithContext(arg1 context.Context, arg2 *kms.ListResourceTagsInput, arg3 ...request.Option) (*kms.ListResourceTagsOutput, error) {
	fake.listResourceTagsWithContextMutex.Lock()
	ret, specificReturn := fake.listResourceTagsWithContextReturnsOnCall[len(fake.listResourceTagsWithContextArgsForCall)]
	fake.listResourceTagsWithContextArgsForCall = append(fake.listResourceTagsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ListResourceTagsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ListResourceTagsWithContextStub
	fakeReturns := fake.listResourceTagsWithContextReturns
	fake.recordInvocation("ListResourceTagsWithContext", []interface{}{arg1, arg2, arg3})
	fake.listResourceTagsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListResourceTagsWithContextCallCount() int {
	fake.listResourceTagsWithContextMutex.RLock()
	defer fake.listResourceTagsWithContextMutex.RUnlock()
	return len(fake.listResourceTagsWithContextArgsForCall)
}

func (fake *FakeKMSClient) ListResourceTagsWithContextCalls(stub func(context.Context, *kms.ListResourceTagsInput, ...request.Option) (*kms.ListResourceTagsOutput, error)) {
	fake.listResourceTagsWithContextMutex.Lock()
	defer fake.listResourceTagsWithContextMutex.Unlock()
	fake.ListResourceTagsWithContextStub = stub
}

func (fake *FakeKMSClient) ListResourceTagsWithContextArgsForCall(i int) (context.Context, *kms.ListResourceTagsInput, []request.Option) {
	fake.listResourceTagsWithContextMutex.RLock()
	defer fake.listResourceTagsWithContextMutex.RUnlock()
	argsForCall := fake.listResourceTagsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ListResourceTagsWithContextReturns(result1 *kms.ListResourceTagsOutput, result2 error) {
	fake.listResourceTagsWithContextMutex.Lock()
	defer fake.listResourceTagsWithContextMutex.Unlock()
	fake.ListResourceTagsWithContextStub = nil
	fake.listResourceTagsWithContextReturns = struct {
		result1 *kms.ListResourceTagsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListResourceTagsWithContextReturnsOnCall(i int, result1 *kms.ListResourceTagsOutput, result2 error) {
	fake.listResourceTagsWithContextMutex.Lock()
	defer fake.listResourceTagsWithContextMutex.Unlock()
	fake.ListResourceTagsWithContextStub = nil
	if fake.listResourceTagsWithContextReturnsOnCall == nil {
		fake.listResourceTagsWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ListResourceTagsOutput
			result2 error
		})
	}
	fake.listResourceTagsWithContextReturnsOnCall[i] = struct {
		result1 *kms.ListResourceTagsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListRetirableGrants(arg1 *kms.ListRetirableGrantsInput) (*kms.ListGrantsResponse, error) {
	fake.listRetirableGrantsMutex.Lock()
	ret, specificReturn := fake.listRetirableGrantsReturnsOnCall[len(fake.listRetirableGrantsArgsForCall)]
	fake.listRetirableGrantsArgsForCall = append(fake.listRetirableGrantsArgsForCall, struct {
		arg1 *kms.ListRetirableGrantsInput
	}{arg1})
	stub := fake.ListRetirableGrantsStub
	fakeReturns := fake.listRetirableGrantsReturns
	fake.recordInvocation("ListRetirableGrants", []interface{}{arg1})
	fake.listRetirableGrantsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListRetirableGrantsCallCount() int {
	fake.listRetirableGrantsMutex.RLock()
	defer fake.listRetirableGrantsMutex.RUnlock()
	return len(fake.listRetirableGrantsArgsForCall)
}

func (fake *FakeKMSClient) ListRetirableGrantsCalls(stub func(*kms.ListRetirableGrantsInput) (*kms.ListGrantsResponse, error)) {
	fake.listRetirableGrantsMutex.Lock()
	defer fake.listRetirableGrantsMutex.Unlock()
	fake.ListRetirableGrantsStub = stub
}

func (fake *FakeKMSClient) ListRetirableGrantsArgsForCall(i int) *kms.ListRetirableGrantsInput {
	fake.listRetirableGrantsMutex.RLock()
	defer fake.listRetirableGrantsMutex.RUnlock()
	argsForCall := fake.listRetirableGrantsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListRetirableGrantsReturns(result1 *kms.ListGrantsResponse, result2 error) {
	fake.listRetirableGrantsMutex.Lock()
	defer fake.listRetirableGrantsMutex.Unlock()
	fake.ListRetirableGrantsStub = nil
	fake.listRetirableGrantsReturns = struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListRetirableGrantsReturnsOnCall(i int, result1 *kms.ListGrantsResponse, result2 error) {
	fake.listRetirableGrantsMutex.Lock()
	defer fake.listRetirableGrantsMutex.Unlock()
	fake.ListRetirableGrantsStub = nil
	if fake.listRetirableGrantsReturnsOnCall == nil {
		fake.listRetirableGrantsReturnsOnCall = make(map[int]struct {
			result1 *kms.ListGrantsResponse
			result2 error
		})
	}
	fake.listRetirableGrantsReturnsOnCall[i] = struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListRetirableGrantsRequest(arg1 *kms.ListRetirableGrantsInput) (*request.Request, *kms.ListGrantsResponse) {
	fake.listRetirableGrantsRequestMutex.Lock()
	ret, specificReturn := fake.listRetirableGrantsRequestReturnsOnCall[len(fake.listRetirableGrantsRequestArgsForCall)]
	fake.listRetirableGrantsRequestArgsForCall = append(fake.listRetirableGrantsRequestArgsForCall, struct {
		arg1 *kms.ListRetirableGrantsInput
	}{arg1})
	stub := fake.ListRetirableGrantsRequestStub
	fakeReturns := fake.listRetirableGrantsRequestReturns
	fake.recordInvocation("ListRetirableGrantsRequest", []interface{}{arg1})
	fake.listRetirableGrantsRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListRetirableGrantsRequestCallCount() int {
	fake.listRetirableGrantsRequestMutex.RLock()
	defer fake.listRetirableGrantsRequestMutex.RUnlock()
	return len(fake.listRetirableGrantsRequestArgsForCall)
}

func (fake *FakeKMSClient) ListRetirableGrantsRequestCalls(stub func(*kms.ListRetirableGrantsInput) (*request.Request, *kms.ListGrantsResponse)) {
	fake.listRetirableGrantsRequestMutex.Lock()
	defer fake.listRetirableGrantsRequestMutex.Unlock()
	fake.ListRetirableGrantsRequestStub = stub
}

func (fake *FakeKMSClient) ListRetirableGrantsRequestArgsForCall(i int) *kms.ListRetirableGrantsInput {
	fake.listRetirableGrantsRequestMutex.RLock()
	defer fake.listRetirableGrantsRequestMutex.RUnlock()
	argsForCall := fake.listRetirableGrantsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ListRetirableGrantsRequestReturns(result1 *request.Request, result2 *kms.ListGrantsResponse) {
	fake.listRetirableGrantsRequestMutex.Lock()
	defer fake.listRetirableGrantsRequestMutex.Unlock()
	fake.ListRetirableGrantsRequestStub = nil
	fake.listRetirableGrantsRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ListGrantsResponse
	}{result1, result2}
}

func (fake *FakeKMSClient) ListRetirableGrantsRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ListGrantsResponse) {
	fake.listRetirableGrantsRequestMutex.Lock()
	defer fake.listRetirableGrantsRequestMutex.Unlock()
	fake.ListRetirableGrantsRequestStub = nil
	if fake.listRetirableGrantsRequestReturnsOnCall == nil {
		fake.listRetirableGrantsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ListGrantsResponse
		})
	}
	fake.listRetirableGrantsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ListGrantsResponse
	}{result1, result2}
}

func (fake *FakeKMSClient) ListRetirableGrantsWithContext(arg1 context.Context, arg2 *kms.ListRetirableGrantsInput, arg3 ...request.Option) (*kms.ListGrantsResponse, error) {
	fake.listRetirableGrantsWithContextMutex.Lock()
	ret, specificReturn := fake.listRetirableGrantsWithContextReturnsOnCall[len(fake.listRetirableGrantsWithContextArgsForCall)]
	fake.listRetirableGrantsWithContextArgsForCall = append(fake.listRetirableGrantsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ListRetirableGrantsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ListRetirableGrantsWithContextStub
	fakeReturns := fake.listRetirableGrantsWithContextReturns
	fake.recordInvocation("ListRetirableGrantsWithContext", []interface{}{arg1, arg2, arg3})
	fake.listRetirableGrantsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ListRetirableGrantsWithContextCallCount() int {
	fake.listRetirableGrantsWithContextMutex.RLock()
	defer fake.listRetirableGrantsWithContextMutex.RUnlock()
	return len(fake.listRetirableGrantsWithContextArgsForCall)
}

func (fake *FakeKMSClient) ListRetirableGrantsWithContextCalls(stub func(context.Context, *kms.ListRetirableGrantsInput, ...request.Option) (*kms.ListGrantsResponse, error)) {
	fake.listRetirableGrantsWithContextMutex.Lock()
	defer fake.listRetirableGrantsWithContextMutex.Unlock()
	fake.ListRetirableGrantsWithContextStub = stub
}

func (fake *FakeKMSClient) ListRetirableGrantsWithContextArgsForCall(i int) (context.Context, *kms.ListRetirableGrantsInput, []request.Option) {
	fake.listRetirableGrantsWithContextMutex.RLock()
	defer fake.listRetirableGrantsWithContextMutex.RUnlock()
	argsForCall := fake.listRetirableGrantsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ListRetirableGrantsWithContextReturns(result1 *kms.ListGrantsResponse, result2 error) {
	fake.listRetirableGrantsWithContextMutex.Lock()
	defer fake.listRetirableGrantsWithContextMutex.Unlock()
	fake.ListRetirableGrantsWithContextStub = nil
	fake.listRetirableGrantsWithContextReturns = struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ListRetirableGrantsWithContextReturnsOnCall(i int, result1 *kms.ListGrantsResponse, result2 error) {
	fake.listRetirableGrantsWithContextMutex.Lock()
	defer fake.listRetirableGrantsWithContextMutex.Unlock()
	fake.ListRetirableGrantsWithContextStub = nil
	if fake.listRetirableGrantsWithContextReturnsOnCall == nil {
		fake.listRetirableGrantsWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ListGrantsResponse
			result2 error
		})
	}
	fake.listRetirableGrantsWithContextReturnsOnCall[i] = struct {
		result1 *kms.ListGrantsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) PutKeyPolicy(arg1 *kms.PutKeyPolicyInput) (*kms.PutKeyPolicyOutput, error) {
	fake.putKeyPolicyMutex.Lock()
	ret, specificReturn := fake.putKeyPolicyReturnsOnCall[len(fake.putKeyPolicyArgsForCall)]
	fake.putKeyPolicyArgsForCall = append(fake.putKeyPolicyArgsForCall, struct {
		arg1 *kms.PutKeyPolicyInput
	}{arg1})
	stub := fake.PutKeyPolicyStub
	fakeReturns := fake.putKeyPolicyReturns
	fake.recordInvocation("PutKeyPolicy", []interface{}{arg1})
	fake.putKeyPolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) PutKeyPolicyCallCount() int {
	fake.putKeyPolicyMutex.RLock()
	defer fake.putKeyPolicyMutex.RUnlock()
	return len(fake.putKeyPolicyArgsForCall)
}

func (fake *FakeKMSClient) PutKeyPolicyCalls(stub func(*kms.PutKeyPolicyInput) (*kms.PutKeyPolicyOutput, error)) {
	fake.putKeyPolicyMutex.Lock()
	defer fake.putKeyPolicyMutex.Unlock()
	fake.PutKeyPolicyStub = stub
}

func (fake *FakeKMSClient) PutKeyPolicyArgsForCall(i int) *kms.PutKeyPolicyInput {
	fake.putKeyPolicyMutex.RLock()
	defer fake.putKeyPolicyMutex.RUnlock()
	argsForCall := fake.putKeyPolicyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) PutKeyPolicyReturns(result1 *kms.PutKeyPolicyOutput, result2 error) {
	fake.putKeyPolicyMutex.Lock()
	defer fake.putKeyPolicyMutex.Unlock()
	fake.PutKeyPolicyStub = nil
	fake.putKeyPolicyReturns = struct {
		result1 *kms.PutKeyPolicyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) PutKeyPolicyReturnsOnCall(i int, result1 *kms.PutKeyPolicyOutput, result2 error) {
	fake.putKeyPolicyMutex.Lock()
	defer fake.putKeyPolicyMutex.Unlock()
	fake.PutKeyPolicyStub = nil
	if fake.putKeyPolicyReturnsOnCall == nil {
		fake.putKeyPolicyReturnsOnCall = make(map[int]struct {
			result1 *kms.PutKeyPolicyOutput
			result2 error
		})
	}
	fake.putKeyPolicyReturnsOnCall[i] = struct {
		result1 *kms.PutKeyPolicyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) PutKeyPolicyRequest(arg1 *kms.PutKeyPolicyInput) (*request.Request, *kms.PutKeyPolicyOutput) {
	fake.putKeyPolicyRequestMutex.Lock()
	ret, specificReturn := fake.putKeyPolicyRequestReturnsOnCall[len(fake.putKeyPolicyRequestArgsForCall)]
	fake.putKeyPolicyRequestArgsForCall = append(fake.putKeyPolicyRequestArgsForCall, struct {
		arg1 *kms.PutKeyPolicyInput
	}{arg1})
	stub := fake.PutKeyPolicyRequestStub
	fakeReturns := fake.putKeyPolicyRequestReturns
	fake.recordInvocation("PutKeyPolicyRequest", []interface{}{arg1})
	fake.putKeyPolicyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) PutKeyPolicyRequestCallCount() int {
	fake.putKeyPolicyRequestMutex.RLock()
	defer fake.putKeyPolicyRequestMutex.RUnlock()
	return len(fake.putKeyPolicyRequestArgsForCall)
}

func (fake *FakeKMSClient) PutKeyPolicyRequestCalls(stub func(*kms.PutKeyPolicyInput) (*request.Request, *kms.PutKeyPolicyOutput)) {
	fake.putKeyPolicyRequestMutex.Lock()
	defer fake.putKeyPolicyRequestMutex.Unlock()
	fake.PutKeyPolicyRequestStub = stub
}

func (fake *FakeKMSClient) PutKeyPolicyRequestArgsForCall(i int) *kms.PutKeyPolicyInput {
	fake.putKeyPolicyRequestMutex.RLock()
	defer fake.putKeyPolicyRequestMutex.RUnlock()
	argsForCall := fake.putKeyPolicyRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) PutKeyPolicyRequestReturns(result1 *request.Request, result2 *kms.PutKeyPolicyOutput) {
	fake.putKeyPolicyRequestMutex.Lock()
	defer fake.putKeyPolicyRequestMutex.Unlock()
	fake.PutKeyPolicyRequestStub = nil
	fake.putKeyPolicyRequestReturns = struct {
		result1 *request.Request
		result2 *kms.PutKeyPolicyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) PutKeyPolicyRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.PutKeyPolicyOutput) {
	fake.putKeyPolicyRequestMutex.Lock()
	defer fake.putKeyPolicyRequestMutex.Unlock()
	fake.PutKeyPolicyRequestStub = nil
	if fake.putKeyPolicyRequestReturnsOnCall == nil {
		fake.putKeyPolicyRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.PutKeyPolicyOutput
		})
	}
	fake.putKeyPolicyRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.PutKeyPolicyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) PutKeyPolicyWithContext(arg1 context.Context, arg2 *kms.PutKeyPolicyInput, arg3 ...request.Option) (*kms.PutKeyPolicyOutput, error) {
	fake.putKeyPolicyWithContextMutex.Lock()
	ret, specificReturn := fake.putKeyPolicyWithContextReturnsOnCall[len(fake.putKeyPolicyWithContextArgsForCall)]
	fake.putKeyPolicyWithContextArgsForCall = append(fake.putKeyPolicyWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.PutKeyPolicyInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.PutKeyPolicyWithContextStub
	fakeReturns := fake.putKeyPolicyWithContextReturns
	fake.recordInvocation("PutKeyPolicyWithContext", []interface{}{arg1, arg2, arg3})
	fake.putKeyPolicyWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) PutKeyPolicyWithContextCallCount() int {
	fake.putKeyPolicyWithContextMutex.RLock()
	defer fake.putKeyPolicyWithContextMutex.RUnlock()
	return len(fake.putKeyPolicyWithContextArgsForCall)
}

func (fake *FakeKMSClient) PutKeyPolicyWithContextCalls(stub func(context.Context, *kms.PutKeyPolicyInput, ...request.Option) (*kms.PutKeyPolicyOutput, error)) {
	fake.putKeyPolicyWithContextMutex.Lock()
	defer fake.putKeyPolicyWithContextMutex.Unlock()
	fake.PutKeyPolicyWithContextStub = stub
}

func (fake *FakeKMSClient) PutKeyPolicyWithContextArgsForCall(i int) (context.Context, *kms.PutKeyPolicyInput, []request.Option) {
	fake.putKeyPolicyWithContextMutex.RLock()
	defer fake.putKeyPolicyWithContextMutex.RUnlock()
	argsForCall := fake.putKeyPolicyWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) PutKeyPolicyWithContextReturns(result1 *kms.PutKeyPolicyOutput, result2 error) {
	fake.putKeyPolicyWithContextMutex.Lock()
	defer fake.putKeyPolicyWithContextMutex.Unlock()
	fake.PutKeyPolicyWithContextStub = nil
	fake.putKeyPolicyWithContextReturns = struct {
		result1 *kms.PutKeyPolicyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) PutKeyPolicyWithContextReturnsOnCall(i int, result1 *kms.PutKeyPolicyOutput, result2 error) {
	fake.putKeyPolicyWithContextMutex.Lock()
	defer fake.putKeyPolicyWithContextMutex.Unlock()
	fake.PutKeyPolicyWithContextStub = nil
	if fake.putKeyPolicyWithContextReturnsOnCall == nil {
		fake.putKeyPolicyWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.PutKeyPolicyOutput
			result2 error
		})
	}
	fake.putKeyPolicyWithContextReturnsOnCall[i] = struct {
		result1 *kms.PutKeyPolicyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ReEncrypt(arg1 *kms.ReEncryptInput) (*kms.ReEncryptOutput, error) {
	fake.reEncryptMutex.Lock()
	ret, specificReturn := fake.reEncryptReturnsOnCall[len(fake.reEncryptArgsForCall)]
	fake.reEncryptArgsForCall = append(fake.reEncryptArgsForCall, struct {
		arg1 *kms.ReEncryptInput
	}{arg1})
	stub := fake.ReEncryptStub
	fakeReturns := fake.reEncryptReturns
	fake.recordInvocation("ReEncrypt", []interface{}{arg1})
	fake.reEncryptMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ReEncryptCallCount() int {
	fake.reEncryptMutex.RLock()
	defer fake.reEncryptMutex.RUnlock()
	return len(fake.reEncryptArgsForCall)
}

func (fake *FakeKMSClient) ReEncryptCalls(stub func(*kms.ReEncryptInput) (*kms.ReEncryptOutput, error)) {
	fake.reEncryptMutex.Lock()
	defer fake.reEncryptMutex.Unlock()
	fake.ReEncryptStub = stub
}

func (fake *FakeKMSClient) ReEncryptArgsForCall(i int) *kms.ReEncryptInput {
	fake.reEncryptMutex.RLock()
	defer fake.reEncryptMutex.RUnlock()
	argsForCall := fake.reEncryptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ReEncryptReturns(result1 *kms.ReEncryptOutput, result2 error) {
	fake.reEncryptMutex.Lock()
	defer fake.reEncryptMutex.Unlock()
	fake.ReEncryptStub = nil
	fake.reEncryptReturns = struct {
		result1 *kms.ReEncryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ReEncryptReturnsOnCall(i int, result1 *kms.ReEncryptOutput, result2 error) {
	fake.reEncryptMutex.Lock()
	defer fake.reEncryptMutex.Unlock()
	fake.ReEncryptStub = nil
	if fake.reEncryptReturnsOnCall == nil {
		fake.reEncryptReturnsOnCall = make(map[int]struct {
			result1 *kms.ReEncryptOutput
			result2 error
		})
	}
	fake.reEncryptReturnsOnCall[i] = struct {
		result1 *kms.ReEncryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ReEncryptRequest(arg1 *kms.ReEncryptInput) (*request.Request, *kms.ReEncryptOutput) {
	fake.reEncryptRequestMutex.Lock()
	ret, specificReturn := fake.reEncryptRequestReturnsOnCall[len(fake.reEncryptRequestArgsForCall)]
	fake.reEncryptRequestArgsForCall = append(fake.reEncryptRequestArgsForCall, struct {
		arg1 *kms.ReEncryptInput
	}{arg1})
	stub := fake.ReEncryptRequestStub
	fakeReturns := fake.reEncryptRequestReturns
	fake.recordInvocation("ReEncryptRequest", []interface{}{arg1})
	fake.reEncryptRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ReEncryptRequestCallCount() int {
	fake.reEncryptRequestMutex.RLock()
	defer fake.reEncryptRequestMutex.RUnlock()
	return len(fake.reEncryptRequestArgsForCall)
}

func (fake *FakeKMSClient) ReEncryptRequestCalls(stub func(*kms.ReEncryptInput) (*request.Request, *kms.ReEncryptOutput)) {
	fake.reEncryptRequestMutex.Lock()
	defer fake.reEncryptRequestMutex.Unlock()
	fake.ReEncryptRequestStub = stub
}

func (fake *FakeKMSClient) ReEncryptRequestArgsForCall(i int) *kms.ReEncryptInput {
	fake.reEncryptRequestMutex.RLock()
	defer fake.reEncryptRequestMutex.RUnlock()
	argsForCall := fake.reEncryptRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ReEncryptRequestReturns(result1 *request.Request, result2 *kms.ReEncryptOutput) {
	fake.reEncryptRequestMutex.Lock()
	defer fake.reEncryptRequestMutex.Unlock()
	fake.ReEncryptRequestStub = nil
	fake.reEncryptRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ReEncryptOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ReEncryptRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ReEncryptOutput) {
	fake.reEncryptRequestMutex.Lock()
	defer fake.reEncryptRequestMutex.Unlock()
	fake.ReEncryptRequestStub = nil
	if fake.reEncryptRequestReturnsOnCall == nil {
		fake.reEncryptRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ReEncryptOutput
		})
	}
	fake.reEncryptRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ReEncryptOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ReEncryptWithContext(arg1 context.Context, arg2 *kms.ReEncryptInput, arg3 ...request.Option) (*kms.ReEncryptOutput, error) {
	fake.reEncryptWithContextMutex.Lock()
	ret, specificReturn := fake.reEncryptWithContextReturnsOnCall[len(fake.reEncryptWithContextArgsForCall)]
	fake.reEncryptWithContextArgsForCall = append(fake.reEncryptWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ReEncryptInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ReEncryptWithContextStub
	fakeReturns := fake.reEncryptWithContextReturns
	fake.recordInvocation("ReEncryptWithContext", []interface{}{arg1, arg2, arg3})
	fake.reEncryptWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ReEncryptWithContextCallCount() int {
	fake.reEncryptWithContextMutex.RLock()
	defer fake.reEncryptWithContextMutex.RUnlock()
	return len(fake.reEncryptWithContextArgsForCall)
}

func (fake *FakeKMSClient) ReEncryptWithContextCalls(stub func(context.Context, *kms.ReEncryptInput, ...request.Option) (*kms.ReEncryptOutput, error)) {
	fake.reEncryptWithContextMutex.Lock()
	defer fake.reEncryptWithContextMutex.Unlock()
	fake.ReEncryptWithContextStub = stub
}

func (fake *FakeKMSClient) ReEncryptWithContextArgsForCall(i int) (context.Context, *kms.ReEncryptInput, []request.Option) {
	fake.reEncryptWithContextMutex.RLock()
	defer fake.reEncryptWithContextMutex.RUnlock()
	argsForCall := fake.reEncryptWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ReEncryptWithContextReturns(result1 *kms.ReEncryptOutput, result2 error) {
	fake.reEncryptWithContextMutex.Lock()
	defer fake.reEncryptWithContextMutex.Unlock()
	fake.ReEncryptWithContextStub = nil
	fake.reEncryptWithContextReturns = struct {
		result1 *kms.ReEncryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ReEncryptWithContextReturnsOnCall(i int, result1 *kms.ReEncryptOutput, result2 error) {
	fake.reEncryptWithContextMutex.Lock()
	defer fake.reEncryptWithContextMutex.Unlock()
	fake.ReEncryptWithContextStub = nil
	if fake.reEncryptWithContextReturnsOnCall == nil {
		fake.reEncryptWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ReEncryptOutput
			result2 error
		})
	}
	fake.reEncryptWithContextReturnsOnCall[i] = struct {
		result1 *kms.ReEncryptOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ReplicateKey(arg1 *kms.ReplicateKeyInput) (*kms.ReplicateKeyOutput, error) {
	fake.replicateKeyMutex.Lock()
	ret, specificReturn := fake.replicateKeyReturnsOnCall[len(fake.replicateKeyArgsForCall)]
	fake.replicateKeyArgsForCall = append(fake.replicateKeyArgsForCall, struct {
		arg1 *kms.ReplicateKeyInput
	}{arg1})
	stub := fake.ReplicateKeyStub
	fakeReturns := fake.replicateKeyReturns
	fake.recordInvocation("ReplicateKey", []interface{}{arg1})
	fake.replicateKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ReplicateKeyCallCount() int {
	fake.replicateKeyMutex.RLock()
	defer fake.replicateKeyMutex.RUnlock()
	return len(fake.replicateKeyArgsForCall)
}

func (fake *FakeKMSClient) ReplicateKeyCalls(stub func(*kms.ReplicateKeyInput) (*kms.ReplicateKeyOutput, error)) {
	fake.replicateKeyMutex.Lock()
	defer fake.replicateKeyMutex.Unlock()
	fake.ReplicateKeyStub = stub
}

func (fake *FakeKMSClient) ReplicateKeyArgsForCall(i int) *kms.ReplicateKeyInput {
	fake.replicateKeyMutex.RLock()
	defer fake.replicateKeyMutex.RUnlock()
	argsForCall := fake.replicateKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ReplicateKeyReturns(result1 *kms.ReplicateKeyOutput, result2 error) {
	fake.replicateKeyMutex.Lock()
	defer fake.replicateKeyMutex.Unlock()
	fake.ReplicateKeyStub = nil
	fake.replicateKeyReturns = struct {
		result1 *kms.ReplicateKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ReplicateKeyReturnsOnCall(i int, result1 *kms.ReplicateKeyOutput, result2 error) {
	fake.replicateKeyMutex.Lock()
	defer fake.replicateKeyMutex.Unlock()
	fake.ReplicateKeyStub = nil
	if fake.replicateKeyReturnsOnCall == nil {
		fake.replicateKeyReturnsOnCall = make(map[int]struct {
			result1 *kms.ReplicateKeyOutput
			result2 error
		})
	}
	fake.replicateKeyReturnsOnCall[i] = struct {
		result1 *kms.ReplicateKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ReplicateKeyRequest(arg1 *kms.ReplicateKeyInput) (*request.Request, *kms.ReplicateKeyOutput) {
	fake.replicateKeyRequestMutex.Lock()
	ret, specificReturn := fake.replicateKeyRequestReturnsOnCall[len(fake.replicateKeyRequestArgsForCall)]
	fake.replicateKeyRequestArgsForCall = append(fake.replicateKeyRequestArgsForCall, struct {
		arg1 *kms.ReplicateKeyInput
	}{arg1})
	stub := fake.ReplicateKeyRequestStub
	fakeReturns := fake.replicateKeyRequestReturns
	fake.recordInvocation("ReplicateKeyRequest", []interface{}{arg1})
	fake.replicateKeyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ReplicateKeyRequestCallCount() int {
	fake.replicateKeyRequestMutex.RLock()
	defer fake.replicateKeyRequestMutex.RUnlock()
	return len(fake.replicateKeyRequestArgsForCall)
}

func (fake *FakeKMSClient) ReplicateKeyRequestCalls(stub func(*kms.ReplicateKeyInput) (*request.Request, *kms.ReplicateKeyOutput)) {
	fake.replicateKeyRequestMutex.Lock()
	defer fake.replicateKeyRequestMutex.Unlock()
	fake.ReplicateKeyRequestStub = stub
}

func (fake *FakeKMSClient) ReplicateKeyRequestArgsForCall(i int) *kms.ReplicateKeyInput {
	fake.replicateKeyRequestMutex.RLock()
	defer fake.replicateKeyRequestMutex.RUnlock()
	argsForCall := fake.replicateKeyRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ReplicateKeyRequestReturns(result1 *request.Request, result2 *kms.ReplicateKeyOutput) {
	fake.replicateKeyRequestMutex.Lock()
	defer fake.replicateKeyRequestMutex.Unlock()
	fake.ReplicateKeyRequestStub = nil
	fake.replicateKeyRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ReplicateKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ReplicateKeyRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ReplicateKeyOutput) {
	fake.replicateKeyRequestMutex.Lock()
	defer fake.replicateKeyRequestMutex.Unlock()
	fake.ReplicateKeyRequestStub = nil
	if fake.replicateKeyRequestReturnsOnCall == nil {
		fake.replicateKeyRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ReplicateKeyOutput
		})
	}
	fake.replicateKeyRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ReplicateKeyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ReplicateKeyWithContext(arg1 context.Context, arg2 *kms.ReplicateKeyInput, arg3 ...request.Option) (*kms.ReplicateKeyOutput, error) {
	fake.replicateKeyWithContextMutex.Lock()
	ret, specificReturn := fake.replicateKeyWithContextReturnsOnCall[len(fake.replicateKeyWithContextArgsForCall)]
	fake.replicateKeyWithContextArgsForCall = append(fake.replicateKeyWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ReplicateKeyInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ReplicateKeyWithContextStub
	fakeReturns := fake.replicateKeyWithContextReturns
	fake.recordInvocation("ReplicateKeyWithContext", []interface{}{arg1, arg2, arg3})
	fake.replicateKeyWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ReplicateKeyWithContextCallCount() int {
	fake.replicateKeyWithContextMutex.RLock()
	defer fake.replicateKeyWithContextMutex.RUnlock()
	return len(fake.replicateKeyWithContextArgsForCall)
}

func (fake *FakeKMSClient) ReplicateKeyWithContextCalls(stub func(context.Context, *kms.ReplicateKeyInput, ...request.Option) (*kms.ReplicateKeyOutput, error)) {
	fake.replicateKeyWithContextMutex.Lock()
	defer fake.replicateKeyWithContextMutex.Unlock()
	fake.ReplicateKeyWithContextStub = stub
}

func (fake *FakeKMSClient) ReplicateKeyWithContextArgsForCall(i int) (context.Context, *kms.ReplicateKeyInput, []request.Option) {
	fake.replicateKeyWithContextMutex.RLock()
	defer fake.replicateKeyWithContextMutex.RUnlock()
	argsForCall := fake.replicateKeyWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ReplicateKeyWithContextReturns(result1 *kms.ReplicateKeyOutput, result2 error) {
	fake.replicateKeyWithContextMutex.Lock()
	defer fake.replicateKeyWithContextMutex.Unlock()
	fake.ReplicateKeyWithContextStub = nil
	fake.replicateKeyWithContextReturns = struct {
		result1 *kms.ReplicateKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ReplicateKeyWithContextReturnsOnCall(i int, result1 *kms.ReplicateKeyOutput, result2 error) {
	fake.replicateKeyWithContextMutex.Lock()
	defer fake.replicateKeyWithContextMutex.Unlock()
	fake.ReplicateKeyWithContextStub = nil
	if fake.replicateKeyWithContextReturnsOnCall == nil {
		fake.replicateKeyWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ReplicateKeyOutput
			result2 error
		})
	}
	fake.replicateKeyWithContextReturnsOnCall[i] = struct {
		result1 *kms.ReplicateKeyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) RetireGrant(arg1 *kms.RetireGrantInput) (*kms.RetireGrantOutput, error) {
	fake.retireGrantMutex.Lock()
	ret, specificReturn := fake.retireGrantReturnsOnCall[len(fake.retireGrantArgsForCall)]
	fake.retireGrantArgsForCall = append(fake.retireGrantArgsForCall, struct {
		arg1 *kms.RetireGrantInput
	}{arg1})
	stub := fake.RetireGrantStub
	fakeReturns := fake.retireGrantReturns
	fake.recordInvocation("RetireGrant", []interface{}{arg1})
	fake.retireGrantMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) RetireGrantCallCount() int {
	fake.retireGrantMutex.RLock()
	defer fake.retireGrantMutex.RUnlock()
	return len(fake.retireGrantArgsForCall)
}

func (fake *FakeKMSClient) RetireGrantCalls(stub func(*kms.RetireGrantInput) (*kms.RetireGrantOutput, error)) {
	fake.retireGrantMutex.Lock()
	defer fake.retireGrantMutex.Unlock()
	fake.RetireGrantStub = stub
}

func (fake *FakeKMSClient) RetireGrantArgsForCall(i int) *kms.RetireGrantInput {
	fake.retireGrantMutex.RLock()
	defer fake.retireGrantMutex.RUnlock()
	argsForCall := fake.retireGrantArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) RetireGrantReturns(result1 *kms.RetireGrantOutput, result2 error) {
	fake.retireGrantMutex.Lock()
	defer fake.retireGrantMutex.Unlock()
	fake.RetireGrantStub = nil
	fake.retireGrantReturns = struct {
		result1 *kms.RetireGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) RetireGrantReturnsOnCall(i int, result1 *kms.RetireGrantOutput, result2 error) {
	fake.retireGrantMutex.Lock()
	defer fake.retireGrantMutex.Unlock()
	fake.RetireGrantStub = nil
	if fake.retireGrantReturnsOnCall == nil {
		fake.retireGrantReturnsOnCall = make(map[int]struct {
			result1 *kms.RetireGrantOutput
			result2 error
		})
	}
	fake.retireGrantReturnsOnCall[i] = struct {
		result1 *kms.RetireGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) RetireGrantRequest(arg1 *kms.RetireGrantInput) (*request.Request, *kms.RetireGrantOutput) {
	fake.retireGrantRequestMutex.Lock()
	ret, specificReturn := fake.retireGrantRequestReturnsOnCall[len(fake.retireGrantRequestArgsForCall)]
	fake.retireGrantRequestArgsForCall = append(fake.retireGrantRequestArgsForCall, struct {
		arg1 *kms.RetireGrantInput
	}{arg1})
	stub := fake.RetireGrantRequestStub
	fakeReturns := fake.retireGrantRequestReturns
	fake.recordInvocation("RetireGrantRequest", []interface{}{arg1})
	fake.retireGrantRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) RetireGrantRequestCallCount() int {
	fake.retireGrantRequestMutex.RLock()
	defer fake.retireGrantRequestMutex.RUnlock()
	return len(fake.retireGrantRequestArgsForCall)
}

func (fake *FakeKMSClient) RetireGrantRequestCalls(stub func(*kms.RetireGrantInput) (*request.Request, *kms.RetireGrantOutput)) {
	fake.retireGrantRequestMutex.Lock()
	defer fake.retireGrantRequestMutex.Unlock()
	fake.RetireGrantRequestStub = stub
}

func (fake *FakeKMSClient) RetireGrantRequestArgsForCall(i int) *kms.RetireGrantInput {
	fake.retireGrantRequestMutex.RLock()
	defer fake.retireGrantRequestMutex.RUnlock()
	argsForCall := fake.retireGrantRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) RetireGrantRequestReturns(result1 *request.Request, result2 *kms.RetireGrantOutput) {
	fake.retireGrantRequestMutex.Lock()
	defer fake.retireGrantRequestMutex.Unlock()
	fake.RetireGrantRequestStub = nil
	fake.retireGrantRequestReturns = struct {
		result1 *request.Request
		result2 *kms.RetireGrantOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) RetireGrantRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.RetireGrantOutput) {
	fake.retireGrantRequestMutex.Lock()
	defer fake.retireGrantRequestMutex.Unlock()
	fake.RetireGrantRequestStub = nil
	if fake.retireGrantRequestReturnsOnCall == nil {
		fake.retireGrantRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.RetireGrantOutput
		})
	}
	fake.retireGrantRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.RetireGrantOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) RetireGrantWithContext(arg1 context.Context, arg2 *kms.RetireGrantInput, arg3 ...request.Option) (*kms.RetireGrantOutput, error) {
	fake.retireGrantWithContextMutex.Lock()
	ret, specificReturn := fake.retireGrantWithContextReturnsOnCall[len(fake.retireGrantWithContextArgsForCall)]
	fake.retireGrantWithContextArgsForCall = append(fake.retireGrantWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.RetireGrantInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.RetireGrantWithContextStub
	fakeReturns := fake.retireGrantWithContextReturns
	fake.recordInvocation("RetireGrantWithContext", []interface{}{arg1, arg2, arg3})
	fake.retireGrantWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) RetireGrantWithContextCallCount() int {
	fake.retireGrantWithContextMutex.RLock()
	defer fake.retireGrantWithContextMutex.RUnlock()
	return len(fake.retireGrantWithContextArgsForCall)
}

func (fake *FakeKMSClient) RetireGrantWithContextCalls(stub func(context.Context, *kms.RetireGrantInput, ...request.Option) (*kms.RetireGrantOutput, error)) {
	fake.retireGrantWithContextMutex.Lock()
	defer fake.retireGrantWithContextMutex.Unlock()
	fake.RetireGrantWithContextStub = stub
}

func (fake *FakeKMSClient) RetireGrantWithContextArgsForCall(i int) (context.Context, *kms.RetireGrantInput, []request.Option) {
	fake.retireGrantWithContextMutex.RLock()
	defer fake.retireGrantWithContextMutex.RUnlock()
	argsForCall := fake.retireGrantWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) RetireGrantWithContextReturns(result1 *kms.RetireGrantOutput, result2 error) {
	fake.retireGrantWithContextMutex.Lock()
	defer fake.retireGrantWithContextMutex.Unlock()
	fake.RetireGrantWithContextStub = nil
	fake.retireGrantWithContextReturns = struct {
		result1 *kms.RetireGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) RetireGrantWithContextReturnsOnCall(i int, result1 *kms.RetireGrantOutput, result2 error) {
	fake.retireGrantWithContextMutex.Lock()
	defer fake.retireGrantWithContextMutex.Unlock()
	fake.RetireGrantWithContextStub = nil
	if fake.retireGrantWithContextReturnsOnCall == nil {
		fake.retireGrantWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.RetireGrantOutput
			result2 error
		})
	}
	fake.retireGrantWithContextReturnsOnCall[i] = struct {
		result1 *kms.RetireGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) RevokeGrant(arg1 *kms.RevokeGrantInput) (*kms.RevokeGrantOutput, error) {
	fake.revokeGrantMutex.Lock()
	ret, specificReturn := fake.revokeGrantReturnsOnCall[len(fake.revokeGrantArgsForCall)]
	fake.revokeGrantArgsForCall = append(fake.revokeGrantArgsForCall, struct {
		arg1 *kms.RevokeGrantInput
	}{arg1})
	stub := fake.RevokeGrantStub
	fakeReturns := fake.revokeGrantReturns
	fake.recordInvocation("RevokeGrant", []interface{}{arg1})
	fake.revokeGrantMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) RevokeGrantCallCount() int {
	fake.revokeGrantMutex.RLock()
	defer fake.revokeGrantMutex.RUnlock()
	return len(fake.revokeGrantArgsForCall)
}

func (fake *FakeKMSClient) RevokeGrantCalls(stub func(*kms.RevokeGrantInput) (*kms.RevokeGrantOutput, error)) {
	fake.revokeGrantMutex.Lock()
	defer fake.revokeGrantMutex.Unlock()
	fake.RevokeGrantStub = stub
}

func (fake *FakeKMSClient) RevokeGrantArgsForCall(i int) *kms.RevokeGrantInput {
	fake.revokeGrantMutex.RLock()
	defer fake.revokeGrantMutex.RUnlock()
	argsForCall := fake.revokeGrantArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) RevokeGrantReturns(result1 *kms.RevokeGrantOutput, result2 error) {
	fake.revokeGrantMutex.Lock()
	defer fake.revokeGrantMutex.Unlock()
	fake.RevokeGrantStub = nil
	fake.revokeGrantReturns = struct {
		result1 *kms.RevokeGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) RevokeGrantReturnsOnCall(i int, result1 *kms.RevokeGrantOutput, result2 error) {
	fake.revokeGrantMutex.Lock()
	defer fake.revokeGrantMutex.Unlock()
	fake.RevokeGrantStub = nil
	if fake.revokeGrantReturnsOnCall == nil {
		fake.revokeGrantReturnsOnCall = make(map[int]struct {
			result1 *kms.RevokeGrantOutput
			result2 error
		})
	}
	fake.revokeGrantReturnsOnCall[i] = struct {
		result1 *kms.RevokeGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) RevokeGrantRequest(arg1 *kms.RevokeGrantInput) (*request.Request, *kms.RevokeGrantOutput) {
	fake.revokeGrantRequestMutex.Lock()
	ret, specificReturn := fake.revokeGrantRequestReturnsOnCall[len(fake.revokeGrantRequestArgsForCall)]
	fake.revokeGrantRequestArgsForCall = append(fake.revokeGrantRequestArgsForCall, struct {
		arg1 *kms.RevokeGrantInput
	}{arg1})
	stub := fake.RevokeGrantRequestStub
	fakeReturns := fake.revokeGrantRequestReturns
	fake.recordInvocation("RevokeGrantRequest", []interface{}{arg1})
	fake.revokeGrantRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) RevokeGrantRequestCallCount() int {
	fake.revokeGrantRequestMutex.RLock()
	defer fake.revokeGrantRequestMutex.RUnlock()
	return len(fake.revokeGrantRequestArgsForCall)
}

func (fake *FakeKMSClient) RevokeGrantRequestCalls(stub func(*kms.RevokeGrantInput) (*request.Request, *kms.RevokeGrantOutput)) {
	fake.revokeGrantRequestMutex.Lock()
	defer fake.revokeGrantRequestMutex.Unlock()
	fake.RevokeGrantRequestStub = stub
}

func (fake *FakeKMSClient) RevokeGrantRequestArgsForCall(i int) *kms.RevokeGrantInput {
	fake.revokeGrantRequestMutex.RLock()
	defer fake.revokeGrantRequestMutex.RUnlock()
	argsForCall := fake.revokeGrantRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) RevokeGrantRequestReturns(result1 *request.Request, result2 *kms.RevokeGrantOutput) {
	fake.revokeGrantRequestMutex.Lock()
	defer fake.revokeGrantRequestMutex.Unlock()
	fake.RevokeGrantRequestStub = nil
	fake.revokeGrantRequestReturns = struct {
		result1 *request.Request
		result2 *kms.RevokeGrantOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) RevokeGrantRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.RevokeGrantOutput) {
	fake.revokeGrantRequestMutex.Lock()
	defer fake.revokeGrantRequestMutex.Unlock()
	fake.RevokeGrantRequestStub = nil
	if fake.revokeGrantRequestReturnsOnCall == nil {
		fake.revokeGrantRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.RevokeGrantOutput
		})
	}
	fake.revokeGrantRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.RevokeGrantOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) RevokeGrantWithContext(arg1 context.Context, arg2 *kms.RevokeGrantInput, arg3 ...request.Option) (*kms.RevokeGrantOutput, error) {
	fake.revokeGrantWithContextMutex.Lock()
	ret, specificReturn := fake.revokeGrantWithContextReturnsOnCall[len(fake.revokeGrantWithContextArgsForCall)]
	fake.revokeGrantWithContextArgsForCall = append(fake.revokeGrantWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.RevokeGrantInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.RevokeGrantWithContextStub
	fakeReturns := fake.revokeGrantWithContextReturns
	fake.recordInvocation("RevokeGrantWithContext", []interface{}{arg1, arg2, arg3})
	fake.revokeGrantWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) RevokeGrantWithContextCallCount() int {
	fake.revokeGrantWithContextMutex.RLock()
	defer fake.revokeGrantWithContextMutex.RUnlock()
	return len(fake.revokeGrantWithContextArgsForCall)
}

func (fake *FakeKMSClient) RevokeGrantWithContextCalls(stub func(context.Context, *kms.RevokeGrantInput, ...request.Option) (*kms.RevokeGrantOutput, error)) {
	fake.revokeGrantWithContextMutex.Lock()
	defer fake.revokeGrantWithContextMutex.Unlock()
	fake.RevokeGrantWithContextStub = stub
}

func (fake *FakeKMSClient) RevokeGrantWithContextArgsForCall(i int) (context.Context, *kms.RevokeGrantInput, []request.Option) {
	fake.revokeGrantWithContextMutex.RLock()
	defer fake.revokeGrantWithContextMutex.RUnlock()
	argsForCall := fake.revokeGrantWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) RevokeGrantWithContextReturns(result1 *kms.RevokeGrantOutput, result2 error) {
	fake.revokeGrantWithContextMutex.Lock()
	defer fake.revokeGrantWithContextMutex.Unlock()
	fake.RevokeGrantWithContextStub = nil
	fake.revokeGrantWithContextReturns = struct {
		result1 *kms.RevokeGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) RevokeGrantWithContextReturnsOnCall(i int, result1 *kms.RevokeGrantOutput, result2 error) {
	fake.revokeGrantWithContextMutex.Lock()
	defer fake.revokeGrantWithContextMutex.Unlock()
	fake.RevokeGrantWithContextStub = nil
	if fake.revokeGrantWithContextReturnsOnCall == nil {
		fake.revokeGrantWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.RevokeGrantOutput
			result2 error
		})
	}
	fake.revokeGrantWithContextReturnsOnCall[i] = struct {
		result1 *kms.RevokeGrantOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ScheduleKeyDeletion(arg1 *kms.ScheduleKeyDeletionInput) (*kms.ScheduleKeyDeletionOutput, error) {
	fake.scheduleKeyDeletionMutex.Lock()
	ret, specificReturn := fake.scheduleKeyDeletionReturnsOnCall[len(fake.scheduleKeyDeletionArgsForCall)]
	fake.scheduleKeyDeletionArgsForCall = append(fake.scheduleKeyDeletionArgsForCall, struct {
		arg1 *kms.ScheduleKeyDeletionInput
	}{arg1})
	stub := fake.ScheduleKeyDeletionStub
	fakeReturns := fake.scheduleKeyDeletionReturns
	fake.recordInvocation("ScheduleKeyDeletion", []interface{}{arg1})
	fake.scheduleKeyDeletionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ScheduleKeyDeletionCallCount() int {
	fake.scheduleKeyDeletionMutex.RLock()
	defer fake.scheduleKeyDeletionMutex.RUnlock()
	return len(fake.scheduleKeyDeletionArgsForCall)
}

func (fake *FakeKMSClient) ScheduleKeyDeletionCalls(stub func(*kms.ScheduleKeyDeletionInput) (*kms.ScheduleKeyDeletionOutput, error)) {
	fake.scheduleKeyDeletionMutex.Lock()
	defer fake.scheduleKeyDeletionMutex.Unlock()
	fake.ScheduleKeyDeletionStub = stub
}

func (fake *FakeKMSClient) ScheduleKeyDeletionArgsForCall(i int) *kms.ScheduleKeyDeletionInput {
	fake.scheduleKeyDeletionMutex.RLock()
	defer fake.scheduleKeyDeletionMutex.RUnlock()
	argsForCall := fake.scheduleKeyDeletionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ScheduleKeyDeletionReturns(result1 *kms.ScheduleKeyDeletionOutput, result2 error) {
	fake.scheduleKeyDeletionMutex.Lock()
	defer fake.scheduleKeyDeletionMutex.Unlock()
	fake.ScheduleKeyDeletionStub = nil
	fake.scheduleKeyDeletionReturns = struct {
		result1 *kms.ScheduleKeyDeletionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ScheduleKeyDeletionReturnsOnCall(i int, result1 *kms.ScheduleKeyDeletionOutput, result2 error) {
	fake.scheduleKeyDeletionMutex.Lock()
	defer fake.scheduleKeyDeletionMutex.Unlock()
	fake.ScheduleKeyDeletionStub = nil
	if fake.scheduleKeyDeletionReturnsOnCall == nil {
		fake.scheduleKeyDeletionReturnsOnCall = make(map[int]struct {
			result1 *kms.ScheduleKeyDeletionOutput
			result2 error
		})
	}
	fake.scheduleKeyDeletionReturnsOnCall[i] = struct {
		result1 *kms.ScheduleKeyDeletionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ScheduleKeyDeletionRequest(arg1 *kms.ScheduleKeyDeletionInput) (*request.Request, *kms.ScheduleKeyDeletionOutput) {
	fake.scheduleKeyDeletionRequestMutex.Lock()
	ret, specificReturn := fake.scheduleKeyDeletionRequestReturnsOnCall[len(fake.scheduleKeyDeletionRequestArgsForCall)]
	fake.scheduleKeyDeletionRequestArgsForCall = append(fake.scheduleKeyDeletionRequestArgsForCall, struct {
		arg1 *kms.ScheduleKeyDeletionInput
	}{arg1})
	stub := fake.ScheduleKeyDeletionRequestStub
	fakeReturns := fake.scheduleKeyDeletionRequestReturns
	fake.recordInvocation("ScheduleKeyDeletionRequest", []interface{}{arg1})
	fake.scheduleKeyDeletionRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ScheduleKeyDeletionRequestCallCount() int {
	fake.scheduleKeyDeletionRequestMutex.RLock()
	defer fake.scheduleKeyDeletionRequestMutex.RUnlock()
	return len(fake.scheduleKeyDeletionRequestArgsForCall)
}

func (fake *FakeKMSClient) ScheduleKeyDeletionRequestCalls(stub func(*kms.ScheduleKeyDeletionInput) (*request.Request, *kms.ScheduleKeyDeletionOutput)) {
	fake.scheduleKeyDeletionRequestMutex.Lock()
	defer fake.scheduleKeyDeletionRequestMutex.Unlock()
	fake.ScheduleKeyDeletionRequestStub = stub
}

func (fake *FakeKMSClient) ScheduleKeyDeletionRequestArgsForCall(i int) *kms.ScheduleKeyDeletionInput {
	fake.scheduleKeyDeletionRequestMutex.RLock()
	defer fake.scheduleKeyDeletionRequestMutex.RUnlock()
	argsForCall := fake.scheduleKeyDeletionRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) ScheduleKeyDeletionRequestReturns(result1 *request.Request, result2 *kms.ScheduleKeyDeletionOutput) {
	fake.scheduleKeyDeletionRequestMutex.Lock()
	defer fake.scheduleKeyDeletionRequestMutex.Unlock()
	fake.ScheduleKeyDeletionRequestStub = nil
	fake.scheduleKeyDeletionRequestReturns = struct {
		result1 *request.Request
		result2 *kms.ScheduleKeyDeletionOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ScheduleKeyDeletionRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.ScheduleKeyDeletionOutput) {
	fake.scheduleKeyDeletionRequestMutex.Lock()
	defer fake.scheduleKeyDeletionRequestMutex.Unlock()
	fake.ScheduleKeyDeletionRequestStub = nil
	if fake.scheduleKeyDeletionRequestReturnsOnCall == nil {
		fake.scheduleKeyDeletionRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.ScheduleKeyDeletionOutput
		})
	}
	fake.scheduleKeyDeletionRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.ScheduleKeyDeletionOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) ScheduleKeyDeletionWithContext(arg1 context.Context, arg2 *kms.ScheduleKeyDeletionInput, arg3 ...request.Option) (*kms.ScheduleKeyDeletionOutput, error) {
	fake.scheduleKeyDeletionWithContextMutex.Lock()
	ret, specificReturn := fake.scheduleKeyDeletionWithContextReturnsOnCall[len(fake.scheduleKeyDeletionWithContextArgsForCall)]
	fake.scheduleKeyDeletionWithContextArgsForCall = append(fake.scheduleKeyDeletionWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.ScheduleKeyDeletionInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ScheduleKeyDeletionWithContextStub
	fakeReturns := fake.scheduleKeyDeletionWithContextReturns
	fake.recordInvocation("ScheduleKeyDeletionWithContext", []interface{}{arg1, arg2, arg3})
	fake.scheduleKeyDeletionWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) ScheduleKeyDeletionWithContextCallCount() int {
	fake.scheduleKeyDeletionWithContextMutex.RLock()
	defer fake.scheduleKeyDeletionWithContextMutex.RUnlock()
	return len(fake.scheduleKeyDeletionWithContextArgsForCall)
}

func (fake *FakeKMSClient) ScheduleKeyDeletionWithContextCalls(stub func(context.Context, *kms.ScheduleKeyDeletionInput, ...request.Option) (*kms.ScheduleKeyDeletionOutput, error)) {
	fake.scheduleKeyDeletionWithContextMutex.Lock()
	defer fake.scheduleKeyDeletionWithContextMutex.Unlock()
	fake.ScheduleKeyDeletionWithContextStub = stub
}

func (fake *FakeKMSClient) ScheduleKeyDeletionWithContextArgsForCall(i int) (context.Context, *kms.ScheduleKeyDeletionInput, []request.Option) {
	fake.scheduleKeyDeletionWithContextMutex.RLock()
	defer fake.scheduleKeyDeletionWithContextMutex.RUnlock()
	argsForCall := fake.scheduleKeyDeletionWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) ScheduleKeyDeletionWithContextReturns(result1 *kms.ScheduleKeyDeletionOutput, result2 error) {
	fake.scheduleKeyDeletionWithContextMutex.Lock()
	defer fake.scheduleKeyDeletionWithContextMutex.Unlock()
	fake.ScheduleKeyDeletionWithContextStub = nil
	fake.scheduleKeyDeletionWithContextReturns = struct {
		result1 *kms.ScheduleKeyDeletionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) ScheduleKeyDeletionWithContextReturnsOnCall(i int, result1 *kms.ScheduleKeyDeletionOutput, result2 error) {
	fake.scheduleKeyDeletionWithContextMutex.Lock()
	defer fake.scheduleKeyDeletionWithContextMutex.Unlock()
	fake.ScheduleKeyDeletionWithContextStub = nil
	if fake.scheduleKeyDeletionWithContextReturnsOnCall == nil {
		fake.scheduleKeyDeletionWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.ScheduleKeyDeletionOutput
			result2 error
		})
	}
	fake.scheduleKeyDeletionWithContextReturnsOnCall[i] = struct {
		result1 *kms.ScheduleKeyDeletionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) Sign(arg1 *kms.SignInput) (*kms.SignOutput, error) {
	fake.signMutex.Lock()
	ret, specificReturn := fake.signReturnsOnCall[len(fake.signArgsForCall)]
	fake.signArgsForCall = append(fake.signArgsForCall, struct {
		arg1 *kms.SignInput
	}{arg1})
	stub := fake.SignStub
	fakeReturns := fake.signReturns
	fake.recordInvocation("Sign", []interface{}{arg1})
	fake.signMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) SignCallCount() int {
	fake.signMutex.RLock()
	defer fake.signMutex.RUnlock()
	return len(fake.signArgsForCall)
}

func (fake *FakeKMSClient) SignCalls(stub func(*kms.SignInput) (*kms.SignOutput, error)) {
	fake.signMutex.Lock()
	defer fake.signMutex.Unlock()
	fake.SignStub = stub
}

func (fake *FakeKMSClient) SignArgsForCall(i int) *kms.SignInput {
	fake.signMutex.RLock()
	defer fake.signMutex.RUnlock()
	argsForCall := fake.signArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) SignReturns(result1 *kms.SignOutput, result2 error) {
	fake.signMutex.Lock()
	defer fake.signMutex.Unlock()
	fake.SignStub = nil
	fake.signReturns = struct {
		result1 *kms.SignOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) SignReturnsOnCall(i int, result1 *kms.SignOutput, result2 error) {
	fake.signMutex.Lock()
	defer fake.signMutex.Unlock()
	fake.SignStub = nil
	if fake.signReturnsOnCall == nil {
		fake.signReturnsOnCall = make(map[int]struct {
			result1 *kms.SignOutput
			result2 error
		})
	}
	fake.signReturnsOnCall[i] = struct {
		result1 *kms.SignOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) SignRequest(arg1 *kms.SignInput) (*request.Request, *kms.SignOutput) {
	fake.signRequestMutex.Lock()
	ret, specificReturn := fake.signRequestReturnsOnCall[len(fake.signRequestArgsForCall)]
	fake.signRequestArgsForCall = append(fake.signRequestArgsForCall, struct {
		arg1 *kms.SignInput
	}{arg1})
	stub := fake.SignRequestStub
	fakeReturns := fake.signRequestReturns
	fake.recordInvocation("SignRequest", []interface{}{arg1})
	fake.signRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) SignRequestCallCount() int {
	fake.signRequestMutex.RLock()
	defer fake.signRequestMutex.RUnlock()
	return len(fake.signRequestArgsForCall)
}

func (fake *FakeKMSClient) SignRequestCalls(stub func(*kms.SignInput) (*request.Request, *kms.SignOutput)) {
	fake.signRequestMutex.Lock()
	defer fake.signRequestMutex.Unlock()
	fake.SignRequestStub = stub
}

func (fake *FakeKMSClient) SignRequestArgsForCall(i int) *kms.SignInput {
	fake.signRequestMutex.RLock()
	defer fake.signRequestMutex.RUnlock()
	argsForCall := fake.signRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) SignRequestReturns(result1 *request.Request, result2 *kms.SignOutput) {
	fake.signRequestMutex.Lock()
	defer fake.signRequestMutex.Unlock()
	fake.SignRequestStub = nil
	fake.signRequestReturns = struct {
		result1 *request.Request
		result2 *kms.SignOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) SignRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.SignOutput) {
	fake.signRequestMutex.Lock()
	defer fake.signRequestMutex.Unlock()
	fake.SignRequestStub = nil
	if fake.signRequestReturnsOnCall == nil {
		fake.signRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.SignOutput
		})
	}
	fake.signRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.SignOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) SignWithContext(arg1 context.Context, arg2 *kms.SignInput, arg3 ...request.Option) (*kms.SignOutput, error) {
	fake.signWithContextMutex.Lock()
	ret, specificReturn := fake.signWithContextReturnsOnCall[len(fake.signWithContextArgsForCall)]
	fake.signWithContextArgsForCall = append(fake.signWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.SignInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.SignWithContextStub
	fakeReturns := fake.signWithContextReturns
	fake.recordInvocation("SignWithContext", []interface{}{arg1, arg2, arg3})
	fake.signWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) SignWithContextCallCount() int {
	fake.signWithContextMutex.RLock()
	defer fake.signWithContextMutex.RUnlock()
	return len(fake.signWithContextArgsForCall)
}

func (fake *FakeKMSClient) SignWithContextCalls(stub func(context.Context, *kms.SignInput, ...request.Option) (*kms.SignOutput, error)) {
	fake.signWithContextMutex.Lock()
	defer fake.signWithContextMutex.Unlock()
	fake.SignWithContextStub = stub
}

func (fake *FakeKMSClient) SignWithContextArgsForCall(i int) (context.Context, *kms.SignInput, []request.Option) {
	fake.signWithContextMutex.RLock()
	defer fake.signWithContextMutex.RUnlock()
	argsForCall := fake.signWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) SignWithContextReturns(result1 *kms.SignOutput, result2 error) {
	fake.signWithContextMutex.Lock()
	defer fake.signWithContextMutex.Unlock()
	fake.SignWithContextStub = nil
	fake.signWithContextReturns = struct {
		result1 *kms.SignOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) SignWithContextReturnsOnCall(i int, result1 *kms.SignOutput, result2 error) {
	fake.signWithContextMutex.Lock()
	defer fake.signWithContextMutex.Unlock()
	fake.SignWithContextStub = nil
	if fake.signWithContextReturnsOnCall == nil {
		fake.signWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.SignOutput
			result2 error
		})
	}
	fake.signWithContextReturnsOnCall[i] = struct {
		result1 *kms.SignOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) TagResource(arg1 *kms.TagResourceInput) (*kms.TagResourceOutput, error) {
	fake.tagResourceMutex.Lock()
	ret, specificReturn := fake.tagResourceReturnsOnCall[len(fake.tagResourceArgsForCall)]
	fake.tagResourceArgsForCall = append(fake.tagResourceArgsForCall, struct {
		arg1 *kms.TagResourceInput
	}{arg1})
	stub := fake.TagResourceStub
	fakeReturns := fake.tagResourceReturns
	fake.recordInvocation("TagResource", []interface{}{arg1})
	fake.tagResourceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) TagResourceCallCount() int {
	fake.tagResourceMutex.RLock()
	defer fake.tagResourceMutex.RUnlock()
	return len(fake.tagResourceArgsForCall)
}

func (fake *FakeKMSClient) TagResourceCalls(stub func(*kms.TagResourceInput) (*kms.TagResourceOutput, error)) {
	fake.tagResourceMutex.Lock()
	defer fake.tagResourceMutex.Unlock()
	fake.TagResourceStub = stub
}

func (fake *FakeKMSClient) TagResourceArgsForCall(i int) *kms.TagResourceInput {
	fake.tagResourceMutex.RLock()
	defer fake.tagResourceMutex.RUnlock()
	argsForCall := fake.tagResourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) TagResourceReturns(result1 *kms.TagResourceOutput, result2 error) {
	fake.tagResourceMutex.Lock()
	defer fake.tagResourceMutex.Unlock()
	fake.TagResourceStub = nil
	fake.tagResourceReturns = struct {
		result1 *kms.TagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) TagResourceReturnsOnCall(i int, result1 *kms.TagResourceOutput, result2 error) {
	fake.tagResourceMutex.Lock()
	defer fake.tagResourceMutex.Unlock()
	fake.TagResourceStub = nil
	if fake.tagResourceReturnsOnCall == nil {
		fake.tagResourceReturnsOnCall = make(map[int]struct {
			result1 *kms.TagResourceOutput
			result2 error
		})
	}
	fake.tagResourceReturnsOnCall[i] = struct {
		result1 *kms.TagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) TagResourceRequest(arg1 *kms.TagResourceInput) (*request.Request, *kms.TagResourceOutput) {
	fake.tagResourceRequestMutex.Lock()
	ret, specificReturn := fake.tagResourceRequestReturnsOnCall[len(fake.tagResourceRequestArgsForCall)]
	fake.tagResourceRequestArgsForCall = append(fake.tagResourceRequestArgsForCall, struct {
		arg1 *kms.TagResourceInput
	}{arg1})
	stub := fake.TagResourceRequestStub
	fakeReturns := fake.tagResourceRequestReturns
	fake.recordInvocation("TagResourceRequest", []interface{}{arg1})
	fake.tagResourceRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) TagResourceRequestCallCount() int {
	fake.tagResourceRequestMutex.RLock()
	defer fake.tagResourceRequestMutex.RUnlock()
	return len(fake.tagResourceRequestArgsForCall)
}

func (fake *FakeKMSClient) TagResourceRequestCalls(stub func(*kms.TagResourceInput) (*request.Request, *kms.TagResourceOutput)) {
	fake.tagResourceRequestMutex.Lock()
	defer fake.tagResourceRequestMutex.Unlock()
	fake.TagResourceRequestStub = stub
}

func (fake *FakeKMSClient) TagResourceRequestArgsForCall(i int) *kms.TagResourceInput {
	fake.tagResourceRequestMutex.RLock()
	defer fake.tagResourceRequestMutex.RUnlock()
	argsForCall := fake.tagResourceRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) TagResourceRequestReturns(result1 *request.Request, result2 *kms.TagResourceOutput) {
	fake.tagResourceRequestMutex.Lock()
	defer fake.tagResourceRequestMutex.Unlock()
	fake.TagResourceRequestStub = nil
	fake.tagResourceRequestReturns = struct {
		result1 *request.Request
		result2 *kms.TagResourceOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) TagResourceRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.TagResourceOutput) {
	fake.tagResourceRequestMutex.Lock()
	defer fake.tagResourceRequestMutex.Unlock()
	fake.TagResourceRequestStub = nil
	if fake.tagResourceRequestReturnsOnCall == nil {
		fake.tagResourceRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.TagResourceOutput
		})
	}
	fake.tagResourceRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.TagResourceOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) TagResourceWithContext(arg1 context.Context, arg2 *kms.TagResourceInput, arg3 ...request.Option) (*kms.TagResourceOutput, error) {
	fake.tagResourceWithContextMutex.Lock()
	ret, specificReturn := fake.tagResourceWithContextReturnsOnCall[len(fake.tagResourceWithContextArgsForCall)]
	fake.tagResourceWithContextArgsForCall = append(fake.tagResourceWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.TagResourceInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.TagResourceWithContextStub
	fakeReturns := fake.tagResourceWithContextReturns
	fake.recordInvocation("TagResourceWithContext", []interface{}{arg1, arg2, arg3})
	fake.tagResourceWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) TagResourceWithContextCallCount() int {
	fake.tagResourceWithContextMutex.RLock()
	defer fake.tagResourceWithContextMutex.RUnlock()
	return len(fake.tagResourceWithContextArgsForCall)
}

func (fake *FakeKMSClient) TagResourceWithContextCalls(stub func(context.Context, *kms.TagResourceInput, ...request.Option) (*kms.TagResourceOutput, error)) {
	fake.tagResourceWithContextMutex.Lock()
	defer fake.tagResourceWithContextMutex.Unlock()
	fake.TagResourceWithContextStub = stub
}

func (fake *FakeKMSClient) TagResourceWithContextArgsForCall(i int) (context.Context, *kms.TagResourceInput, []request.Option) {
	fake.tagResourceWithContextMutex.RLock()
	defer fake.tagResourceWithContextMutex.RUnlock()
	argsForCall := fake.tagResourceWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) TagResourceWithContextReturns(result1 *kms.TagResourceOutput, result2 error) {
	fake.tagResourceWithContextMutex.Lock()
	defer fake.tagResourceWithContextMutex.Unlock()
	fake.TagResourceWithContextStub = nil
	fake.tagResourceWithContextReturns = struct {
		result1 *kms.TagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) TagResourceWithContextReturnsOnCall(i int, result1 *kms.TagResourceOutput, result2 error) {
	fake.tagResourceWithContextMutex.Lock()
	defer fake.tagResourceWithContextMutex.Unlock()
	fake.TagResourceWithContextStub = nil
	if fake.tagResourceWithContextReturnsOnCall == nil {
		fake.tagResourceWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.TagResourceOutput
			result2 error
		})
	}
	fake.tagResourceWithContextReturnsOnCall[i] = struct {
		result1 *kms.TagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UntagResource(arg1 *kms.UntagResourceInput) (*kms.UntagResourceOutput, error) {
	fake.untagResourceMutex.Lock()
	ret, specificReturn := fake.untagResourceReturnsOnCall[len(fake.untagResourceArgsForCall)]
	fake.untagResourceArgsForCall = append(fake.untagResourceArgsForCall, struct {
		arg1 *kms.UntagResourceInput
	}{arg1})
	stub := fake.UntagResourceStub
	fakeReturns := fake.untagResourceReturns
	fake.recordInvocation("UntagResource", []interface{}{arg1})
	fake.untagResourceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UntagResourceCallCount() int {
	fake.untagResourceMutex.RLock()
	defer fake.untagResourceMutex.RUnlock()
	return len(fake.untagResourceArgsForCall)
}

func (fake *FakeKMSClient) UntagResourceCalls(stub func(*kms.UntagResourceInput) (*kms.UntagResourceOutput, error)) {
	fake.untagResourceMutex.Lock()
	defer fake.untagResourceMutex.Unlock()
	fake.UntagResourceStub = stub
}

func (fake *FakeKMSClient) UntagResourceArgsForCall(i int) *kms.UntagResourceInput {
	fake.untagResourceMutex.RLock()
	defer fake.untagResourceMutex.RUnlock()
	argsForCall := fake.untagResourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) UntagResourceReturns(result1 *kms.UntagResourceOutput, result2 error) {
	fake.untagResourceMutex.Lock()
	defer fake.untagResourceMutex.Unlock()
	fake.UntagResourceStub = nil
	fake.untagResourceReturns = struct {
		result1 *kms.UntagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UntagResourceReturnsOnCall(i int, result1 *kms.UntagResourceOutput, result2 error) {
	fake.untagResourceMutex.Lock()
	defer fake.untagResourceMutex.Unlock()
	fake.UntagResourceStub = nil
	if fake.untagResourceReturnsOnCall == nil {
		fake.untagResourceReturnsOnCall = make(map[int]struct {
			result1 *kms.UntagResourceOutput
			result2 error
		})
	}
	fake.untagResourceReturnsOnCall[i] = struct {
		result1 *kms.UntagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UntagResourceRequest(arg1 *kms.UntagResourceInput) (*request.Request, *kms.UntagResourceOutput) {
	fake.untagResourceRequestMutex.Lock()
	ret, specificReturn := fake.untagResourceRequestReturnsOnCall[len(fake.untagResourceRequestArgsForCall)]
	fake.untagResourceRequestArgsForCall = append(fake.untagResourceRequestArgsForCall, struct {
		arg1 *kms.UntagResourceInput
	}{arg1})
	stub := fake.UntagResourceRequestStub
	fakeReturns := fake.untagResourceRequestReturns
	fake.recordInvocation("UntagResourceRequest", []interface{}{arg1})
	fake.untagResourceRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UntagResourceRequestCallCount() int {
	fake.untagResourceRequestMutex.RLock()
	defer fake.untagResourceRequestMutex.RUnlock()
	return len(fake.untagResourceRequestArgsForCall)
}

func (fake *FakeKMSClient) UntagResourceRequestCalls(stub func(*kms.UntagResourceInput) (*request.Request, *kms.UntagResourceOutput)) {
	fake.untagResourceRequestMutex.Lock()
	defer fake.untagResourceRequestMutex.Unlock()
	fake.UntagResourceRequestStub = stub
}

func (fake *FakeKMSClient) UntagResourceRequestArgsForCall(i int) *kms.UntagResourceInput {
	fake.untagResourceRequestMutex.RLock()
	defer fake.untagResourceRequestMutex.RUnlock()
	argsForCall := fake.untagResourceRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) UntagResourceRequestReturns(result1 *request.Request, result2 *kms.UntagResourceOutput) {
	fake.untagResourceRequestMutex.Lock()
	defer fake.untagResourceRequestMutex.Unlock()
	fake.UntagResourceRequestStub = nil
	fake.untagResourceRequestReturns = struct {
		result1 *request.Request
		result2 *kms.UntagResourceOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) UntagResourceRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.UntagResourceOutput) {
	fake.untagResourceRequestMutex.Lock()
	defer fake.untagResourceRequestMutex.Unlock()
	fake.UntagResourceRequestStub = nil
	if fake.untagResourceRequestReturnsOnCall == nil {
		fake.untagResourceRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.UntagResourceOutput
		})
	}
	fake.untagResourceRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.UntagResourceOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) UntagResourceWithContext(arg1 context.Context, arg2 *kms.UntagResourceInput, arg3 ...request.Option) (*kms.UntagResourceOutput, error) {
	fake.untagResourceWithContextMutex.Lock()
	ret, specificReturn := fake.untagResourceWithContextReturnsOnCall[len(fake.untagResourceWithContextArgsForCall)]
	fake.untagResourceWithContextArgsForCall = append(fake.untagResourceWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.UntagResourceInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.UntagResourceWithContextStub
	fakeReturns := fake.untagResourceWithContextReturns
	fake.recordInvocation("UntagResourceWithContext", []interface{}{arg1, arg2, arg3})
	fake.untagResourceWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UntagResourceWithContextCallCount() int {
	fake.untagResourceWithContextMutex.RLock()
	defer fake.untagResourceWithContextMutex.RUnlock()
	return len(fake.untagResourceWithContextArgsForCall)
}

func (fake *FakeKMSClient) UntagResourceWithContextCalls(stub func(context.Context, *kms.UntagResourceInput, ...request.Option) (*kms.UntagResourceOutput, error)) {
	fake.untagResourceWithContextMutex.Lock()
	defer fake.untagResourceWithContextMutex.Unlock()
	fake.UntagResourceWithContextStub = stub
}

func (fake *FakeKMSClient) UntagResourceWithContextArgsForCall(i int) (context.Context, *kms.UntagResourceInput, []request.Option) {
	fake.untagResourceWithContextMutex.RLock()
	defer fake.untagResourceWithContextMutex.RUnlock()
	argsForCall := fake.untagResourceWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) UntagResourceWithContextReturns(result1 *kms.UntagResourceOutput, result2 error) {
	fake.untagResourceWithContextMutex.Lock()
	defer fake.untagResourceWithContextMutex.Unlock()
	fake.UntagResourceWithContextStub = nil
	fake.untagResourceWithContextReturns = struct {
		result1 *kms.UntagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UntagResourceWithContextReturnsOnCall(i int, result1 *kms.UntagResourceOutput, result2 error) {
	fake.untagResourceWithContextMutex.Lock()
	defer fake.untagResourceWithContextMutex.Unlock()
	fake.UntagResourceWithContextStub = nil
	if fake.untagResourceWithContextReturnsOnCall == nil {
		fake.untagResourceWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.UntagResourceOutput
			result2 error
		})
	}
	fake.untagResourceWithContextReturnsOnCall[i] = struct {
		result1 *kms.UntagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateAlias(arg1 *kms.UpdateAliasInput) (*kms.UpdateAliasOutput, error) {
	fake.updateAliasMutex.Lock()
	ret, specificReturn := fake.updateAliasReturnsOnCall[len(fake.updateAliasArgsForCall)]
	fake.updateAliasArgsForCall = append(fake.updateAliasArgsForCall, struct {
		arg1 *kms.UpdateAliasInput
	}{arg1})
	stub := fake.UpdateAliasStub
	fakeReturns := fake.updateAliasReturns
	fake.recordInvocation("UpdateAlias", []interface{}{arg1})
	fake.updateAliasMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdateAliasCallCount() int {
	fake.updateAliasMutex.RLock()
	defer fake.updateAliasMutex.RUnlock()
	return len(fake.updateAliasArgsForCall)
}

func (fake *FakeKMSClient) UpdateAliasCalls(stub func(*kms.UpdateAliasInput) (*kms.UpdateAliasOutput, error)) {
	fake.updateAliasMutex.Lock()
	defer fake.updateAliasMutex.Unlock()
	fake.UpdateAliasStub = stub
}

func (fake *FakeKMSClient) UpdateAliasArgsForCall(i int) *kms.UpdateAliasInput {
	fake.updateAliasMutex.RLock()
	defer fake.updateAliasMutex.RUnlock()
	argsForCall := fake.updateAliasArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) UpdateAliasReturns(result1 *kms.UpdateAliasOutput, result2 error) {
	fake.updateAliasMutex.Lock()
	defer fake.updateAliasMutex.Unlock()
	fake.UpdateAliasStub = nil
	fake.updateAliasReturns = struct {
		result1 *kms.UpdateAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateAliasReturnsOnCall(i int, result1 *kms.UpdateAliasOutput, result2 error) {
	fake.updateAliasMutex.Lock()
	defer fake.updateAliasMutex.Unlock()
	fake.UpdateAliasStub = nil
	if fake.updateAliasReturnsOnCall == nil {
		fake.updateAliasReturnsOnCall = make(map[int]struct {
			result1 *kms.UpdateAliasOutput
			result2 error
		})
	}
	fake.updateAliasReturnsOnCall[i] = struct {
		result1 *kms.UpdateAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateAliasRequest(arg1 *kms.UpdateAliasInput) (*request.Request, *kms.UpdateAliasOutput) {
	fake.updateAliasRequestMutex.Lock()
	ret, specificReturn := fake.updateAliasRequestReturnsOnCall[len(fake.updateAliasRequestArgsForCall)]
	fake.updateAliasRequestArgsForCall = append(fake.updateAliasRequestArgsForCall, struct {
		arg1 *kms.UpdateAliasInput
	}{arg1})
	stub := fake.UpdateAliasRequestStub
	fakeReturns := fake.updateAliasRequestReturns
	fake.recordInvocation("UpdateAliasRequest", []interface{}{arg1})
	fake.updateAliasRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdateAliasRequestCallCount() int {
	fake.updateAliasRequestMutex.RLock()
	defer fake.updateAliasRequestMutex.RUnlock()
	return len(fake.updateAliasRequestArgsForCall)
}

func (fake *FakeKMSClient) UpdateAliasRequestCalls(stub func(*kms.UpdateAliasInput) (*request.Request, *kms.UpdateAliasOutput)) {
	fake.updateAliasRequestMutex.Lock()
	defer fake.updateAliasRequestMutex.Unlock()
	fake.UpdateAliasRequestStub = stub
}

func (fake *FakeKMSClient) UpdateAliasRequestArgsForCall(i int) *kms.UpdateAliasInput {
	fake.updateAliasRequestMutex.RLock()
	defer fake.updateAliasRequestMutex.RUnlock()
	argsForCall := fake.updateAliasRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) UpdateAliasRequestReturns(result1 *request.Request, result2 *kms.UpdateAliasOutput) {
	fake.updateAliasRequestMutex.Lock()
	defer fake.updateAliasRequestMutex.Unlock()
	fake.UpdateAliasRequestStub = nil
	fake.updateAliasRequestReturns = struct {
		result1 *request.Request
		result2 *kms.UpdateAliasOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateAliasRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.UpdateAliasOutput) {
	fake.updateAliasRequestMutex.Lock()
	defer fake.updateAliasRequestMutex.Unlock()
	fake.UpdateAliasRequestStub = nil
	if fake.updateAliasRequestReturnsOnCall == nil {
		fake.updateAliasRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.UpdateAliasOutput
		})
	}
	fake.updateAliasRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.UpdateAliasOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateAliasWithContext(arg1 context.Context, arg2 *kms.UpdateAliasInput, arg3 ...request.Option) (*kms.UpdateAliasOutput, error) {
	fake.updateAliasWithContextMutex.Lock()
	ret, specificReturn := fake.updateAliasWithContextReturnsOnCall[len(fake.updateAliasWithContextArgsForCall)]
	fake.updateAliasWithContextArgsForCall = append(fake.updateAliasWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.UpdateAliasInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.UpdateAliasWithContextStub
	fakeReturns := fake.updateAliasWithContextReturns
	fake.recordInvocation("UpdateAliasWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateAliasWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdateAliasWithContextCallCount() int {
	fake.updateAliasWithContextMutex.RLock()
	defer fake.updateAliasWithContextMutex.RUnlock()
	return len(fake.updateAliasWithContextArgsForCall)
}

func (fake *FakeKMSClient) UpdateAliasWithContextCalls(stub func(context.Context, *kms.UpdateAliasInput, ...request.Option) (*kms.UpdateAliasOutput, error)) {
	fake.updateAliasWithContextMutex.Lock()
	defer fake.updateAliasWithContextMutex.Unlock()
	fake.UpdateAliasWithContextStub = stub
}

func (fake *FakeKMSClient) UpdateAliasWithContextArgsForCall(i int) (context.Context, *kms.UpdateAliasInput, []request.Option) {
	fake.updateAliasWithContextMutex.RLock()
	defer fake.updateAliasWithContextMutex.RUnlock()
	argsForCall := fake.updateAliasWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) UpdateAliasWithContextReturns(result1 *kms.UpdateAliasOutput, result2 error) {
	fake.updateAliasWithContextMutex.Lock()
	defer fake.updateAliasWithContextMutex.Unlock()
	fake.UpdateAliasWithContextStub = nil
	fake.updateAliasWithContextReturns = struct {
		result1 *kms.UpdateAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateAliasWithContextReturnsOnCall(i int, result1 *kms.UpdateAliasOutput, result2 error) {
	fake.updateAliasWithContextMutex.Lock()
	defer fake.updateAliasWithContextMutex.Unlock()
	fake.UpdateAliasWithContextStub = nil
	if fake.updateAliasWithContextReturnsOnCall == nil {
		fake.updateAliasWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.UpdateAliasOutput
			result2 error
		})
	}
	fake.updateAliasWithContextReturnsOnCall[i] = struct {
		result1 *kms.UpdateAliasOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateCustomKeyStore(arg1 *kms.UpdateCustomKeyStoreInput) (*kms.UpdateCustomKeyStoreOutput, error) {
	fake.updateCustomKeyStoreMutex.Lock()
	ret, specificReturn := fake.updateCustomKeyStoreReturnsOnCall[len(fake.updateCustomKeyStoreArgsForCall)]
	fake.updateCustomKeyStoreArgsForCall = append(fake.updateCustomKeyStoreArgsForCall, struct {
		arg1 *kms.UpdateCustomKeyStoreInput
	}{arg1})
	stub := fake.UpdateCustomKeyStoreStub
	fakeReturns := fake.updateCustomKeyStoreReturns
	fake.recordInvocation("UpdateCustomKeyStore", []interface{}{arg1})
	fake.updateCustomKeyStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreCallCount() int {
	fake.updateCustomKeyStoreMutex.RLock()
	defer fake.updateCustomKeyStoreMutex.RUnlock()
	return len(fake.updateCustomKeyStoreArgsForCall)
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreCalls(stub func(*kms.UpdateCustomKeyStoreInput) (*kms.UpdateCustomKeyStoreOutput, error)) {
	fake.updateCustomKeyStoreMutex.Lock()
	defer fake.updateCustomKeyStoreMutex.Unlock()
	fake.UpdateCustomKeyStoreStub = stub
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreArgsForCall(i int) *kms.UpdateCustomKeyStoreInput {
	fake.updateCustomKeyStoreMutex.RLock()
	defer fake.updateCustomKeyStoreMutex.RUnlock()
	argsForCall := fake.updateCustomKeyStoreArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreReturns(result1 *kms.UpdateCustomKeyStoreOutput, result2 error) {
	fake.updateCustomKeyStoreMutex.Lock()
	defer fake.updateCustomKeyStoreMutex.Unlock()
	fake.UpdateCustomKeyStoreStub = nil
	fake.updateCustomKeyStoreReturns = struct {
		result1 *kms.UpdateCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreReturnsOnCall(i int, result1 *kms.UpdateCustomKeyStoreOutput, result2 error) {
	fake.updateCustomKeyStoreMutex.Lock()
	defer fake.updateCustomKeyStoreMutex.Unlock()
	fake.UpdateCustomKeyStoreStub = nil
	if fake.updateCustomKeyStoreReturnsOnCall == nil {
		fake.updateCustomKeyStoreReturnsOnCall = make(map[int]struct {
			result1 *kms.UpdateCustomKeyStoreOutput
			result2 error
		})
	}
	fake.updateCustomKeyStoreReturnsOnCall[i] = struct {
		result1 *kms.UpdateCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreRequest(arg1 *kms.UpdateCustomKeyStoreInput) (*request.Request, *kms.UpdateCustomKeyStoreOutput) {
	fake.updateCustomKeyStoreRequestMutex.Lock()
	ret, specificReturn := fake.updateCustomKeyStoreRequestReturnsOnCall[len(fake.updateCustomKeyStoreRequestArgsForCall)]
	fake.updateCustomKeyStoreRequestArgsForCall = append(fake.updateCustomKeyStoreRequestArgsForCall, struct {
		arg1 *kms.UpdateCustomKeyStoreInput
	}{arg1})
	stub := fake.UpdateCustomKeyStoreRequestStub
	fakeReturns := fake.updateCustomKeyStoreRequestReturns
	fake.recordInvocation("UpdateCustomKeyStoreRequest", []interface{}{arg1})
	fake.updateCustomKeyStoreRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreRequestCallCount() int {
	fake.updateCustomKeyStoreRequestMutex.RLock()
	defer fake.updateCustomKeyStoreRequestMutex.RUnlock()
	return len(fake.updateCustomKeyStoreRequestArgsForCall)
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreRequestCalls(stub func(*kms.UpdateCustomKeyStoreInput) (*request.Request, *kms.UpdateCustomKeyStoreOutput)) {
	fake.updateCustomKeyStoreRequestMutex.Lock()
	defer fake.updateCustomKeyStoreRequestMutex.Unlock()
	fake.UpdateCustomKeyStoreRequestStub = stub
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreRequestArgsForCall(i int) *kms.UpdateCustomKeyStoreInput {
	fake.updateCustomKeyStoreRequestMutex.RLock()
	defer fake.updateCustomKeyStoreRequestMutex.RUnlock()
	argsForCall := fake.updateCustomKeyStoreRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreRequestReturns(result1 *request.Request, result2 *kms.UpdateCustomKeyStoreOutput) {
	fake.updateCustomKeyStoreRequestMutex.Lock()
	defer fake.updateCustomKeyStoreRequestMutex.Unlock()
	fake.UpdateCustomKeyStoreRequestStub = nil
	fake.updateCustomKeyStoreRequestReturns = struct {
		result1 *request.Request
		result2 *kms.UpdateCustomKeyStoreOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.UpdateCustomKeyStoreOutput) {
	fake.updateCustomKeyStoreRequestMutex.Lock()
	defer fake.updateCustomKeyStoreRequestMutex.Unlock()
	fake.UpdateCustomKeyStoreRequestStub = nil
	if fake.updateCustomKeyStoreRequestReturnsOnCall == nil {
		fake.updateCustomKeyStoreRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.UpdateCustomKeyStoreOutput
		})
	}
	fake.updateCustomKeyStoreRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.UpdateCustomKeyStoreOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreWithContext(arg1 context.Context, arg2 *kms.UpdateCustomKeyStoreInput, arg3 ...request.Option) (*kms.UpdateCustomKeyStoreOutput, error) {
	fake.updateCustomKeyStoreWithContextMutex.Lock()
	ret, specificReturn := fake.updateCustomKeyStoreWithContextReturnsOnCall[len(fake.updateCustomKeyStoreWithContextArgsForCall)]
	fake.updateCustomKeyStoreWithContextArgsForCall = append(fake.updateCustomKeyStoreWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.UpdateCustomKeyStoreInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.UpdateCustomKeyStoreWithContextStub
	fakeReturns := fake.updateCustomKeyStoreWithContextReturns
	fake.recordInvocation("UpdateCustomKeyStoreWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateCustomKeyStoreWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreWithContextCallCount() int {
	fake.updateCustomKeyStoreWithContextMutex.RLock()
	defer fake.updateCustomKeyStoreWithContextMutex.RUnlock()
	return len(fake.updateCustomKeyStoreWithContextArgsForCall)
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreWithContextCalls(stub func(context.Context, *kms.UpdateCustomKeyStoreInput, ...request.Option) (*kms.UpdateCustomKeyStoreOutput, error)) {
	fake.updateCustomKeyStoreWithContextMutex.Lock()
	defer fake.updateCustomKeyStoreWithContextMutex.Unlock()
	fake.UpdateCustomKeyStoreWithContextStub = stub
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreWithContextArgsForCall(i int) (context.Context, *kms.UpdateCustomKeyStoreInput, []request.Option) {
	fake.updateCustomKeyStoreWithContextMutex.RLock()
	defer fake.updateCustomKeyStoreWithContextMutex.RUnlock()
	argsForCall := fake.updateCustomKeyStoreWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreWithContextReturns(result1 *kms.UpdateCustomKeyStoreOutput, result2 error) {
	fake.updateCustomKeyStoreWithContextMutex.Lock()
	defer fake.updateCustomKeyStoreWithContextMutex.Unlock()
	fake.UpdateCustomKeyStoreWithContextStub = nil
	fake.updateCustomKeyStoreWithContextReturns = struct {
		result1 *kms.UpdateCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateCustomKeyStoreWithContextReturnsOnCall(i int, result1 *kms.UpdateCustomKeyStoreOutput, result2 error) {
	fake.updateCustomKeyStoreWithContextMutex.Lock()
	defer fake.updateCustomKeyStoreWithContextMutex.Unlock()
	fake.UpdateCustomKeyStoreWithContextStub = nil
	if fake.updateCustomKeyStoreWithContextReturnsOnCall == nil {
		fake.updateCustomKeyStoreWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.UpdateCustomKeyStoreOutput
			result2 error
		})
	}
	fake.updateCustomKeyStoreWithContextReturnsOnCall[i] = struct {
		result1 *kms.UpdateCustomKeyStoreOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateKeyDescription(arg1 *kms.UpdateKeyDescriptionInput) (*kms.UpdateKeyDescriptionOutput, error) {
	fake.updateKeyDescriptionMutex.Lock()
	ret, specificReturn := fake.updateKeyDescriptionReturnsOnCall[len(fake.updateKeyDescriptionArgsForCall)]
	fake.updateKeyDescriptionArgsForCall = append(fake.updateKeyDescriptionArgsForCall, struct {
		arg1 *kms.UpdateKeyDescriptionInput
	}{arg1})
	stub := fake.UpdateKeyDescriptionStub
	fakeReturns := fake.updateKeyDescriptionReturns
	fake.recordInvocation("UpdateKeyDescription", []interface{}{arg1})
	fake.updateKeyDescriptionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdateKeyDescriptionCallCount() int {
	fake.updateKeyDescriptionMutex.RLock()
	defer fake.updateKeyDescriptionMutex.RUnlock()
	return len(fake.updateKeyDescriptionArgsForCall)
}

func (fake *FakeKMSClient) UpdateKeyDescriptionCalls(stub func(*kms.UpdateKeyDescriptionInput) (*kms.UpdateKeyDescriptionOutput, error)) {
	fake.updateKeyDescriptionMutex.Lock()
	defer fake.updateKeyDescriptionMutex.Unlock()
	fake.UpdateKeyDescriptionStub = stub
}

func (fake *FakeKMSClient) UpdateKeyDescriptionArgsForCall(i int) *kms.UpdateKeyDescriptionInput {
	fake.updateKeyDescriptionMutex.RLock()
	defer fake.updateKeyDescriptionMutex.RUnlock()
	argsForCall := fake.updateKeyDescriptionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) UpdateKeyDescriptionReturns(result1 *kms.UpdateKeyDescriptionOutput, result2 error) {
	fake.updateKeyDescriptionMutex.Lock()
	defer fake.updateKeyDescriptionMutex.Unlock()
	fake.UpdateKeyDescriptionStub = nil
	fake.updateKeyDescriptionReturns = struct {
		result1 *kms.UpdateKeyDescriptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateKeyDescriptionReturnsOnCall(i int, result1 *kms.UpdateKeyDescriptionOutput, result2 error) {
	fake.updateKeyDescriptionMutex.Lock()
	defer fake.updateKeyDescriptionMutex.Unlock()
	fake.UpdateKeyDescriptionStub = nil
	if fake.updateKeyDescriptionReturnsOnCall == nil {
		fake.updateKeyDescriptionReturnsOnCall = make(map[int]struct {
			result1 *kms.UpdateKeyDescriptionOutput
			result2 error
		})
	}
	fake.updateKeyDescriptionReturnsOnCall[i] = struct {
		result1 *kms.UpdateKeyDescriptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateKeyDescriptionRequest(arg1 *kms.UpdateKeyDescriptionInput) (*request.Request, *kms.UpdateKeyDescriptionOutput) {
	fake.updateKeyDescriptionRequestMutex.Lock()
	ret, specificReturn := fake.updateKeyDescriptionRequestReturnsOnCall[len(fake.updateKeyDescriptionRequestArgsForCall)]
	fake.updateKeyDescriptionRequestArgsForCall = append(fake.updateKeyDescriptionRequestArgsForCall, struct {
		arg1 *kms.UpdateKeyDescriptionInput
	}{arg1})
	stub := fake.UpdateKeyDescriptionRequestStub
	fakeReturns := fake.updateKeyDescriptionRequestReturns
	fake.recordInvocation("UpdateKeyDescriptionRequest", []interface{}{arg1})
	fake.updateKeyDescriptionRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdateKeyDescriptionRequestCallCount() int {
	fake.updateKeyDescriptionRequestMutex.RLock()
	defer fake.updateKeyDescriptionRequestMutex.RUnlock()
	return len(fake.updateKeyDescriptionRequestArgsForCall)
}

func (fake *FakeKMSClient) UpdateKeyDescriptionRequestCalls(stub func(*kms.UpdateKeyDescriptionInput) (*request.Request, *kms.UpdateKeyDescriptionOutput)) {
	fake.updateKeyDescriptionRequestMutex.Lock()
	defer fake.updateKeyDescriptionRequestMutex.Unlock()
	fake.UpdateKeyDescriptionRequestStub = stub
}

func (fake *FakeKMSClient) UpdateKeyDescriptionRequestArgsForCall(i int) *kms.UpdateKeyDescriptionInput {
	fake.updateKeyDescriptionRequestMutex.RLock()
	defer fake.updateKeyDescriptionRequestMutex.RUnlock()
	argsForCall := fake.updateKeyDescriptionRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) UpdateKeyDescriptionRequestReturns(result1 *request.Request, result2 *kms.UpdateKeyDescriptionOutput) {
	fake.updateKeyDescriptionRequestMutex.Lock()
	defer fake.updateKeyDescriptionRequestMutex.Unlock()
	fake.UpdateKeyDescriptionRequestStub = nil
	fake.updateKeyDescriptionRequestReturns = struct {
		result1 *request.Request
		result2 *kms.UpdateKeyDescriptionOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateKeyDescriptionRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.UpdateKeyDescriptionOutput) {
	fake.updateKeyDescriptionRequestMutex.Lock()
	defer fake.updateKeyDescriptionRequestMutex.Unlock()
	fake.UpdateKeyDescriptionRequestStub = nil
	if fake.updateKeyDescriptionRequestReturnsOnCall == nil {
		fake.updateKeyDescriptionRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.UpdateKeyDescriptionOutput
		})
	}
	fake.updateKeyDescriptionRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.UpdateKeyDescriptionOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateKeyDescriptionWithContext(arg1 context.Context, arg2 *kms.UpdateKeyDescriptionInput, arg3 ...request.Option) (*kms.UpdateKeyDescriptionOutput, error) {
	fake.updateKeyDescriptionWithContextMutex.Lock()
	ret, specificReturn := fake.updateKeyDescriptionWithContextReturnsOnCall[len(fake.updateKeyDescriptionWithContextArgsForCall)]
	fake.updateKeyDescriptionWithContextArgsForCall = append(fake.updateKeyDescriptionWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.UpdateKeyDescriptionInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.UpdateKeyDescriptionWithContextStub
	fakeReturns := fake.updateKeyDescriptionWithContextReturns
	fake.recordInvocation("UpdateKeyDescriptionWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateKeyDescriptionWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdateKeyDescriptionWithContextCallCount() int {
	fake.updateKeyDescriptionWithContextMutex.RLock()
	defer fake.updateKeyDescriptionWithContextMutex.RUnlock()
	return len(fake.updateKeyDescriptionWithContextArgsForCall)
}

func (fake *FakeKMSClient) UpdateKeyDescriptionWithContextCalls(stub func(context.Context, *kms.UpdateKeyDescriptionInput, ...request.Option) (*kms.UpdateKeyDescriptionOutput, error)) {
	fake.updateKeyDescriptionWithContextMutex.Lock()
	defer fake.updateKeyDescriptionWithContextMutex.Unlock()
	fake.UpdateKeyDescriptionWithContextStub = stub
}

func (fake *FakeKMSClient) UpdateKeyDescriptionWithContextArgsForCall(i int) (context.Context, *kms.UpdateKeyDescriptionInput, []request.Option) {
	fake.updateKeyDescriptionWithContextMutex.RLock()
	defer fake.updateKeyDescriptionWithContextMutex.RUnlock()
	argsForCall := fake.updateKeyDescriptionWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) UpdateKeyDescriptionWithContextReturns(result1 *kms.UpdateKeyDescriptionOutput, result2 error) {
	fake.updateKeyDescriptionWithContextMutex.Lock()
	defer fake.updateKeyDescriptionWithContextMutex.Unlock()
	fake.UpdateKeyDescriptionWithContextStub = nil
	fake.updateKeyDescriptionWithContextReturns = struct {
		result1 *kms.UpdateKeyDescriptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdateKeyDescriptionWithContextReturnsOnCall(i int, result1 *kms.UpdateKeyDescriptionOutput, result2 error) {
	fake.updateKeyDescriptionWithContextMutex.Lock()
	defer fake.updateKeyDescriptionWithContextMutex.Unlock()
	fake.UpdateKeyDescriptionWithContextStub = nil
	if fake.updateKeyDescriptionWithContextReturnsOnCall == nil {
		fake.updateKeyDescriptionWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.UpdateKeyDescriptionOutput
			result2 error
		})
	}
	fake.updateKeyDescriptionWithContextReturnsOnCall[i] = struct {
		result1 *kms.UpdateKeyDescriptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdatePrimaryRegion(arg1 *kms.UpdatePrimaryRegionInput) (*kms.UpdatePrimaryRegionOutput, error) {
	fake.updatePrimaryRegionMutex.Lock()
	ret, specificReturn := fake.updatePrimaryRegionReturnsOnCall[len(fake.updatePrimaryRegionArgsForCall)]
	fake.updatePrimaryRegionArgsForCall = append(fake.updatePrimaryRegionArgsForCall, struct {
		arg1 *kms.UpdatePrimaryRegionInput
	}{arg1})
	stub := fake.UpdatePrimaryRegionStub
	fakeReturns := fake.updatePrimaryRegionReturns
	fake.recordInvocation("UpdatePrimaryRegion", []interface{}{arg1})
	fake.updatePrimaryRegionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdatePrimaryRegionCallCount() int {
	fake.updatePrimaryRegionMutex.RLock()
	defer fake.updatePrimaryRegionMutex.RUnlock()
	return len(fake.updatePrimaryRegionArgsForCall)
}

func (fake *FakeKMSClient) UpdatePrimaryRegionCalls(stub func(*kms.UpdatePrimaryRegionInput) (*kms.UpdatePrimaryRegionOutput, error)) {
	fake.updatePrimaryRegionMutex.Lock()
	defer fake.updatePrimaryRegionMutex.Unlock()
	fake.UpdatePrimaryRegionStub = stub
}

func (fake *FakeKMSClient) UpdatePrimaryRegionArgsForCall(i int) *kms.UpdatePrimaryRegionInput {
	fake.updatePrimaryRegionMutex.RLock()
	defer fake.updatePrimaryRegionMutex.RUnlock()
	argsForCall := fake.updatePrimaryRegionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) UpdatePrimaryRegionReturns(result1 *kms.UpdatePrimaryRegionOutput, result2 error) {
	fake.updatePrimaryRegionMutex.Lock()
	defer fake.updatePrimaryRegionMutex.Unlock()
	fake.UpdatePrimaryRegionStub = nil
	fake.updatePrimaryRegionReturns = struct {
		result1 *kms.UpdatePrimaryRegionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdatePrimaryRegionReturnsOnCall(i int, result1 *kms.UpdatePrimaryRegionOutput, result2 error) {
	fake.updatePrimaryRegionMutex.Lock()
	defer fake.updatePrimaryRegionMutex.Unlock()
	fake.UpdatePrimaryRegionStub = nil
	if fake.updatePrimaryRegionReturnsOnCall == nil {
		fake.updatePrimaryRegionReturnsOnCall = make(map[int]struct {
			result1 *kms.UpdatePrimaryRegionOutput
			result2 error
		})
	}
	fake.updatePrimaryRegionReturnsOnCall[i] = struct {
		result1 *kms.UpdatePrimaryRegionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdatePrimaryRegionRequest(arg1 *kms.UpdatePrimaryRegionInput) (*request.Request, *kms.UpdatePrimaryRegionOutput) {
	fake.updatePrimaryRegionRequestMutex.Lock()
	ret, specificReturn := fake.updatePrimaryRegionRequestReturnsOnCall[len(fake.updatePrimaryRegionRequestArgsForCall)]
	fake.updatePrimaryRegionRequestArgsForCall = append(fake.updatePrimaryRegionRequestArgsForCall, struct {
		arg1 *kms.UpdatePrimaryRegionInput
	}{arg1})
	stub := fake.UpdatePrimaryRegionRequestStub
	fakeReturns := fake.updatePrimaryRegionRequestReturns
	fake.recordInvocation("UpdatePrimaryRegionRequest", []interface{}{arg1})
	fake.updatePrimaryRegionRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdatePrimaryRegionRequestCallCount() int {
	fake.updatePrimaryRegionRequestMutex.RLock()
	defer fake.updatePrimaryRegionRequestMutex.RUnlock()
	return len(fake.updatePrimaryRegionRequestArgsForCall)
}

func (fake *FakeKMSClient) UpdatePrimaryRegionRequestCalls(stub func(*kms.UpdatePrimaryRegionInput) (*request.Request, *kms.UpdatePrimaryRegionOutput)) {
	fake.updatePrimaryRegionRequestMutex.Lock()
	defer fake.updatePrimaryRegionRequestMutex.Unlock()
	fake.UpdatePrimaryRegionRequestStub = stub
}

func (fake *FakeKMSClient) UpdatePrimaryRegionRequestArgsForCall(i int) *kms.UpdatePrimaryRegionInput {
	fake.updatePrimaryRegionRequestMutex.RLock()
	defer fake.updatePrimaryRegionRequestMutex.RUnlock()
	argsForCall := fake.updatePrimaryRegionRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) UpdatePrimaryRegionRequestReturns(result1 *request.Request, result2 *kms.UpdatePrimaryRegionOutput) {
	fake.updatePrimaryRegionRequestMutex.Lock()
	defer fake.updatePrimaryRegionRequestMutex.Unlock()
	fake.UpdatePrimaryRegionRequestStub = nil
	fake.updatePrimaryRegionRequestReturns = struct {
		result1 *request.Request
		result2 *kms.UpdatePrimaryRegionOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdatePrimaryRegionRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.UpdatePrimaryRegionOutput) {
	fake.updatePrimaryRegionRequestMutex.Lock()
	defer fake.updatePrimaryRegionRequestMutex.Unlock()
	fake.UpdatePrimaryRegionRequestStub = nil
	if fake.updatePrimaryRegionRequestReturnsOnCall == nil {
		fake.updatePrimaryRegionRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.UpdatePrimaryRegionOutput
		})
	}
	fake.updatePrimaryRegionRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.UpdatePrimaryRegionOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdatePrimaryRegionWithContext(arg1 context.Context, arg2 *kms.UpdatePrimaryRegionInput, arg3 ...request.Option) (*kms.UpdatePrimaryRegionOutput, error) {
	fake.updatePrimaryRegionWithContextMutex.Lock()
	ret, specificReturn := fake.updatePrimaryRegionWithContextReturnsOnCall[len(fake.updatePrimaryRegionWithContextArgsForCall)]
	fake.updatePrimaryRegionWithContextArgsForCall = append(fake.updatePrimaryRegionWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.UpdatePrimaryRegionInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.UpdatePrimaryRegionWithContextStub
	fakeReturns := fake.updatePrimaryRegionWithContextReturns
	fake.recordInvocation("UpdatePrimaryRegionWithContext", []interface{}{arg1, arg2, arg3})
	fake.updatePrimaryRegionWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) UpdatePrimaryRegionWithContextCallCount() int {
	fake.updatePrimaryRegionWithContextMutex.RLock()
	defer fake.updatePrimaryRegionWithContextMutex.RUnlock()
	return len(fake.updatePrimaryRegionWithContextArgsForCall)
}

func (fake *FakeKMSClient) UpdatePrimaryRegionWithContextCalls(stub func(context.Context, *kms.UpdatePrimaryRegionInput, ...request.Option) (*kms.UpdatePrimaryRegionOutput, error)) {
	fake.updatePrimaryRegionWithContextMutex.Lock()
	defer fake.updatePrimaryRegionWithContextMutex.Unlock()
	fake.UpdatePrimaryRegionWithContextStub = stub
}

func (fake *FakeKMSClient) UpdatePrimaryRegionWithContextArgsForCall(i int) (context.Context, *kms.UpdatePrimaryRegionInput, []request.Option) {
	fake.updatePrimaryRegionWithContextMutex.RLock()
	defer fake.updatePrimaryRegionWithContextMutex.RUnlock()
	argsForCall := fake.updatePrimaryRegionWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) UpdatePrimaryRegionWithContextReturns(result1 *kms.UpdatePrimaryRegionOutput, result2 error) {
	fake.updatePrimaryRegionWithContextMutex.Lock()
	defer fake.updatePrimaryRegionWithContextMutex.Unlock()
	fake.UpdatePrimaryRegionWithContextStub = nil
	fake.updatePrimaryRegionWithContextReturns = struct {
		result1 *kms.UpdatePrimaryRegionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) UpdatePrimaryRegionWithContextReturnsOnCall(i int, result1 *kms.UpdatePrimaryRegionOutput, result2 error) {
	fake.updatePrimaryRegionWithContextMutex.Lock()
	defer fake.updatePrimaryRegionWithContextMutex.Unlock()
	fake.UpdatePrimaryRegionWithContextStub = nil
	if fake.updatePrimaryRegionWithContextReturnsOnCall == nil {
		fake.updatePrimaryRegionWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.UpdatePrimaryRegionOutput
			result2 error
		})
	}
	fake.updatePrimaryRegionWithContextReturnsOnCall[i] = struct {
		result1 *kms.UpdatePrimaryRegionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) Verify(arg1 *kms.VerifyInput) (*kms.VerifyOutput, error) {
	fake.verifyMutex.Lock()
	ret, specificReturn := fake.verifyReturnsOnCall[len(fake.verifyArgsForCall)]
	fake.verifyArgsForCall = append(fake.verifyArgsForCall, struct {
		arg1 *kms.VerifyInput
	}{arg1})
	stub := fake.VerifyStub
	fakeReturns := fake.verifyReturns
	fake.recordInvocation("Verify", []interface{}{arg1})
	fake.verifyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) VerifyCallCount() int {
	fake.verifyMutex.RLock()
	defer fake.verifyMutex.RUnlock()
	return len(fake.verifyArgsForCall)
}

func (fake *FakeKMSClient) VerifyCalls(stub func(*kms.VerifyInput) (*kms.VerifyOutput, error)) {
	fake.verifyMutex.Lock()
	defer fake.verifyMutex.Unlock()
	fake.VerifyStub = stub
}

func (fake *FakeKMSClient) VerifyArgsForCall(i int) *kms.VerifyInput {
	fake.verifyMutex.RLock()
	defer fake.verifyMutex.RUnlock()
	argsForCall := fake.verifyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) VerifyReturns(result1 *kms.VerifyOutput, result2 error) {
	fake.verifyMutex.Lock()
	defer fake.verifyMutex.Unlock()
	fake.VerifyStub = nil
	fake.verifyReturns = struct {
		result1 *kms.VerifyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyReturnsOnCall(i int, result1 *kms.VerifyOutput, result2 error) {
	fake.verifyMutex.Lock()
	defer fake.verifyMutex.Unlock()
	fake.VerifyStub = nil
	if fake.verifyReturnsOnCall == nil {
		fake.verifyReturnsOnCall = make(map[int]struct {
			result1 *kms.VerifyOutput
			result2 error
		})
	}
	fake.verifyReturnsOnCall[i] = struct {
		result1 *kms.VerifyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyMac(arg1 *kms.VerifyMacInput) (*kms.VerifyMacOutput, error) {
	fake.verifyMacMutex.Lock()
	ret, specificReturn := fake.verifyMacReturnsOnCall[len(fake.verifyMacArgsForCall)]
	fake.verifyMacArgsForCall = append(fake.verifyMacArgsForCall, struct {
		arg1 *kms.VerifyMacInput
	}{arg1})
	stub := fake.VerifyMacStub
	fakeReturns := fake.verifyMacReturns
	fake.recordInvocation("VerifyMac", []interface{}{arg1})
	fake.verifyMacMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) VerifyMacCallCount() int {
	fake.verifyMacMutex.RLock()
	defer fake.verifyMacMutex.RUnlock()
	return len(fake.verifyMacArgsForCall)
}

func (fake *FakeKMSClient) VerifyMacCalls(stub func(*kms.VerifyMacInput) (*kms.VerifyMacOutput, error)) {
	fake.verifyMacMutex.Lock()
	defer fake.verifyMacMutex.Unlock()
	fake.VerifyMacStub = stub
}

func (fake *FakeKMSClient) VerifyMacArgsForCall(i int) *kms.VerifyMacInput {
	fake.verifyMacMutex.RLock()
	defer fake.verifyMacMutex.RUnlock()
	argsForCall := fake.verifyMacArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) VerifyMacReturns(result1 *kms.VerifyMacOutput, result2 error) {
	fake.verifyMacMutex.Lock()
	defer fake.verifyMacMutex.Unlock()
	fake.VerifyMacStub = nil
	fake.verifyMacReturns = struct {
		result1 *kms.VerifyMacOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyMacReturnsOnCall(i int, result1 *kms.VerifyMacOutput, result2 error) {
	fake.verifyMacMutex.Lock()
	defer fake.verifyMacMutex.Unlock()
	fake.VerifyMacStub = nil
	if fake.verifyMacReturnsOnCall == nil {
		fake.verifyMacReturnsOnCall = make(map[int]struct {
			result1 *kms.VerifyMacOutput
			result2 error
		})
	}
	fake.verifyMacReturnsOnCall[i] = struct {
		result1 *kms.VerifyMacOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyMacRequest(arg1 *kms.VerifyMacInput) (*request.Request, *kms.VerifyMacOutput) {
	fake.verifyMacRequestMutex.Lock()
	ret, specificReturn := fake.verifyMacRequestReturnsOnCall[len(fake.verifyMacRequestArgsForCall)]
	fake.verifyMacRequestArgsForCall = append(fake.verifyMacRequestArgsForCall, struct {
		arg1 *kms.VerifyMacInput
	}{arg1})
	stub := fake.VerifyMacRequestStub
	fakeReturns := fake.verifyMacRequestReturns
	fake.recordInvocation("VerifyMacRequest", []interface{}{arg1})
	fake.verifyMacRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) VerifyMacRequestCallCount() int {
	fake.verifyMacRequestMutex.RLock()
	defer fake.verifyMacRequestMutex.RUnlock()
	return len(fake.verifyMacRequestArgsForCall)
}

func (fake *FakeKMSClient) VerifyMacRequestCalls(stub func(*kms.VerifyMacInput) (*request.Request, *kms.VerifyMacOutput)) {
	fake.verifyMacRequestMutex.Lock()
	defer fake.verifyMacRequestMutex.Unlock()
	fake.VerifyMacRequestStub = stub
}

func (fake *FakeKMSClient) VerifyMacRequestArgsForCall(i int) *kms.VerifyMacInput {
	fake.verifyMacRequestMutex.RLock()
	defer fake.verifyMacRequestMutex.RUnlock()
	argsForCall := fake.verifyMacRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) VerifyMacRequestReturns(result1 *request.Request, result2 *kms.VerifyMacOutput) {
	fake.verifyMacRequestMutex.Lock()
	defer fake.verifyMacRequestMutex.Unlock()
	fake.VerifyMacRequestStub = nil
	fake.verifyMacRequestReturns = struct {
		result1 *request.Request
		result2 *kms.VerifyMacOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyMacRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.VerifyMacOutput) {
	fake.verifyMacRequestMutex.Lock()
	defer fake.verifyMacRequestMutex.Unlock()
	fake.VerifyMacRequestStub = nil
	if fake.verifyMacRequestReturnsOnCall == nil {
		fake.verifyMacRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.VerifyMacOutput
		})
	}
	fake.verifyMacRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.VerifyMacOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyMacWithContext(arg1 context.Context, arg2 *kms.VerifyMacInput, arg3 ...request.Option) (*kms.VerifyMacOutput, error) {
	fake.verifyMacWithContextMutex.Lock()
	ret, specificReturn := fake.verifyMacWithContextReturnsOnCall[len(fake.verifyMacWithContextArgsForCall)]
	fake.verifyMacWithContextArgsForCall = append(fake.verifyMacWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.VerifyMacInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.VerifyMacWithContextStub
	fakeReturns := fake.verifyMacWithContextReturns
	fake.recordInvocation("VerifyMacWithContext", []interface{}{arg1, arg2, arg3})
	fake.verifyMacWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) VerifyMacWithContextCallCount() int {
	fake.verifyMacWithContextMutex.RLock()
	defer fake.verifyMacWithContextMutex.RUnlock()
	return len(fake.verifyMacWithContextArgsForCall)
}

func (fake *FakeKMSClient) VerifyMacWithContextCalls(stub func(context.Context, *kms.VerifyMacInput, ...request.Option) (*kms.VerifyMacOutput, error)) {
	fake.verifyMacWithContextMutex.Lock()
	defer fake.verifyMacWithContextMutex.Unlock()
	fake.VerifyMacWithContextStub = stub
}

func (fake *FakeKMSClient) VerifyMacWithContextArgsForCall(i int) (context.Context, *kms.VerifyMacInput, []request.Option) {
	fake.verifyMacWithContextMutex.RLock()
	defer fake.verifyMacWithContextMutex.RUnlock()
	argsForCall := fake.verifyMacWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) VerifyMacWithContextReturns(result1 *kms.VerifyMacOutput, result2 error) {
	fake.verifyMacWithContextMutex.Lock()
	defer fake.verifyMacWithContextMutex.Unlock()
	fake.VerifyMacWithContextStub = nil
	fake.verifyMacWithContextReturns = struct {
		result1 *kms.VerifyMacOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyMacWithContextReturnsOnCall(i int, result1 *kms.VerifyMacOutput, result2 error) {
	fake.verifyMacWithContextMutex.Lock()
	defer fake.verifyMacWithContextMutex.Unlock()
	fake.VerifyMacWithContextStub = nil
	if fake.verifyMacWithContextReturnsOnCall == nil {
		fake.verifyMacWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.VerifyMacOutput
			result2 error
		})
	}
	fake.verifyMacWithContextReturnsOnCall[i] = struct {
		result1 *kms.VerifyMacOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyRequest(arg1 *kms.VerifyInput) (*request.Request, *kms.VerifyOutput) {
	fake.verifyRequestMutex.Lock()
	ret, specificReturn := fake.verifyRequestReturnsOnCall[len(fake.verifyRequestArgsForCall)]
	fake.verifyRequestArgsForCall = append(fake.verifyRequestArgsForCall, struct {
		arg1 *kms.VerifyInput
	}{arg1})
	stub := fake.VerifyRequestStub
	fakeReturns := fake.verifyRequestReturns
	fake.recordInvocation("VerifyRequest", []interface{}{arg1})
	fake.verifyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) VerifyRequestCallCount() int {
	fake.verifyRequestMutex.RLock()
	defer fake.verifyRequestMutex.RUnlock()
	return len(fake.verifyRequestArgsForCall)
}

func (fake *FakeKMSClient) VerifyRequestCalls(stub func(*kms.VerifyInput) (*request.Request, *kms.VerifyOutput)) {
	fake.verifyRequestMutex.Lock()
	defer fake.verifyRequestMutex.Unlock()
	fake.VerifyRequestStub = stub
}

func (fake *FakeKMSClient) VerifyRequestArgsForCall(i int) *kms.VerifyInput {
	fake.verifyRequestMutex.RLock()
	defer fake.verifyRequestMutex.RUnlock()
	argsForCall := fake.verifyRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKMSClient) VerifyRequestReturns(result1 *request.Request, result2 *kms.VerifyOutput) {
	fake.verifyRequestMutex.Lock()
	defer fake.verifyRequestMutex.Unlock()
	fake.VerifyRequestStub = nil
	fake.verifyRequestReturns = struct {
		result1 *request.Request
		result2 *kms.VerifyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyRequestReturnsOnCall(i int, result1 *request.Request, result2 *kms.VerifyOutput) {
	fake.verifyRequestMutex.Lock()
	defer fake.verifyRequestMutex.Unlock()
	fake.VerifyRequestStub = nil
	if fake.verifyRequestReturnsOnCall == nil {
		fake.verifyRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kms.VerifyOutput
		})
	}
	fake.verifyRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kms.VerifyOutput
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyWithContext(arg1 context.Context, arg2 *kms.VerifyInput, arg3 ...request.Option) (*kms.VerifyOutput, error) {
	fake.verifyWithContextMutex.Lock()
	ret, specificReturn := fake.verifyWithContextReturnsOnCall[len(fake.verifyWithContextArgsForCall)]
	fake.verifyWithContextArgsForCall = append(fake.verifyWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kms.VerifyInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.VerifyWithContextStub
	fakeReturns := fake.verifyWithContextReturns
	fake.recordInvocation("VerifyWithContext", []interface{}{arg1, arg2, arg3})
	fake.verifyWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKMSClient) VerifyWithContextCallCount() int {
	fake.verifyWithContextMutex.RLock()
	defer fake.verifyWithContextMutex.RUnlock()
	return len(fake.verifyWithContextArgsForCall)
}

func (fake *FakeKMSClient) VerifyWithContextCalls(stub func(context.Context, *kms.VerifyInput, ...request.Option) (*kms.VerifyOutput, error)) {
	fake.verifyWithContextMutex.Lock()
	defer fake.verifyWithContextMutex.Unlock()
	fake.VerifyWithContextStub = stub
}

func (fake *FakeKMSClient) VerifyWithContextArgsForCall(i int) (context.Context, *kms.VerifyInput, []request.Option) {
	fake.verifyWithContextMutex.RLock()
	defer fake.verifyWithContextMutex.RUnlock()
	argsForCall := fake.verifyWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKMSClient) VerifyWithContextReturns(result1 *kms.VerifyOutput, result2 error) {
	fake.verifyWithContextMutex.Lock()
	defer fake.verifyWithContextMutex.Unlock()
	fake.VerifyWithContextStub = nil
	fake.verifyWithContextReturns = struct {
		result1 *kms.VerifyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) VerifyWithContextReturnsOnCall(i int, result1 *kms.VerifyOutput, result2 error) {
	fake.verifyWithContextMutex.Lock()
	defer fake.verifyWithContextMutex.Unlock()
	fake.VerifyWithContextStub = nil
	if fake.verifyWithContextReturnsOnCall == nil {
		fake.verifyWithContextReturnsOnCall = make(map[int]struct {
			result1 *kms.VerifyOutput
			result2 error
		})
	}
	fake.verifyWithContextReturnsOnCall[i] = struct {
		result1 *kms.VerifyOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKMSClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelKeyDeletionMutex.RLock()
	defer fake.cancelKeyDeletionMutex.RUnlock()
	fake.cancelKeyDeletionRequestMutex.RLock()
	defer fake.cancelKeyDeletionRequestMutex.RUnlock()
	fake.cancelKeyDeletionWithContextMutex.RLock()
	defer fake.cancelKeyDeletionWithContextMutex.RUnlock()
	fake.connectCustomKeyStoreMutex.RLock()
	defer fake.connectCustomKeyStoreMutex.RUnlock()
	fake.connectCustomKeyStoreRequestMutex.RLock()
	defer fake.connectCustomKeyStoreRequestMutex.RUnlock()
	fake.connectCustomKeyStoreWithContextMutex.RLock()
	defer fake.connectCustomKeyStoreWithContextMutex.RUnlock()
	fake.createAliasMutex.RLock()
	defer fake.createAliasMutex.RUnlock()
	fake.createAliasRequestMutex.RLock()
	defer fake.createAliasRequestMutex.RUnlock()
	fake.createAliasWithContextMutex.RLock()
	defer fake.createAliasWithContextMutex.RUnlock()
	fake.createCustomKeyStoreMutex.RLock()
	defer fake.createCustomKeyStoreMutex.RUnlock()
	fake.createCustomKeyStoreRequestMutex.RLock()
	defer fake.createCustomKeyStoreRequestMutex.RUnlock()
	fake.createCustomKeyStoreWithContextMutex.RLock()
	defer fake.createCustomKeyStoreWithContextMutex.RUnlock()
	fake.createGrantMutex.RLock()
	defer fake.createGrantMutex.RUnlock()
	fake.createGrantRequestMutex.RLock()
	defer fake.createGrantRequestMutex.RUnlock()
	fake.createGrantWithContextMutex.RLock()
	defer fake.createGrantWithContextMutex.RUnlock()
	fake.createKeyMutex.RLock()
	defer fake.createKeyMutex.RUnlock()
	fake.createKeyRequestMutex.RLock()
	defer fake.createKeyRequestMutex.RUnlock()
	fake.createKeyWithContextMutex.RLock()
	defer fake.createKeyWithContextMutex.RUnlock()
	fake.decryptMutex.RLock()
	defer fake.decryptMutex.RUnlock()
	fake.decryptRequestMutex.RLock()
	defer fake.decryptRequestMutex.RUnlock()
	fake.decryptWithContextMutex.RLock()
	defer fake.decryptWithContextMutex.RUnlock()
	fake.deleteAliasMutex.RLock()
	defer fake.deleteAliasMutex.RUnlock()
	fake.deleteAliasRequestMutex.RLock()
	defer fake.deleteAliasRequestMutex.RUnlock()
	fake.deleteAliasWithContextMutex.RLock()
	defer fake.deleteAliasWithContextMutex.RUnlock()
	fake.deleteCustomKeyStoreMutex.RLock()
	defer fake.deleteCustomKeyStoreMutex.RUnlock()
	fake.deleteCustomKeyStoreRequestMutex.RLock()
	defer fake.deleteCustomKeyStoreRequestMutex.RUnlock()
	fake.deleteCustomKeyStoreWithContextMutex.RLock()
	defer fake.deleteCustomKeyStoreWithContextMutex.RUnlock()
	fake.deleteImportedKeyMaterialMutex.RLock()
	defer fake.deleteImportedKeyMaterialMutex.RUnlock()
	fake.deleteImportedKeyMaterialRequestMutex.RLock()
	defer fake.deleteImportedKeyMaterialRequestMutex.RUnlock()
	fake.deleteImportedKeyMaterialWithContextMutex.RLock()
	defer fake.deleteImportedKeyMaterialWithContextMutex.RUnlock()
	fake.describeCustomKeyStoresMutex.RLock()
	defer fake.describeCustomKeyStoresMutex.RUnlock()
	fake.describeCustomKeyStoresRequestMutex.RLock()
	defer fake.describeCustomKeyStoresRequestMutex.RUnlock()
	fake.describeCustomKeyStoresWithContextMutex.RLock()
	defer fake.describeCustomKeyStoresWithContextMutex.RUnlock()
	fake.describeKeyMutex.RLock()
	defer fake.describeKeyMutex.RUnlock()
	fake.describeKeyRequestMutex.RLock()
	defer fake.describeKeyRequestMutex.RUnlock()
	fake.describeKeyWithContextMutex.RLock()
	defer fake.describeKeyWithContextMutex.RUnlock()
	fake.disableKeyMutex.RLock()
	defer fake.disableKeyMutex.RUnlock()
	fake.disableKeyRequestMutex.RLock()
	defer fake.disableKeyRequestMutex.RUnlock()
	fake.disableKeyRotationMutex.RLock()
	defer fake.disableKeyRotationMutex.RUnlock()
	fake.disableKeyRotationRequestMutex.RLock()
	defer fake.disableKeyRotationRequestMutex.RUnlock()
	fake.disableKeyRotationWithContextMutex.RLock()
	defer fake.disableKeyRotationWithContextMutex.RUnlock()
	fake.disableKeyWithContextMutex.RLock()
	defer fake.disableKeyWithContextMutex.RUnlock()
	fake.disconnectCustomKeyStoreMutex.RLock()
	defer fake.disconnectCustomKeyStoreMutex.RUnlock()
	fake.disconnectCustomKeyStoreRequestMutex.RLock()
	defer fake.disconnectCustomKeyStoreRequestMutex.RUnlock()
	fake.disconnectCustomKeyStoreWithContextMutex.RLock()
	defer fake.disconnectCustomKeyStoreWithContextMutex.RUnlock()
	fake.enableKeyMutex.RLock()
	defer fake.enableKeyMutex.RUnlock()
	fake.enableKeyRequestMutex.RLock()
	defer fake.enableKeyRequestMutex.RUnlock()
	fake.enableKeyRotationMutex.RLock()
	defer fake.enableKeyRotationMutex.RUnlock()
	fake.enableKeyRotationRequestMutex.RLock()
	defer fake.enableKeyRotationRequestMutex.RUnlock()
	fake.enableKeyRotationWithContextMutex.RLock()
	defer fake.enableKeyRotationWithContextMutex.RUnlock()
	fake.enableKeyWithContextMutex.RLock()
	defer fake.enableKeyWithContextMutex.RUnlock()
	fake.encryptMutex.RLock()
	defer fake.encryptMutex.RUnlock()
	fake.encryptRequestMutex.RLock()
	defer fake.encryptRequestMutex.RUnlock()
	fake.encryptWithContextMutex.RLock()
	defer fake.encryptWithContextMutex.RUnlock()
	fake.generateDataKeyMutex.RLock()
	defer fake.generateDataKeyMutex.RUnlock()
	fake.generateDataKeyPairMutex.RLock()
	defer fake.generateDataKeyPairMutex.RUnlock()
	fake.generateDataKeyPairRequestMutex.RLock()
	defer fake.generateDataKeyPairRequestMutex.RUnlock()
	fake.generateDataKeyPairWithContextMutex.RLock()
	defer fake.generateDataKeyPairWithContextMutex.RUnlock()
	fake.generateDataKeyPairWithoutPlaintextMutex.RLock()
	defer fake.generateDataKeyPairWithoutPlaintextMutex.RUnlock()
	fake.generateDataKeyPairWithoutPlaintextRequestMutex.RLock()
	defer fake.generateDataKeyPairWithoutPlaintextRequestMutex.RUnlock()
	fake.generateDataKeyPairWithoutPlaintextWithContextMutex.RLock()
	defer fake.generateDataKeyPairWithoutPlaintextWithContextMutex.RUnlock()
	fake.generateDataKeyRequestMutex.RLock()
	defer fake.generateDataKeyRequestMutex.RUnlock()
	fake.generateDataKeyWithContextMutex.RLock()
	defer fake.generateDataKeyWithContextMutex.RUnlock()
	fake.generateDataKeyWithoutPlaintextMutex.RLock()
	defer fake.generateDataKeyWithoutPlaintextMutex.RUnlock()
	fake.generateDataKeyWithoutPlaintextRequestMutex.RLock()
	defer fake.generateDataKeyWithoutPlaintextRequestMutex.RUnlock()
	fake.generateDataKeyWithoutPlaintextWithContextMutex.RLock()
	defer fake.generateDataKeyWithoutPlaintextWithContextMutex.RUnlock()
	fake.generateMacMutex.RLock()
	defer fake.generateMacMutex.RUnlock()
	fake.generateMacRequestMutex.RLock()
	defer fake.generateMacRequestMutex.RUnlock()
	fake.generateMacWithContextMutex.RLock()
	defer fake.generateMacWithContextMutex.RUnlock()
	fake.generateRandomMutex.RLock()
	defer fake.generateRandomMutex.RUnlock()
	fake.generateRandomRequestMutex.RLock()
	defer fake.generateRandomRequestMutex.RUnlock()
	fake.generateRandomWithContextMutex.RLock()
	defer fake.generateRandomWithContextMutex.RUnlock()
	fake.getKeyPolicyMutex.RLock()
	defer fake.getKeyPolicyMutex.RUnlock()
	fake.getKeyPolicyRequestMutex.RLock()
	defer fake.getKeyPolicyRequestMutex.RUnlock()
	fake.getKeyPolicyWithContextMutex.RLock()
	defer fake.getKeyPolicyWithContextMutex.RUnlock()
	fake.getKeyRotationStatusMutex.RLock()
	defer fake.getKeyRotationStatusMutex.RUnlock()
	fake.getKeyRotationStatusRequestMutex.RLock()
	defer fake.getKeyRotationStatusRequestMutex.RUnlock()
	fake.getKeyRotationStatusWithContextMutex.RLock()
	defer fake.getKeyRotationStatusWithContextMutex.RUnlock()
	fake.getParametersForImportMutex.RLock()
	defer fake.getParametersForImportMutex.RUnlock()
	fake.getParametersForImportRequestMutex.RLock()
	defer fake.getParametersForImportRequestMutex.RUnlock()
	fake.getParametersForImportWithContextMutex.RLock()
	defer fake.getParametersForImportWithContextMutex.RUnlock()
	fake.getPublicKeyMutex.RLock()
	defer fake.getPublicKeyMutex.RUnlock()
	fake.getPublicKeyRequestMutex.RLock()
	defer fake.getPublicKeyRequestMutex.RUnlock()
	fake.getPublicKeyWithContextMutex.RLock()
	defer fake.getPublicKeyWithContextMutex.RUnlock()
	fake.importKeyMaterialMutex.RLock()
	defer fake.importKeyMaterialMutex.RUnlock()
	fake.importKeyMaterialRequestMutex.RLock()
	defer fake.importKeyMaterialRequestMutex.RUnlock()
	fake.importKeyMaterialWithContextMutex.RLock()
	defer fake.importKeyMaterialWithContextMutex.RUnlock()
	fake.listAliasesMutex.RLock()
	defer fake.listAliasesMutex.RUnlock()
	fake.listAliasesPagesMutex.RLock()
	defer fake.listAliasesPagesMutex.RUnlock()
	fake.listAliasesPagesWithContextMutex.RLock()
	defer fake.listAliasesPagesWithContextMutex.RUnlock()
	fake.listAliasesRequestMutex.RLock()
	defer fake.listAliasesRequestMutex.RUnlock()
	fake.listAliasesWithContextMutex.RLock()
	defer fake.listAliasesWithContextMutex.RUnlock()
	fake.listGrantsMutex.RLock()
	defer fake.listGrantsMutex.RUnlock()
	fake.listGrantsPagesMutex.RLock()
	defer fake.listGrantsPagesMutex.RUnlock()
	fake.listGrantsPagesWithContextMutex.RLock()
	defer fake.listGrantsPagesWithContextMutex.RUnlock()
	fake.listGrantsRequestMutex.RLock()
	defer fake.listGrantsRequestMutex.RUnlock()
	fake.listGrantsWithContextMutex.RLock()
	defer fake.listGrantsWithContextMutex.RUnlock()
	fake.listKeyPoliciesMutex.RLock()
	defer fake.listKeyPoliciesMutex.RUnlock()
	fake.listKeyPoliciesPagesMutex.RLock()
	defer fake.listKeyPoliciesPagesMutex.RUnlock()
	fake.listKeyPoliciesPagesWithContextMutex.RLock()
	defer fake.listKeyPoliciesPagesWithContextMutex.RUnlock()
	fake.listKeyPoliciesRequestMutex.RLock()
	defer fake.listKeyPoliciesRequestMutex.RUnlock()
	fake.listKeyPoliciesWithContextMutex.RLock()
	defer fake.listKeyPoliciesWithContextMutex.RUnlock()
	fake.listKeysMutex.RLock()
	defer fake.listKeysMutex.RUnlock()
	fake.listKeysPagesMutex.RLock()
	defer fake.listKeysPagesMutex.RUnlock()
	fake.listKeysPagesWithContextMutex.RLock()
	defer fake.listKeysPagesWithContextMutex.RUnlock()
	fake.listKeysRequestMutex.RLock()
	defer fake.listKeysRequestMutex.RUnlock()
	fake.listKeysWithContextMutex.RLock()
	defer fake.listKeysWithContextMutex.RUnlock()
	fake.listResourceTagsMutex.RLock()
	defer fake.listResourceTagsMutex.RUnlock()
	fake.listResourceTagsRequestMutex.RLock()
	defer fake.listResourceTagsRequestMutex.RUnlock()
	fake.listResourceTagsWithContextMutex.RLock()
	defer fake.listResourceTagsWithContextMutex.RUnlock()
	fake.listRetirableGrantsMutex.RLock()
	defer fake.listRetirableGrantsMutex.RUnlock()
	fake.listRetirableGrantsRequestMutex.RLock()
	defer fake.listRetirableGrantsRequestMutex.RUnlock()
	fake.listRetirableGrantsWithContextMutex.RLock()
	defer fake.listRetirableGrantsWithContextMutex.RUnlock()
	fake.putKeyPolicyMutex.RLock()
	defer fake.putKeyPolicyMutex.RUnlock()
	fake.putKeyPolicyRequestMutex.RLock()
	defer fake.putKeyPolicyRequestMutex.RUnlock()
	fake.putKeyPolicyWithContextMutex.RLock()
	defer fake.putKeyPolicyWithContextMutex.RUnlock()
	fake.reEncryptMutex.RLock()
	defer fake.reEncryptMutex.RUnlock()
	fake.reEncryptRequestMutex.RLock()
	defer fake.reEncryptRequestMutex.RUnlock()
	fake.reEncryptWithContextMutex.RLock()
	defer fake.reEncryptWithContextMutex.RUnlock()
	fake.replicateKeyMutex.RLock()
	defer fake.replicateKeyMutex.RUnlock()
	fake.replicateKeyRequestMutex.RLock()
	defer fake.replicateKeyRequestMutex.RUnlock()
	fake.replicateKeyWithContextMutex.RLock()
	defer fake.replicateKeyWithContextMutex.RUnlock()
	fake.retireGrantMutex.RLock()
	defer fake.retireGrantMutex.RUnlock()
	fake.retireGrantRequestMutex.RLock()
	defer fake.retireGrantRequestMutex.RUnlock()
	fake.retireGrantWithContextMutex.RLock()
	defer fake.retireGrantWithContextMutex.RUnlock()
	fake.revokeGrantMutex.RLock()
	defer fake.revokeGrantMutex.RUnlock()
	fake.revokeGrantRequestMutex.RLock()
	defer fake.revokeGrantRequestMutex.RUnlock()
	fake.revokeGrantWithContextMutex.RLock()
	defer fake.revokeGrantWithContextMutex.RUnlock()
	fake.scheduleKeyDeletionMutex.RLock()
	defer fake.scheduleKeyDeletionMutex.RUnlock()
	fake.scheduleKeyDeletionRequestMutex.RLock()
	defer fake.scheduleKeyDeletionRequestMutex.RUnlock()
	fake.scheduleKeyDeletionWithContextMutex.RLock()
	defer fake.scheduleKeyDeletionWithContextMutex.RUnlock()
	fake.signMutex.RLock()
	defer fake.signMutex.RUnlock()
	fake.signRequestMutex.RLock()
	defer fake.signRequestMutex.RUnlock()
	fake.signWithContextMutex.RLock()
	defer fake.signWithContextMutex.RUnlock()
	fake.tagResourceMutex.RLock()
	defer fake.tagResourceMutex.RUnlock()
	fake.tagResourceRequestMutex.RLock()
	defer fake.tagResourceRequestMutex.RUnlock()
	fake.tagResourceWithContextMutex.RLock()
	defer fake.tagResourceWithContextMutex.RUnlock()
	fake.untagResourceMutex.RLock()
	defer fake.untagResourceMutex.RUnlock()
	fake.untagResourceRequestMutex.RLock()
	defer fake.untagResourceRequestMutex.RUnlock()
	fake.untagResourceWithContextMutex.RLock()
	defer fake.untagResourceWithContextMutex.RUnlock()
	fake.updateAliasMutex.RLock()
	defer fake.updateAliasMutex.RUnlock()
	fake.updateAliasRequestMutex.RLock()
	defer fake.updateAliasRequestMutex.RUnlock()
	fake.updateAliasWithContextMutex.RLock()
	defer fake.updateAliasWithContextMutex.RUnlock()
	fake.updateCustomKeyStoreMutex.RLock()
	defer fake.updateCustomKeyStoreMutex.RUnlock()
	fake.updateCustomKeyStoreRequestMutex.RLock()
	defer fake.updateCustomKeyStoreRequestMutex.RUnlock()
	fake.updateCustomKeyStoreWithContextMutex.RLock()
	defer fake.updateCustomKeyStoreWithContextMutex.RUnlock()
	fake.updateKeyDescriptionMutex.RLock()
	defer fake.updateKeyDescriptionMutex.RUnlock()
	fake.updateKeyDescriptionRequestMutex.RLock()
	defer fake.updateKeyDescriptionRequestMutex.RUnlock()
	fake.updateKeyDescriptionWithContextMutex.RLock()
	defer fake.updateKeyDescriptionWithContextMutex.RUnlock()
	fake.updatePrimaryRegionMutex.RLock()
	defer fake.updatePrimaryRegionMutex.RUnlock()
	fake.updatePrimaryRegionRequestMutex.RLock()
	defer fake.updatePrimaryRegionRequestMutex.RUnlock()
	fake.updatePrimaryRegionWithContextMutex.RLock()
	defer fake.updatePrimaryRegionWithContextMutex.RUnlock()
	fake.verifyMutex.RLock()
	defer fake.verifyMutex.RUnlock()
	fake.verifyMacMutex.RLock()
	defer fake.verifyMacMutex.RUnlock()
	fake.verifyMacRequestMutex.RLock()
	defer fake.verifyMacRequestMutex.RUnlock()
	fake.verifyMacWithContextMutex.RLock()
	defer fake.verifyMacWithContextMutex.RUnlock()
	fake.verifyRequestMutex.RLock()
	defer fake.verifyRequestMutex.RUnlock()
	fake.verifyWithContextMutex.RLock()
	defer fake.verifyWithContextMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeKMSClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ environment.KMSClient = new(FakeKMSClient)
